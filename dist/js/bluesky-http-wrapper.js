



var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var service;
        (function (service) {
            /**
             * Provider for the BlueskyHttpWrapper.
             * Enables per-consumer configuration of the http service to set custom configuration URL to fetch data from:
             *  - Client initial configuration URL from the origin the app was loaded from.
             *  - UserRole to use of already fetched from another place.
             */
            var BlueskyHttpWrapperProvider = (function () {
                function BlueskyHttpWrapperProvider() {
                    var _this = this;
                    //#region private properties
                    this.getClientConfigInitializationUrl = 'BlueskyAjaxClientConfiguration/GetAjaxClientConfiguration'; // by default.
                    this.selectedUserRole = null; // by default not-set.
                    //#endregion
                    // Provider's factory function
                    /* @ngInject */
                    this.$get = ["_", "$http", "$window", "$log", "$q", "$location", "Upload", "toaster", function (_, $http, $window, $log, $q, $location, Upload, toaster) {
                        return new service.BlueskyHttpWrapper(_, $http, $window, $log, $q, $location, Upload, toaster, _this.getClientConfigInitializationUrl, _this.selectedUserRole);
                    }];
                    this.$get.$inject = ["_", "$http", "$window", "$log", "$q", "$location", "Upload", "toaster"];
                }
                //#endregion
                //#region public configuration methods
                BlueskyHttpWrapperProvider.prototype.setClientConfigURL = function (clientConfigUrlToUse) {
                    this.getClientConfigInitializationUrl = clientConfigUrlToUse || this.getClientConfigInitializationUrl;
                };
                BlueskyHttpWrapperProvider.prototype.setUserRoleToUse = function (userRole) {
                    this.selectedUserRole = userRole || null;
                };
                return BlueskyHttpWrapperProvider;
            }());
            service.BlueskyHttpWrapperProvider = BlueskyHttpWrapperProvider;
            angular.module('bluesky.httpWrapper', ['toaster', 'ngAnimate', 'ngFileUpload'])
                .constant('_', window._)
                .constant('moment', window.moment)
                .provider('blueskyHttpWrapper', BlueskyHttpWrapperProvider);
        })(service = core.service || (core.service = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var service;
        (function (service) {
            var EndpointTypeEnum = bluesky.core.model.clientConfig.EndpointTypeEnum;
            (function (HttpMethod) {
                HttpMethod[HttpMethod["GET"] = 0] = "GET";
                HttpMethod[HttpMethod["POST"] = 1] = "POST";
                HttpMethod[HttpMethod["PUT"] = 2] = "PUT";
                HttpMethod[HttpMethod["PATCH"] = 3] = "PATCH";
                HttpMethod[HttpMethod["DELETE"] = 4] = "DELETE";
            })(service.HttpMethod || (service.HttpMethod = {}));
            var HttpMethod = service.HttpMethod;
            ;
            var BlueskyHttpWrapper = (function () {
                //#endregion
                //#region ctor
                /* @ngInject */
                BlueskyHttpWrapper.$inject = ["_", "$http", "$window", "$log", "$q", "$location", "Upload", "toaster", "configInitializationURL", "selectedUserRole"];
                function BlueskyHttpWrapper(_, $http, $window, $log, $q, $location, Upload, toaster, configInitializationURL, selectedUserRole) {
                    // 1 - fetch the configuration data necessary for this service to run from the provided endpoint
                    var _this = this;
                    this._ = _;
                    this.$http = $http;
                    this.$window = $window;
                    this.$log = $log;
                    this.$q = $q;
                    this.$location = $location;
                    this.Upload = Upload;
                    this.toaster = toaster;
                    this.configInitializationURL = configInitializationURL;
                    this.selectedUserRole = selectedUserRole;
                    /**
                    * Prepares a {@link ng#$http#config config} object for $http call.
                    * The operations include setting default values when not provided, and setting http headers if needed for :
                    *  - Ajax calls
                    *  - Authorization token
                    *  - Current UserRole.
                    * @param options
                    * @returns {ng.$http.config} the configuration object ready to be injected into a $http call.
                    */
                    this.configureHttpCall = function (method, url, config) {
                        // input validation
                        if (!url || method === null || method === undefined) {
                            _this.$log.error('URL & METHOD parameters are necessary for httpWrapper calls. Aborting.');
                            return null;
                        }
                        // set default config values and custom ones based on endpoints
                        config = config || {};
                        config.endpointType = config.endpointType || EndpointTypeEnum.CurrentDomain; // default value: if not specified, endpoint to use is supposed to be the origin.
                        // search by string representation of endpoint type
                        // TODO MGA: make sure EndpointTypeEnum[invalid value] doesn't return default valid enum value ??? otherwise, dangerous !
                        var currentEndpointConfig = _this.blueskyAjaxClientConfig && _this.blueskyAjaxClientConfig.EndpointConfigurationDictionnary[EndpointTypeEnum[config.endpointType]];
                        //TODO MGA: hard cast is not safe, we may forget to set url & method parameters. TOFIX.
                        // automatically get all non-filtered parameters & keep them for this new object.
                        var configFull = config;
                        //TODO MGA: support mapping between upload & post here ?
                        configFull.method = HttpMethod[method];
                        configFull.headers = config.headers || {};
                        // configure default config flags based on target endpoint
                        switch (config.endpointType) {
                            case EndpointTypeEnum.CoreApi:
                            case EndpointTypeEnum.MarketingApi:
                            case EndpointTypeEnum.SelfcareApi:
                                // Reject explicitly wrong input configurations
                                if (config.disableXmlHttpRequestHeader) {
                                    _this.$log.warn("[BlueskyHttpWrapper][configureHttpCall] [" + configFull.method + " / " + url + "] - API call intended with incompatible configuration options. Aborting ajax call.", config);
                                    return null;
                                }
                                // config values for API endpoints are different from default, so we must specify them.
                                config.disableXmlHttpRequestHeader = false; // by default already enabled, but enfore this header as necessary for calls to WebAPI endpoints.
                                config.useCurrentUserRole = true; // for api calls, force this role to be passed around (should be mandatory to contextualize request to realm of current user).
                                break;
                            case EndpointTypeEnum.QuoteWizard:
                            case EndpointTypeEnum.OrderEntry:
                            case EndpointTypeEnum.OrderTracking:
                                // for OM apps called as endpoints, make sure the XmlHttpRequest header is present (ASP.NET apps).
                                config.disableXmlHttpRequestHeader = false;
                                //TODO MGA: add currentUserRole by default so that OM apps can contextualise the request ?
                                break;
                            case EndpointTypeEnum.Metranet:
                            case EndpointTypeEnum.TechnicalInventory:
                            case EndpointTypeEnum.TemplateGenerator:
                            case EndpointTypeEnum.Salesforce:
                                //TODO MGA: no specific config for those external endpoints ? add custom ones if needed here.
                                break;
                            case EndpointTypeEnum.CurrentDomain:
                                // for ajax calls, make sure the XmlHttpRequest header is present (ASP.NET apps).
                                config.disableXmlHttpRequestHeader = false;
                                // user role is usefull even for current domain so that srv can know the context.
                                config.useCurrentUserRole = true;
                                break;
                            case EndpointTypeEnum.External:
                                //TODO MGA to confirm: we may want to call external urls via ajax, so how to be sure of default value ?
                                config.disableXmlHttpRequestHeader = true; // do not add XmlHttpRequest if external Url by default: might create conflicts on certain servers that don't support this header outside of ASP world.
                                break;
                            default:
                                _this.$log.error("[BlueskyHttpWrapper][configureHttpCall][" + configFull.method + " / " + url + "] - Unsupported endpointType provided: '" + EndpointTypeEnum[config.endpointType || EndpointTypeEnum.CurrentDomain] + "'. Aborting.");
                                return null;
                        }
                        //TODO MGA: should we authorize no valid endpoint configuration loaded for current domain ? AuthToken still usefull or not ? BaseURL still usefull or not ? api suffix ? 
                        // For external URLs, obviously endpoint config is not mandatory, but it could be provided if needed: how to handle this case?
                        //Reject ajax calls intended to external endpoints without necessary configuration loaded from the server.
                        if (config.endpointType !== EndpointTypeEnum.CurrentDomain &&
                            config.endpointType !== EndpointTypeEnum.External &&
                            !currentEndpointConfig) {
                            _this.$log.error("[BlueskyHttpWrapper][configureHttpCall][" + configFull.method + " / " + url + "] - Ajax call intended without expected endpoint configuration loaded from the server for endpointType '" + EndpointTypeEnum[config.endpointType] + "'. Aborting.");
                            return null;
                        }
                        //TODO MGA: set default values after endpoint-specific configurations
                        config.disableXmlHttpRequestHeader = config.disableXmlHttpRequestHeader || false; // default value is enabled (ajax calls on .NET endpoints).
                        config.useCurrentUserRole = config.useCurrentUserRole || false; // default value: don't transmit sensitive information to remote if not explicitly specified.
                        config.disableToasterNotifications = config.disableToasterNotifications || false; //set default value for disableToasterNotifications to false as it's part of the normal behavior expected for this service.
                        // Try to build a valid url from input & endpointType.
                        configFull.url = _this.buildUrlFromContext(url, config.endpointType);
                        if (!configFull.url) {
                            _this.$log.error("[BlueskyHttpWrapper][configureHttpCall] - Unable to build url from urlInput '" + url + "' with endpointType '" + EndpointTypeEnum[config.endpointType] + "'. Aborting ajax call.");
                            return null;
                        }
                        if (!config.disableXmlHttpRequestHeader)
                            //TODO MGA: hard coded header to put in CONST
                            configFull.headers['X-Requested-With'] = 'XMLHttpRequest';
                        if (config.useCurrentUserRole) {
                            // Reject call when missing mandatory information
                            if (!_this.blueskyAjaxClientConfig.CurrentUserRole) {
                                _this.$log.error("[BlueskyHttpWrapper][configureHttpCall][" + configFull.method + " / " + url + "] - Ajax call intended without necessary userRole set in config. Aborting.");
                                return null;
                            }
                            //TODO MGA: hard coded header to put in CONST
                            configFull.headers['OA-UserRole'] = _this.blueskyAjaxClientConfig.CurrentUserRole;
                        }
                        // If auth token provided for target endpoint, add it in header
                        if (currentEndpointConfig && currentEndpointConfig.AuthToken) {
                            //TODO MGA: reject authToken for endpoints that are not 'safe' to share auth token with, such as External ones ? Or authorize this so that server can load an auth token for certain external endpoints ?
                            //TODO MGA: handle token validity endDate: renew auth before the call ! What's the best moment to do it ?
                            //TODO MGA: hard coded header to put in CONST
                            configFull.headers['Authorization'] = 'Bearer ' + currentEndpointConfig.AuthToken;
                        }
                        //TODO MGA: OE specific code, to remove, or at least put in as config param
                        if (_this.$window.block_UI !== undefined)
                            // TODO MGA : type casting, is it okay or not ? better approach ?
                            _this.$window.preventBlockUI = true;
                        return configFull;
                    };
                    /**
                     * Success handler.
                     * Captures the input parameters at the moment of its declaration & return the real handler to be called upon promise completion.
                     * Input parameters:
                     *  - callingConfig: configuration used to make the ajax call, in case the returned promise is null/empty and doesn't contain necessary data for debugging.
                     *  - getCompleteResponseObject: flag indication if we must return the full response object along with headers and status or only the inner data. By default & if not specified, only returns inner data.
                     */
                    this.onSuccess = function (originalConfig) {
                        return function (httpPromise) {
                            if (!httpPromise) {
                                _this.$log.error("[HTTP no-response] Unexpected $http error, no response promise returned.");
                                if (!originalConfig.disableToasterNotifications)
                                    _this.toaster.error('Unexpected behavior', 'Please contact your local support team.');
                                return null;
                            }
                            //TODO MGA: reject if status != 2XX ?
                            //TODO MGA: handle when API is fixed. See http://stackoverflow.com/questions/11746894/what-is-the-proper-rest-response-code-for-a-valid-request-but-an-empty-data
                            //if ((promiseCallback.data === null || promiseCallback.data === undefined) && promiseCallback.status !== 204) {
                            //    this.$log.error('Unexpected response from the server, expected response data but none found.');
                            //    this.toaster.warning('Unexpected response', 'Please contact your local support team.');
                            //    return this.$q.reject(promiseCallback); // Reject promise if not well-formed data
                            //}
                            //TODO MGA: same behavior also on a GET request ? if request is GET and response is 200 with no data, return error ? (pass in parameter request context to log this error).
                            //TODO MGA: get full url of request
                            _this.$log.debug("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "]", httpPromise);
                            // return only the data expected for caller
                            return httpPromise.data;
                        };
                    };
                    /**
                     * Error handler
                     * TODO MGA: angular signatures indicates that parameter is rejection reason, not necessarily httpPromise: investigate & fix if necessary
                     * @param httpPromise
                     * @returns {}
                     */
                    this.onError = function (originalConfig) {
                        return function (httpPromise) {
                            // We suppose in case of no response that the srv didn't send any response.
                            // TODO MGA: may also be a fault in internal $http / ajax client side lib, to distinguish.
                            if (!httpPromise || !httpPromise.data) {
                                httpPromise.data = 'Server not responding';
                                httpPromise.status = 503;
                            }
                            if (!originalConfig.disableToasterNotifications) {
                                var contentType = httpPromise.headers('Content-Type');
                                //check contentType to try to display error message
                                if (contentType && (contentType.indexOf('application/json') > -1 || contentType.indexOf('text/plain') > -1)) {
                                    var message = ""; //default message
                                    //TODO MGA: handle error handling more generically based on input error message contract instead of expecting specific error strcture.
                                    //if (response.data.ModelState) {
                                    //    //TODO MGA : handle this when well formatted server-side
                                    //} else
                                    if (httpPromise.data.Message && angular.isString(httpPromise.data.Message)) {
                                        message = httpPromise.data.Message;
                                    }
                                    else if (angular.isString(httpPromise.data)) {
                                        message = httpPromise.data;
                                    }
                                    //TODO MGA: handle more response codes gracefully.
                                    if (httpPromise.status === 404) {
                                        _this.toaster.warning('Not Found', message);
                                    }
                                    else {
                                        _this.toaster.error('Server response error', message + '\n Status: ' + httpPromise.status);
                                    }
                                }
                                else {
                                    _this.toaster.error('Internal server error', 'Status: ' + httpPromise.status);
                                }
                            }
                            //TODO MGA: get full url of request
                            _this.$log.error("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "]", httpPromise);
                            // We don't recover from error, so we propagate it : below handlers have the choice of reading the error with an error handler or not. See $q promises behavior here : https://github.com/kriskowal/q
                            // This behavior is desired so that we show error inside specific server communication modals at specific places in the app, otherwise show a global alert message, or even do not show anything if not necessary (do not ad an error handler in below handlers of this promise).
                            return _this.$q.reject(httpPromise);
                        };
                    };
                    /**
                     * Function called at the end of an ajax call, regardless of it's success or failure.
                     * @param response
                     * TODO MGA inversion of responsability: make this extensible so that specifc apps can plug into this event workflow
                     */
                    this.finally = function () {
                        //TODO MGA: OE-specific code
                        if (_this.$window.block_UI !== undefined)
                            // TODO MGA : type casting, is it okay or not ? better approach ?
                            _this.$window.preventBlockUI = false;
                    };
                    var configurationEndpointUrl = this.buildUrlFromContext(configInitializationURL, EndpointTypeEnum.CurrentDomain);
                    if (!configurationEndpointUrl) {
                        this.$log.error("[BlueskyHttpWrapper][Initialization] - Unable to build url from initialConfig url '" + configInitializationURL + "' with endpointType '" + EndpointTypeEnum[EndpointTypeEnum.CurrentDomain] + "'. Aborting blueskyHttpService init.");
                        return;
                    }
                    //TODO MGA: custom config for headers hard coded, to mutualize with const
                    this.getAjaxConfigFromServerPromise = this.$http.get(configurationEndpointUrl, { headers: { 'X-Requested-With': 'XMLHttpRequest' } })
                        .then(
                    // success
                    function (clientConfigPromise) {
                        //TODO MGA: reject status not in 2XX ?
                        if (!clientConfigPromise.data) {
                            var msg = "[BlueskyHttpWrapper][Initialization] - Unable to retrieve http config data from '" + configInitializationURL + "'. Aborting blueskyHttpWrapperService initialization.";
                            _this.$log.error(msg);
                            //TODO MGA: toaster ?
                            return _this.$q.reject(msg);
                        }
                        _this.$log.info('[BlueskyHttpWrapper][Initialization] - Successfully loaded clientConfig from srv:', clientConfigPromise.data);
                        _this.blueskyAjaxClientConfig = clientConfigPromise.data;
                        return clientConfigPromise.data;
                    }, 
                    // error
                    function (error) {
                        _this.$log.error('[BlueskyHttpWrapper][Initialization] - Unable to retrieve API config. Aborting blueskyHttpWrapperService initialization. Srv msg: ', error);
                        //TODO MGA: show toaster ? based on provider config flag ?
                        return _this.$q.reject(error);
                    }).then(
                    // success
                    function (blueskyClientConfig) {
                        //TODO MGA: handle case where client-side userRole was provided and not == srv-side user role !
                        if (!blueskyClientConfig.CurrentUserRole) {
                            //If not provided by domain from which code was loaded, then try to fetch default userRole from CAPI endpoint
                            _this.$log.info('[BlueskyHttpWrapper][Initialization] - No default UserRole provided by current domain, trying to fetch it from CAPI.');
                            var coreApiConfig = blueskyClientConfig.EndpointConfigurationDictionnary[EndpointTypeEnum[EndpointTypeEnum.CoreApi]];
                            if (!coreApiConfig) {
                                var msg = '[BlueskyHttpWrapper][Initialization] - Failed to retrieve necessary CoreApi endpoint config to fetch userSSO. Aborting.';
                                _this.$log.error(msg);
                                return _this.$q.reject(msg);
                            }
                            //TODO MGA: factorize with configureHttpCall() !! this is a special case where we cannot use ajax() DRY method ...
                            var customConfig = {
                                headers: {
                                    'X-Requested-With': 'XMLHttpRequest',
                                    'Authorization': 'Bearer ' + coreApiConfig.AuthToken
                                }
                            };
                            var getUserSsoFullUrl = _this.buildUrlFromContext('user-sso?profile=', EndpointTypeEnum.CoreApi);
                            return _this.$http.get(getUserSsoFullUrl, customConfig).then(function (userSsoPromise) {
                                if (!userSsoPromise || !userSsoPromise.data || !userSsoPromise.data.UserRoleEntry) {
                                    var coreApiConfigMissingMsg = '[BlueskyHttpWrapper][Initialization] - Unable to retrieve CoreAPI default userSSO. Aborting httpWrapperService initialization.';
                                    _this.$log.error(coreApiConfigMissingMsg);
                                    return _this.$q.reject(coreApiConfigMissingMsg);
                                }
                                var userSso = userSsoPromise.data;
                                _this.$log.info("[BlueskyHttpWrapper][Initialization] - Default userSSO loaded from CAPI: '" + userSso.UserDisplayName + "'.", userSso);
                                if (selectedUserRole)
                                    _this.$log.info("[BlueskyHttpWrapper][Initialization] - Client app provided saved UserRole. Assigning it.", _this.selectedUserRole);
                                //TODO MGA: make sure selectedUserRole is available in the list of userSSO roles, otherwise select default !
                                //TODO MGA: how to inform back the DA that selectedUserRole was reset ? invert responsability & store userRole in localStorage from this service ?
                                var userRoleToUse = selectedUserRole || userSso.UserRoleEntry;
                                //TODO MGA: this needs to be put in shared extension method / service
                                _this.blueskyAjaxClientConfig.CurrentUserRole = userRoleToUse.Name + " " + userRoleToUse.Role + " " + userRoleToUse.Silo;
                                _this.blueskyAjaxClientConfig.CurrentUser = userSso;
                                return blueskyClientConfig;
                            });
                        }
                        else {
                            //TODO MGA: we only load userSSO if no userRole was provided srv-side, should we load it in all cases ?
                            // already defined userRole sent from origin app, use it & set it as default.
                            return blueskyClientConfig;
                        }
                    });
                }
                //#endregion
                //#region public methods
                BlueskyHttpWrapper.prototype.get = function (url, config) {
                    return this.ajax(HttpMethod.GET, url, config);
                };
                BlueskyHttpWrapper.prototype.delete = function (url, config) {
                    return this.ajax(HttpMethod.DELETE, url, config);
                };
                BlueskyHttpWrapper.prototype.post = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    ;
                    return this.ajax(HttpMethod.POST, url, config);
                };
                BlueskyHttpWrapper.prototype.put = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    return this.ajax(HttpMethod.PUT, url, config);
                };
                BlueskyHttpWrapper.prototype.patch = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    return this.ajax(HttpMethod.PATCH, url, config);
                };
                /**
                 * TODO MGA: not DRY with ajax method, how to keep it in sync ?
                 * @param url
                 * @param file
                 * @param config
                 */
                BlueskyHttpWrapper.prototype.upload = function (url, file, config) {
                    var _this = this;
                    if (!file && (!config || !config.file)) {
                        this.$log.error('Cannot start upload with null {file} parameter.');
                        return null;
                    }
                    config = config || {};
                    config.file = file || config.file; //TODO MGA : do not expose file in IBlueskyHttpRequestConfig ?
                    config.data = config.data || {};
                    if (config.uploadInBase64Json) {
                        //TODO MGA: make sure this delays next call and upload is not done before base64 encoding is finished, even if promise is already resolved ???
                        return this.Upload.base64DataUrl(file).then(function (fileBase64Url) {
                            //TODO MGA: hard-coded key to fetch base64 encoding, to parametrize with server-side !
                            config.data.fileBase64Url = fileBase64Url;
                            //normal post in case of base64-encoded data
                            return _this.ajax(HttpMethod.POST, url, config);
                        });
                    }
                    else {
                        config.data.fileFormDataName = 'file'; // file formData name ('Content-Disposition'), server side request form name
                        //TODO MGA : do not block if not call to internal API ? (initCall)
                        return this.getAjaxConfigFromServerPromise.then(function () {
                            //TODO MGA : behavior duplication with this.ajax, not DRY, to improve
                            var requestConfig = _this.configureHttpCall(HttpMethod.POST, url, config);
                            if (requestConfig)
                                return _this.Upload.upload(requestConfig) //TODO MGA : not safe hard cast
                                    .then(_this.onSuccess(config), _this.onError(config), config.uploadProgress) //TODO MGA : uploadProgress callback ok ?
                                    .finally(_this.finally);
                            return null; //TODO MGA: what to return ?
                        });
                    }
                };
                /**
                 * This method is used to download a file in the form of a byte-stream from an endpoint and wrap it into a FileContent object with name, type & size properties read from the HTTP response headers of the serveur.
                 * It is the responsability of the consumer to do something with the wrapped byteArray (for example download the file, or show it inside the webPage etc).
                 * TODO MGA: not DRY with ajax method, how to keep it in sync ?
                 * @param url
                 * @param expectedName
                 * @param expectedSize
                 * @param expectedType
                 * @param config
                 */
                BlueskyHttpWrapper.prototype.getFile = function (url, config) {
                    var _this = this;
                    return this.getAjaxConfigFromServerPromise.then(function () {
                        var angularHttpConfig = _this.configureHttpCall(HttpMethod.GET, url, config);
                        // if no config returned, configuration failed, do not start ajax request
                        if (!angularHttpConfig) {
                            return _this.$q.reject('Unable to configure request correctly. Aborting getFile ajax call.');
                        }
                        // specifically expect raw response type, otherwise byte stream responses are corrupted.
                        angularHttpConfig.responseType = 'arraybuffer';
                        //Expected ArrayBuffer response = byte array
                        return _this.$http(angularHttpConfig)
                            .then(function (httpResponse) {
                            //benefit from successCallback validation before continuing
                            var arrayBuffer = _this.onSuccess(config)(httpResponse);
                            //TODO MGA: promise rejection vs. return null ?
                            if (!arrayBuffer)
                                return null; //stop processing if unable to retrieve byte array
                            //read file info from response-headers
                            var fileContent = {
                                name: _this.getFileNameFromHeaderContentDisposition(httpResponse.headers('content-disposition')) || null,
                                size: Number(httpResponse.headers('content-length')) || 0,
                                type: httpResponse.headers('content-type') || 'application/octet-stream',
                                content: arrayBuffer
                            };
                            return fileContent;
                        }, _this.onError)
                            .finally(_this.finally);
                    });
                };
                /**
                 * Tries to parse the input url :
                 * If it seems to be a full URL, then return as is (considers it external Url)
                 * Otherwise, tries to find the base URL of the current BlueSky app with or without the included Controller and returns the full Url
                 * @param urlInput : TODO MGA: document different kind of urls that this method can take as input (full, partial etc)
                 * @return null if not able to compute url. Otherwise, url of the request either partial or full based on endpointType.
                 */
                BlueskyHttpWrapper.prototype.buildUrlFromContext = function (urlInput, endpointType) {
                    if (!urlInput) {
                        this.$log.error('No URL input provided.');
                        return null;
                    }
                    // If Url starts with http:// or https:// => return as is, even if endpointType is not external.
                    if (urlInput.slice(0, 'http://'.length) === 'http://' ||
                        urlInput.slice(0, 'https://'.length) === 'https://') {
                        if (endpointType !== EndpointTypeEnum.External)
                            this.$log.warn('Full URL provided for a call that is not flagged as \'External\' endpointType, this is bad practice as only the blueskyWrapper should know about the baseURL of target endpoints (loaded from server, depending on the current env). Use partial URLs.');
                        return urlInput;
                    }
                    // Else, we have a partial URL to complete: use provided endpoint type to determine how to complete url.
                    // Default value for endpointType if not provided is origin. TODO MGA: rule to discuss, here for retro-compatibility.
                    endpointType = endpointType || EndpointTypeEnum.CurrentDomain;
                    var baseUrl;
                    if (endpointType === EndpointTypeEnum.External) {
                        this.$log.warn('Partial url provided for a call with endpointType flagged as \'External\': the call will probably fail.');
                        // do not modify provided url if external (we cannot know how to complete it, even if partial).
                        return urlInput;
                    }
                    else if (endpointType === EndpointTypeEnum.CurrentDomain) {
                        //TODO MGA: not loading the endpointConfig for current domain means we can't access endpointAPIsuffix if it exists, should we load the endpointConfig for this case too ?? & handle it the same way as other endpoints ?
                        // Regex trying to determine if the input fragment contains a / between two character suites => controller given as input, otherwise, action on same controller expected
                        var controllerIsPresentRegex = /\w+\/\w+/;
                        var actionIsOnSameController = !controllerIsPresentRegex.test(urlInput);
                        baseUrl = this.getUrlPath(actionIsOnSameController);
                    }
                    else {
                        // For all other endpointTypes: compute URL as a combination of baseURL & suffix if present, as provided by server-configuration.
                        if (!this.blueskyAjaxClientConfig ||
                            !this.blueskyAjaxClientConfig.EndpointConfigurationDictionnary) {
                            this.$log.error('Expected endpointConfigurationDictionnary provided but none found. Aborting.');
                            return null;
                        }
                        // TODO MGA HACKY: search by string representation of endpoint type in dict due to serialization limits
                        var endpointConfig = this.blueskyAjaxClientConfig.EndpointConfigurationDictionnary[EndpointTypeEnum[endpointType]];
                        if (!endpointConfig) {
                            this.$log.error("EndpointType '" + EndpointTypeEnum[endpointType] + "' is not 'External' or 'CurrentDomain', expected corresponding endpointConfiguration provided in blueskyAjaxClientConfig.endpointConfigurationDictionnary but none found. Aborting.");
                            return null;
                        }
                        baseUrl = endpointConfig.EndpointBaseURL + (endpointConfig.EndpointSuffix || '');
                    }
                    //TODO MGA: how to handle OM apps external calls without session provided ? will result in a redirect and call may fail ?
                    // Boolean used to try to determine correct full url (add / or not before the url fragment depending on if found or not)
                    var urlFragmentStartsWithSlash = urlInput.slice(0, 1) === '/';
                    var baseUrlFragmentEndsWithSlash = baseUrl.slice(baseUrl.length - 1, baseUrl.length) === '/';
                    //based on starting/trailing slashes, return full url.
                    if (baseUrlFragmentEndsWithSlash && urlFragmentStartsWithSlash)
                        // remove last '/' on baseUrl
                        return baseUrl.slice(0, baseUrl.length - 1) + urlInput;
                    else if (!baseUrlFragmentEndsWithSlash && !urlFragmentStartsWithSlash)
                        return baseUrl + '/' + urlInput;
                    else if ((baseUrlFragmentEndsWithSlash && !urlFragmentStartsWithSlash) ||
                        (!baseUrlFragmentEndsWithSlash && urlFragmentStartsWithSlash))
                        return baseUrl + urlInput;
                    return null;
                };
                //#endregion
                //#region private methods
                /**
                 * Utility method.
                 * Main caller that all wrapper calls (get, delete, post, put) must use to share common behavior.
                 * @param config
                 */
                BlueskyHttpWrapper.prototype.ajax = function (method, url, config) {
                    var _this = this;
                    //TODO MGA : make sure getConfig resolve automatically without overhead once first call sucessfull.
                    //TODO MGA : do not block if not call to internal API (initCall)
                    return this.getAjaxConfigFromServerPromise.then(function () {
                        var angularHttpConfig = _this.configureHttpCall(method, url, config);
                        if (angularHttpConfig)
                            return _this.$http(angularHttpConfig)
                                .then(_this.onSuccess(config), _this.onError(config))
                                .finally(_this.finally);
                    });
                };
                // TODO MGA : using method from Layout.js : to document to not handle duplicate code !!
                //TODO MGA: unrobust, needs solid refacto to make it more generic when on origin domain !
                BlueskyHttpWrapper.prototype.getUrlPath = function (actionIsOnSameController) {
                    var baseUrlOmAppsRegex = /(\/\w+\/\(S\(\w+\)\))\/\w+/;
                    var baseUrlAspAppsRegex = /(\/\w+)\/\w+/;
                    var url = this.$window.location.pathname;
                    var baseUrlOmAppsMatches = baseUrlOmAppsRegex.exec(url);
                    var baseUrlAspAppsMatches = baseUrlAspAppsRegex.exec(url);
                    var baseUrlWithControllerName = null;
                    var baseUrl = null;
                    // 2 matches = regex matches + the capturing group
                    if (baseUrlOmAppsMatches && baseUrlOmAppsMatches.length && baseUrlOmAppsMatches.length === 2) {
                        baseUrlWithControllerName = baseUrlOmAppsMatches[0];
                        baseUrl = baseUrlOmAppsMatches[1];
                    }
                    else if (baseUrlAspAppsMatches && baseUrlAspAppsMatches.length && baseUrlAspAppsMatches.length === 2) {
                        baseUrlWithControllerName = baseUrlAspAppsMatches[0];
                        baseUrl = baseUrlAspAppsMatches[1];
                    }
                    if (actionIsOnSameController && baseUrlWithControllerName) {
                        return baseUrlWithControllerName;
                    }
                    else if (baseUrl) {
                        return baseUrl;
                    }
                    return '';
                };
                //TODO MGA: OM-specific ASP MVC code, not used ATM, to remove
                BlueskyHttpWrapper.prototype.getCurrentSessionID = function () {
                    //TODO MGA : magic regexp to fetch SessionID in URL, to store elsewhere !
                    var sessionRegex = /https:\/\/[\w.]+\/[\w.]+\/(\(S\(\w+\)\))\/.*/;
                    //var sessionRegex = /https:\/\/[\w.]+\/OrderEntry\/(\(S\(\w+\)\))\/.*/;
                    // TODO MGA : update regexp to the one below
                    //var baseUrlRegex = /(https:\/\/[\w.-]+\/[\w.-]+\/\(S\(\w+\)\)\/)\w+/;
                    var path = this.$location.absUrl();
                    var regexpArray = sessionRegex.exec(path);
                    if (!regexpArray) {
                        this.$log.error('Unable to recognized searched pattern in current url location to retrieve sessionID.');
                        return '';
                    }
                    if (regexpArray.length === 1) {
                        this.$log.error('Unable to find sessionID in searched pattern in current url.');
                        return '';
                    }
                    if (regexpArray.length > 2) {
                        this.$log.error('Too many matches found for the sessionID search in the current url.');
                        return '';
                    }
                    return regexpArray[1];
                };
                /**
                 * Trim the content-disposition header to return only the filename.
                 * @param contentDispositionHeader
                 */
                BlueskyHttpWrapper.prototype.getFileNameFromHeaderContentDisposition = function (contentDispositionHeader) {
                    if (!contentDispositionHeader)
                        return null;
                    var result = contentDispositionHeader.split(';')[1].trim().split('=')[1];
                    return result.replace(/"/g, '');
                };
                return BlueskyHttpWrapper;
            }());
            service.BlueskyHttpWrapper = BlueskyHttpWrapper;
        })(service = core.service || (core.service = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1vZGVscy9ibHVlc2t5LWh0dHAtcmVxdWVzdC1jb25maWcubW9kZWwudHMiLCJibHVlc2t5LWh0dHAtd3JhcHBlci5wcm92aWRlci50cyIsImJsdWVza3ktaHR0cC13cmFwcGVyLnNlcnZpY2UudHMiLCJibHVlc2t5LWh0dHAtd3JhcHBlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFxQkM7Ozs7QUNyQkQsSUFBVTtBQUFWLENBQUEsVUFBVSxTQUFPO0lBQUMsSUFBQTtJQUFBLENBQUEsVUFBQSxNQUFJO1FBQUMsSUFBQTtRQUFBLENBQUEsVUFBQSxTQUFROzs7Ozs7O1lBUzNCLElBQUEsOEJBQUEsWUFBQTtnQkFBQSxTQUFBLDZCQUFBO29CQUFBLElBQUEsUUFBQTs7b0JBSVksS0FBQSxtQ0FBMkM7b0JBQzNDLEtBQUEsbUJBQXFDOzs7O29CQWtCdEMsS0FBQSxpRkFBTyxVQUFDLEdBQ1gsT0FDQSxTQUNBLE1BQ0EsSUFDQSxXQUNBLFFBQ0EsU0FBa0M7d0JBRWxDLE9BQU8sSUFBSSxRQUFBLG1CQUFtQixHQUFHLE9BQU8sU0FBUyxNQUFNLElBQUksV0FBVyxRQUFRLFNBQVMsTUFBSyxrQ0FBa0MsTUFBSzs7Ozs7O2dCQXJCaEksMkJBQUEsVUFBQSxxQkFBUCxVQUEwQixzQkFBNEI7b0JBQ2xELEtBQUssbUNBQW1DLHdCQUF3QixLQUFLOztnQkFHbEUsMkJBQUEsVUFBQSxtQkFBUCxVQUF3QixVQUEwQjtvQkFDOUMsS0FBSyxtQkFBbUIsWUFBWTs7Z0JBa0I1QyxPQUFBOztZQWxDYSxRQUFBLDZCQUEwQjtZQW9DdkMsUUFBUSxPQUFPLHVCQUF1QixDQUFDLFdBQVcsYUFBYTtpQkFDMUQsU0FBMkIsS0FBSyxPQUFPO2lCQUN2QyxTQUE4QixVQUFVLE9BQU87aUJBQy9DLFNBQVMsc0JBQXNCO1dBaERqQixVQUFBLEtBQUEsWUFBQSxLQUFBLFVBQU87T0FBWixPQUFBLFFBQUEsU0FBQSxRQUFBLE9BQUk7R0FBWixZQUFBLFVBQU87O0FDQWpCLElB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LFNBQVMsR0FBRzt3QkFDeEIsS0FBSyxLQUFLLE1BQU07d0JBQ2hCLE9BQU87O29CQUdYLE9BQU8sWUFBWTs7Ozs7O2dCQU9mLG1CQUFBLFVBQUEsMENBQVIsVUFBZ0QsMEJBQWdDO29CQUM1RSxJQUFJLENBQUM7d0JBQTBCLE9BQU87b0JBRXRDLElBQUksU0FBUyx5QkFBeUIsTUFBTSxLQUFLLEdBQUcsT0FBTyxNQUFNLEtBQUs7b0JBRXRFLE9BQU8sT0FBTyxRQUFRLE1BQU07O2dCQUlwQyxPQUFBOztZQXRxQmEsUUFBQSxxQkFBa0I7V0E3Q1osVUFBQSxLQUFBLFlBQUEsS0FBQSxVQUFPO09BQVosT0FBQSxRQUFBLFNBQUEsUUFBQSxPQUFJO0dBQVosWUFBQSxVQUFPO0FDOGxCakIiLCJmaWxlIjoiYmx1ZXNreS1odHRwLXdyYXBwZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJuYW1lc3BhY2UgYmx1ZXNreS5jb3JlLm1vZGVsLmJsdWVza3lIdHRwQ2xpZW50IHtcclxuXHJcbiAgICBpbXBvcnQgRW5kcG9pbnRUeXBlRW51bSA9IGNvcmUubW9kZWwuY2xpZW50Q29uZmlnLkVuZHBvaW50VHlwZUVudW07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUT0RPIE1HQSBEb2NcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGludGVyZmFjZSBJQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnIGV4dGVuZHMgbmcuSVJlcXVlc3RTaG9ydGN1dENvbmZpZyB7XHJcblxyXG4gICAgICAgIGVuZHBvaW50VHlwZT86IEVuZHBvaW50VHlwZUVudW07XHJcblxyXG4gICAgICAgIHVzZUN1cnJlbnRVc2VyUm9sZT86IGJvb2xlYW47XHJcbiAgICAgICAgZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyPzogYm9vbGVhbjtcclxuICAgICAgICBkaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnM/OiBib29sZWFuO1xyXG5cclxuICAgICAgICAvL1RPRE8gTUdBOiBlbmNhcHN1bGF0ZSBpbiBhbiBVcGxvYWRDb25maWcgb2JqZWN0XHJcbiAgICAgICAgZmlsZT86IEZpbGUsXHJcbiAgICAgICAgdXBsb2FkSW5CYXNlNjRKc29uPzogYm9vbGVhbjtcclxuICAgICAgICB1cGxvYWRQcm9ncmVzcz86ICgpID0+IGFueTtcclxuXHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgYmx1ZXNreS5jb3JlLnNlcnZpY2Uge1xyXG4gICAgaW1wb3J0IFVzZXJSb2xlRW50cnlEdG8gPSBibHVlc2t5LmNvcmUubW9kZWwudXNlck1hbmFnZW1lbnQuSVVzZXJSb2xlRW50cnlEdG87XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm92aWRlciBmb3IgdGhlIEJsdWVza3lIdHRwV3JhcHBlci5cclxuICAgICAqIEVuYWJsZXMgcGVyLWNvbnN1bWVyIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGh0dHAgc2VydmljZSB0byBzZXQgY3VzdG9tIGNvbmZpZ3VyYXRpb24gVVJMIHRvIGZldGNoIGRhdGEgZnJvbTpcclxuICAgICAqICAtIENsaWVudCBpbml0aWFsIGNvbmZpZ3VyYXRpb24gVVJMIGZyb20gdGhlIG9yaWdpbiB0aGUgYXBwIHdhcyBsb2FkZWQgZnJvbS5cclxuICAgICAqICAtIFVzZXJSb2xlIHRvIHVzZSBvZiBhbHJlYWR5IGZldGNoZWQgZnJvbSBhbm90aGVyIHBsYWNlLlxyXG4gICAgICovXHJcbiAgICBleHBvcnQgY2xhc3MgQmx1ZXNreUh0dHBXcmFwcGVyUHJvdmlkZXIgaW1wbGVtZW50cyBuZy5JU2VydmljZVByb3ZpZGVyIHtcclxuXHJcbiAgICAgICAgLy8jcmVnaW9uIHByaXZhdGUgcHJvcGVydGllc1xyXG5cclxuICAgICAgICBwcml2YXRlIGdldENsaWVudENvbmZpZ0luaXRpYWxpemF0aW9uVXJsOiBzdHJpbmcgPSAnQmx1ZXNreUFqYXhDbGllbnRDb25maWd1cmF0aW9uL0dldEFqYXhDbGllbnRDb25maWd1cmF0aW9uJzsgLy8gYnkgZGVmYXVsdC5cclxuICAgICAgICBwcml2YXRlIHNlbGVjdGVkVXNlclJvbGU6IFVzZXJSb2xlRW50cnlEdG8gPSBudWxsOyAvLyBieSBkZWZhdWx0IG5vdC1zZXQuXHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHVibGljIGNvbmZpZ3VyYXRpb24gbWV0aG9kc1xyXG5cclxuICAgICAgICBwdWJsaWMgc2V0Q2xpZW50Q29uZmlnVVJMKGNsaWVudENvbmZpZ1VybFRvVXNlOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRDbGllbnRDb25maWdJbml0aWFsaXphdGlvblVybCA9IGNsaWVudENvbmZpZ1VybFRvVXNlIHx8IHRoaXMuZ2V0Q2xpZW50Q29uZmlnSW5pdGlhbGl6YXRpb25Vcmw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc2V0VXNlclJvbGVUb1VzZSh1c2VyUm9sZTogVXNlclJvbGVFbnRyeUR0byk6IHZvaWQge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkVXNlclJvbGUgPSB1c2VyUm9sZSB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgICAgIC8vIFByb3ZpZGVyJ3MgZmFjdG9yeSBmdW5jdGlvblxyXG4gICAgICAgIC8qIEBuZ0luamVjdCAqL1xyXG4gICAgICAgIHB1YmxpYyAkZ2V0ID0gKF86IFVuZGVyc2NvcmVTdGF0aWMsXHJcbiAgICAgICAgICAgICRodHRwOiBuZy5JSHR0cFNlcnZpY2UsXHJcbiAgICAgICAgICAgICR3aW5kb3c6IG5nLklXaW5kb3dTZXJ2aWNlLFxyXG4gICAgICAgICAgICAkbG9nOiBuZy5JTG9nU2VydmljZSxcclxuICAgICAgICAgICAgJHE6IG5nLklRU2VydmljZSxcclxuICAgICAgICAgICAgJGxvY2F0aW9uOiBuZy5JTG9jYXRpb25TZXJ2aWNlLFxyXG4gICAgICAgICAgICBVcGxvYWQ6IG5nLmFuZ3VsYXJGaWxlVXBsb2FkLklVcGxvYWRTZXJ2aWNlLFxyXG4gICAgICAgICAgICB0b2FzdGVyOiBuZ3RvYXN0ZXIuSVRvYXN0ZXJTZXJ2aWNlKTogSUJsdWVza3lIdHRwV3JhcHBlciA9PiB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsdWVza3lIdHRwV3JhcHBlcihfLCAkaHR0cCwgJHdpbmRvdywgJGxvZywgJHEsICRsb2NhdGlvbiwgVXBsb2FkLCB0b2FzdGVyLCB0aGlzLmdldENsaWVudENvbmZpZ0luaXRpYWxpemF0aW9uVXJsLCB0aGlzLnNlbGVjdGVkVXNlclJvbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhbmd1bGFyLm1vZHVsZSgnYmx1ZXNreS5odHRwV3JhcHBlcicsIFsndG9hc3RlcicsICduZ0FuaW1hdGUnLCAnbmdGaWxlVXBsb2FkJ10pXHJcbiAgICAgICAgLmNvbnN0YW50PFVuZGVyc2NvcmVTdGF0aWM+KCdfJywgd2luZG93Ll8pXHJcbiAgICAgICAgLmNvbnN0YW50PG1vbWVudC5Nb21lbnRTdGF0aWM+KCdtb21lbnQnLCB3aW5kb3cubW9tZW50KVxyXG4gICAgICAgIC5wcm92aWRlcignYmx1ZXNreUh0dHBXcmFwcGVyJywgQmx1ZXNreUh0dHBXcmFwcGVyUHJvdmlkZXIpO1xyXG59IiwibmFtZXNwYWNlIGJsdWVza3kuY29yZS5zZXJ2aWNlIHtcclxuXHJcbiAgICBpbXBvcnQgVXNlclJvbGVFbnRyeUR0byA9IGJsdWVza3kuY29yZS5tb2RlbC51c2VyTWFuYWdlbWVudC5JVXNlclJvbGVFbnRyeUR0bztcclxuICAgIGltcG9ydCBVc2VyU3NvRHRvID0gYmx1ZXNreS5jb3JlLm1vZGVsLnVzZXJNYW5hZ2VtZW50LklVc2VyU3NvRHRvO1xyXG4gICAgaW1wb3J0IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyA9IGJsdWVza3kuY29yZS5tb2RlbC5ibHVlc2t5SHR0cENsaWVudC5JQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnO1xyXG4gICAgaW1wb3J0IEZpbGVDb250ZW50ID0gYmx1ZXNreS5jb3JlLm1vZGVsLmJsdWVza3lIdHRwQ2xpZW50LkZpbGVDb250ZW50O1xyXG4gICAgaW1wb3J0IEJsdWVza3lBamF4Q2xpZW50Q29uZmlndXJhdGlvbkR0byA9IGJsdWVza3kuY29yZS5tb2RlbC5jbGllbnRDb25maWcuSUJsdWVza3lBamF4Q2xpZW50Q29uZmlndXJhdGlvbkR0bztcclxuICAgIGltcG9ydCBFbmRwb2ludFR5cGVFbnVtID0gYmx1ZXNreS5jb3JlLm1vZGVsLmNsaWVudENvbmZpZy5FbmRwb2ludFR5cGVFbnVtO1xyXG4gICAgaW1wb3J0IEFqYXhDbGllbnRFbmRwb2ludENvbmZpZ3VyYXRpb25EdG8gPSBibHVlc2t5LmNvcmUubW9kZWwuY2xpZW50Q29uZmlnLklBamF4Q2xpZW50RW5kcG9pbnRDb25maWd1cmF0aW9uRHRvO1xyXG5cclxuICAgIGV4cG9ydCBlbnVtIEh0dHBNZXRob2QgeyBHRVQsIFBPU1QsIFBVVCwgUEFUQ0gsIERFTEVURSB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVE9ETyBNR0EgY29tbWVudFxyXG4gICAgICovXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIElCbHVlc2t5SHR0cFdyYXBwZXIge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGwgc3J2LXNpZGUgY29uZmlndXJhdGlvbiBvZiB0aGlzIGh0dHAgY2xpZW50LCBwcm92aWRlZCBieSB0aGUgaW5qZWN0ZWQgJ2NvbmZpZ0luaXRpYWxpemF0aW9uVVJMJyBlbmRwb2ludC5cclxuICAgICAgICAgKiBUaGlzIGNvbmZpZ3VyYXRpb24gZGF0YSBpcyBsb2FkZWQgdXBvbiBpbml0aWFsaXphdGlvbiBvZiB0aGlzIHNlcnZpY2UgKHRvIGJlIHVzZWQgYXMgYSBzaW5nbGV0b24gaW4gdGhlIGFwcCkuIEFsbCBvdGhlciB3ZWIgY2FsbHMgYXJlIGJsb2NrZWQgYXMgbG9uZyBhcyB0aGlzIG9uZSBpcyBub3QgZmluaXNoZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYmx1ZXNreUFqYXhDbGllbnRDb25maWc6IEJsdWVza3lBamF4Q2xpZW50Q29uZmlndXJhdGlvbkR0bztcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvbWlzZSByZXNvbHZlZCBvbmx5IG9uY2UgdGhlIGFqYXhDb25maWcgaGFzIGJlZW4gY29ycmVjdGx5IGZldGNoZWQgZnJvbSBzZXJ2ZXIgJiB0aGUgY3VycmVudCB1c2VyICYgdXNlciByb2xlIGhhcyBiZWVuIGxvYWRlZCAoaWYgbmVlZGVkKSAmIHNldC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRBamF4Q29uZmlnRnJvbVNlcnZlclByb21pc2U6IG5nLklQcm9taXNlPEJsdWVza3lBamF4Q2xpZW50Q29uZmlndXJhdGlvbkR0bz47XHJcblxyXG4gICAgICAgIGdldDxUPih1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIGRlbGV0ZTxUPih1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIHBvc3Q8VD4odXJsOiBzdHJpbmcsIGRhdGE6IGFueSwgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIHB1dDxUPih1cmw6IHN0cmluZywgZGF0YTogYW55LCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuICAgICAgICBcclxuICAgICAgICBwYXRjaDxUPih1cmw6IHN0cmluZywgZGF0YTogYW55LCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuXHJcbiAgICAgICAgdXBsb2FkPFQ+KHVybDogc3RyaW5nLCBmaWxlOiBGaWxlLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuXHJcbiAgICAgICAgZ2V0RmlsZSh1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8RmlsZUNvbnRlbnQ+O1xyXG5cclxuICAgICAgICBidWlsZFVybEZyb21Db250ZXh0KHVybElucHV0OiBzdHJpbmcpOiBzdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGNsYXNzIEJsdWVza3lIdHRwV3JhcHBlciBpbXBsZW1lbnRzIElCbHVlc2t5SHR0cFdyYXBwZXIge1xyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHJvcGVydGllc1xyXG5cclxuICAgICAgICBwdWJsaWMgZ2V0QWpheENvbmZpZ0Zyb21TZXJ2ZXJQcm9taXNlOiBuZy5JUHJvbWlzZTxCbHVlc2t5QWpheENsaWVudENvbmZpZ3VyYXRpb25EdG8+O1xyXG5cclxuICAgICAgICBwdWJsaWMgYmx1ZXNreUFqYXhDbGllbnRDb25maWc6IEJsdWVza3lBamF4Q2xpZW50Q29uZmlndXJhdGlvbkR0bztcclxuXHJcbiAgICAgICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgICAgIC8vI3JlZ2lvbiBjdG9yXHJcblxyXG4gICAgICAgIC8qIEBuZ0luamVjdCAqL1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgICAgICBwcml2YXRlIF86IFVuZGVyc2NvcmVTdGF0aWMsXHJcbiAgICAgICAgICAgIHByaXZhdGUgJGh0dHA6IG5nLklIdHRwU2VydmljZSxcclxuICAgICAgICAgICAgcHJpdmF0ZSAkd2luZG93OiBuZy5JV2luZG93U2VydmljZSxcclxuICAgICAgICAgICAgcHJpdmF0ZSAkbG9nOiBuZy5JTG9nU2VydmljZSxcclxuICAgICAgICAgICAgcHJpdmF0ZSAkcTogbmcuSVFTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlICRsb2NhdGlvbjogbmcuSUxvY2F0aW9uU2VydmljZSxcclxuICAgICAgICAgICAgcHJpdmF0ZSBVcGxvYWQ6IG5nLmFuZ3VsYXJGaWxlVXBsb2FkLklVcGxvYWRTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlIHRvYXN0ZXI6IG5ndG9hc3Rlci5JVG9hc3RlclNlcnZpY2UsXHJcbiAgICAgICAgICAgIHByaXZhdGUgY29uZmlnSW5pdGlhbGl6YXRpb25VUkw6IHN0cmluZyxcclxuICAgICAgICAgICAgcHJpdmF0ZSBzZWxlY3RlZFVzZXJSb2xlOiBVc2VyUm9sZUVudHJ5RHRvXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIC8vIDEgLSBmZXRjaCB0aGUgY29uZmlndXJhdGlvbiBkYXRhIG5lY2Vzc2FyeSBmb3IgdGhpcyBzZXJ2aWNlIHRvIHJ1biBmcm9tIHRoZSBwcm92aWRlZCBlbmRwb2ludFxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbmZpZ3VyYXRpb25FbmRwb2ludFVybCA9IHRoaXMuYnVpbGRVcmxGcm9tQ29udGV4dChjb25maWdJbml0aWFsaXphdGlvblVSTCwgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghY29uZmlndXJhdGlvbkVuZHBvaW50VXJsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYFtCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIFVuYWJsZSB0byBidWlsZCB1cmwgZnJvbSBpbml0aWFsQ29uZmlnIHVybCAnJHtjb25maWdJbml0aWFsaXphdGlvblVSTH0nIHdpdGggZW5kcG9pbnRUeXBlICcke0VuZHBvaW50VHlwZUVudW1bRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluXX0nLiBBYm9ydGluZyBibHVlc2t5SHR0cFNlcnZpY2UgaW5pdC5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogY3VzdG9tIGNvbmZpZyBmb3IgaGVhZGVycyBoYXJkIGNvZGVkLCB0byBtdXR1YWxpemUgd2l0aCBjb25zdFxyXG4gICAgICAgICAgICB0aGlzLmdldEFqYXhDb25maWdGcm9tU2VydmVyUHJvbWlzZSA9IHRoaXMuJGh0dHAuZ2V0PEJsdWVza3lBamF4Q2xpZW50Q29uZmlndXJhdGlvbkR0bz4oY29uZmlndXJhdGlvbkVuZHBvaW50VXJsLCB7IGhlYWRlcnM6IHsgJ1gtUmVxdWVzdGVkLVdpdGgnOiAnWE1MSHR0cFJlcXVlc3QnIH0gfSlcclxuICAgICAgICAgICAgICAgIC50aGVuPEJsdWVza3lBamF4Q2xpZW50Q29uZmlndXJhdGlvbkR0bz4oXHJcbiAgICAgICAgICAgICAgICAvLyBzdWNjZXNzXHJcbiAgICAgICAgICAgICAgICAoY2xpZW50Q29uZmlnUHJvbWlzZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHJlamVjdCBzdGF0dXMgbm90IGluIDJYWCA/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbGllbnRDb25maWdQcm9taXNlLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IGBbQmx1ZXNreUh0dHBXcmFwcGVyXVtJbml0aWFsaXphdGlvbl0gLSBVbmFibGUgdG8gcmV0cmlldmUgaHR0cCBjb25maWcgZGF0YSBmcm9tICcke2NvbmZpZ0luaXRpYWxpemF0aW9uVVJMfScuIEFib3J0aW5nIGJsdWVza3lIdHRwV3JhcHBlclNlcnZpY2UgaW5pdGlhbGl6YXRpb24uYDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHRvYXN0ZXIgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5pbmZvKCdbQmx1ZXNreUh0dHBXcmFwcGVyXVtJbml0aWFsaXphdGlvbl0gLSBTdWNjZXNzZnVsbHkgbG9hZGVkIGNsaWVudENvbmZpZyBmcm9tIHNydjonLCBjbGllbnRDb25maWdQcm9taXNlLmRhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnID0gY2xpZW50Q29uZmlnUHJvbWlzZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnRDb25maWdQcm9taXNlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8gZXJyb3JcclxuICAgICAgICAgICAgICAgIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignW0JsdWVza3lIdHRwV3JhcHBlcl1bSW5pdGlhbGl6YXRpb25dIC0gVW5hYmxlIHRvIHJldHJpZXZlIEFQSSBjb25maWcuIEFib3J0aW5nIGJsdWVza3lIdHRwV3JhcHBlclNlcnZpY2UgaW5pdGlhbGl6YXRpb24uIFNydiBtc2c6ICcsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBzaG93IHRvYXN0ZXIgPyBiYXNlZCBvbiBwcm92aWRlciBjb25maWcgZmxhZyA/XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pLnRoZW48Qmx1ZXNreUFqYXhDbGllbnRDb25maWd1cmF0aW9uRHRvPihcclxuICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NcclxuICAgICAgICAgICAgICAgIChibHVlc2t5Q2xpZW50Q29uZmlnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIGNhc2Ugd2hlcmUgY2xpZW50LXNpZGUgdXNlclJvbGUgd2FzIHByb3ZpZGVkIGFuZCBub3QgPT0gc3J2LXNpZGUgdXNlciByb2xlICFcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJsdWVza3lDbGllbnRDb25maWcuQ3VycmVudFVzZXJSb2xlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgbm90IHByb3ZpZGVkIGJ5IGRvbWFpbiBmcm9tIHdoaWNoIGNvZGUgd2FzIGxvYWRlZCwgdGhlbiB0cnkgdG8gZmV0Y2ggZGVmYXVsdCB1c2VyUm9sZSBmcm9tIENBUEkgZW5kcG9pbnRcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5pbmZvKCdbQmx1ZXNreUh0dHBXcmFwcGVyXVtJbml0aWFsaXphdGlvbl0gLSBObyBkZWZhdWx0IFVzZXJSb2xlIHByb3ZpZGVkIGJ5IGN1cnJlbnQgZG9tYWluLCB0cnlpbmcgdG8gZmV0Y2ggaXQgZnJvbSBDQVBJLicpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3JlQXBpQ29uZmlnOiBBamF4Q2xpZW50RW5kcG9pbnRDb25maWd1cmF0aW9uRHRvID0gYmx1ZXNreUNsaWVudENvbmZpZy5FbmRwb2ludENvbmZpZ3VyYXRpb25EaWN0aW9ubmFyeVtFbmRwb2ludFR5cGVFbnVtW0VuZHBvaW50VHlwZUVudW0uQ29yZUFwaV1dO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb3JlQXBpQ29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ1tCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIEZhaWxlZCB0byByZXRyaWV2ZSBuZWNlc3NhcnkgQ29yZUFwaSBlbmRwb2ludCBjb25maWcgdG8gZmV0Y2ggdXNlclNTTy4gQWJvcnRpbmcuJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihtc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGZhY3Rvcml6ZSB3aXRoIGNvbmZpZ3VyZUh0dHBDYWxsKCkgISEgdGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBjYW5ub3QgdXNlIGFqYXgoKSBEUlkgbWV0aG9kIC4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VzdG9tQ29uZmlnID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdYLVJlcXVlc3RlZC1XaXRoJzogJ1hNTEh0dHBSZXF1ZXN0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgJyArIGNvcmVBcGlDb25maWcuQXV0aFRva2VuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0VXNlclNzb0Z1bGxVcmwgPSB0aGlzLmJ1aWxkVXJsRnJvbUNvbnRleHQoJ3VzZXItc3NvP3Byb2ZpbGU9JywgRW5kcG9pbnRUeXBlRW51bS5Db3JlQXBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRodHRwLmdldDxVc2VyU3NvRHRvPihnZXRVc2VyU3NvRnVsbFVybCwgY3VzdG9tQ29uZmlnKS50aGVuPEJsdWVza3lBamF4Q2xpZW50Q29uZmlndXJhdGlvbkR0bz4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodXNlclNzb1Byb21pc2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJTc29Qcm9taXNlIHx8ICF1c2VyU3NvUHJvbWlzZS5kYXRhIHx8ICF1c2VyU3NvUHJvbWlzZS5kYXRhLlVzZXJSb2xlRW50cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvcmVBcGlDb25maWdNaXNzaW5nTXNnID0gJ1tCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIFVuYWJsZSB0byByZXRyaWV2ZSBDb3JlQVBJIGRlZmF1bHQgdXNlclNTTy4gQWJvcnRpbmcgaHR0cFdyYXBwZXJTZXJ2aWNlIGluaXRpYWxpemF0aW9uLic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihjb3JlQXBpQ29uZmlnTWlzc2luZ01zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRxLnJlamVjdChjb3JlQXBpQ29uZmlnTWlzc2luZ01zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlclNzbyA9IHVzZXJTc29Qcm9taXNlLmRhdGE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5pbmZvKGBbQmx1ZXNreUh0dHBXcmFwcGVyXVtJbml0aWFsaXphdGlvbl0gLSBEZWZhdWx0IHVzZXJTU08gbG9hZGVkIGZyb20gQ0FQSTogJyR7dXNlclNzby5Vc2VyRGlzcGxheU5hbWV9Jy5gLCB1c2VyU3NvKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkVXNlclJvbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5pbmZvKGBbQmx1ZXNreUh0dHBXcmFwcGVyXVtJbml0aWFsaXphdGlvbl0gLSBDbGllbnQgYXBwIHByb3ZpZGVkIHNhdmVkIFVzZXJSb2xlLiBBc3NpZ25pbmcgaXQuYCwgdGhpcy5zZWxlY3RlZFVzZXJSb2xlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogbWFrZSBzdXJlIHNlbGVjdGVkVXNlclJvbGUgaXMgYXZhaWxhYmxlIGluIHRoZSBsaXN0IG9mIHVzZXJTU08gcm9sZXMsIG90aGVyd2lzZSBzZWxlY3QgZGVmYXVsdCAhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaG93IHRvIGluZm9ybSBiYWNrIHRoZSBEQSB0aGF0IHNlbGVjdGVkVXNlclJvbGUgd2FzIHJlc2V0ID8gaW52ZXJ0IHJlc3BvbnNhYmlsaXR5ICYgc3RvcmUgdXNlclJvbGUgaW4gbG9jYWxTdG9yYWdlIGZyb20gdGhpcyBzZXJ2aWNlID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlclJvbGVUb1VzZSA9IHNlbGVjdGVkVXNlclJvbGUgfHwgdXNlclNzby5Vc2VyUm9sZUVudHJ5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiB0aGlzIG5lZWRzIHRvIGJlIHB1dCBpbiBzaGFyZWQgZXh0ZW5zaW9uIG1ldGhvZCAvIHNlcnZpY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLkN1cnJlbnRVc2VyUm9sZSA9IHVzZXJSb2xlVG9Vc2UuTmFtZSArIFwiIFwiICsgdXNlclJvbGVUb1VzZS5Sb2xlICsgXCIgXCIgKyB1c2VyUm9sZVRvVXNlLlNpbG87XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuQ3VycmVudFVzZXIgPSB1c2VyU3NvO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmx1ZXNreUNsaWVudENvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiB3ZSBvbmx5IGxvYWQgdXNlclNTTyBpZiBubyB1c2VyUm9sZSB3YXMgcHJvdmlkZWQgc3J2LXNpZGUsIHNob3VsZCB3ZSBsb2FkIGl0IGluIGFsbCBjYXNlcyA/XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGRlZmluZWQgdXNlclJvbGUgc2VudCBmcm9tIG9yaWdpbiBhcHAsIHVzZSBpdCAmIHNldCBpdCBhcyBkZWZhdWx0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmx1ZXNreUNsaWVudENvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8jcmVnaW9uIHB1YmxpYyBtZXRob2RzXHJcblxyXG4gICAgICAgIGdldDxUPih1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuR0VULCB1cmwsIGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZWxldGU8VD4odXJsOiBzdHJpbmcsIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheDxUPihIdHRwTWV0aG9kLkRFTEVURSwgdXJsLCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcG9zdDxUPih1cmw6IHN0cmluZywgZGF0YTogYW55LCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBkYXRhIHx8IGNvbmZpZy5kYXRhOztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheDxUPihIdHRwTWV0aG9kLlBPU1QsIHVybCwgY29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1dDxUPih1cmw6IHN0cmluZywgZGF0YTogYW55LCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBkYXRhIHx8IGNvbmZpZy5kYXRhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuUFVULCB1cmwsIGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXRjaDxUPih1cmw6IHN0cmluZywgZGF0YTogYW55LCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBkYXRhIHx8IGNvbmZpZy5kYXRhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuUEFUQ0gsIHVybCwgY29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRPRE8gTUdBOiBub3QgRFJZIHdpdGggYWpheCBtZXRob2QsIGhvdyB0byBrZWVwIGl0IGluIHN5bmMgP1xyXG4gICAgICAgICAqIEBwYXJhbSB1cmxcclxuICAgICAgICAgKiBAcGFyYW0gZmlsZVxyXG4gICAgICAgICAqIEBwYXJhbSBjb25maWdcclxuICAgICAgICAgKi9cclxuICAgICAgICB1cGxvYWQ8VD4odXJsOiBzdHJpbmcsIGZpbGU6IEZpbGUsIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuXHJcbiAgICAgICAgICAgIGlmICghZmlsZSAmJiAoIWNvbmZpZyB8fCAhY29uZmlnLmZpbGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ0Nhbm5vdCBzdGFydCB1cGxvYWQgd2l0aCBudWxsIHtmaWxlfSBwYXJhbWV0ZXIuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgICAgICAgICBjb25maWcuZmlsZSA9IGZpbGUgfHwgY29uZmlnLmZpbGU7IC8vVE9ETyBNR0EgOiBkbyBub3QgZXhwb3NlIGZpbGUgaW4gSUJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyA/XHJcbiAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gY29uZmlnLmRhdGEgfHwge307XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLnVwbG9hZEluQmFzZTY0SnNvbikge1xyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogbWFrZSBzdXJlIHRoaXMgZGVsYXlzIG5leHQgY2FsbCBhbmQgdXBsb2FkIGlzIG5vdCBkb25lIGJlZm9yZSBiYXNlNjQgZW5jb2RpbmcgaXMgZmluaXNoZWQsIGV2ZW4gaWYgcHJvbWlzZSBpcyBhbHJlYWR5IHJlc29sdmVkID8/P1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuVXBsb2FkLmJhc2U2NERhdGFVcmwoZmlsZSkudGhlbigoZmlsZUJhc2U2NFVybCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQtY29kZWQga2V5IHRvIGZldGNoIGJhc2U2NCBlbmNvZGluZywgdG8gcGFyYW1ldHJpemUgd2l0aCBzZXJ2ZXItc2lkZSAhXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRhdGEuZmlsZUJhc2U2NFVybCA9IGZpbGVCYXNlNjRVcmw7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9ub3JtYWwgcG9zdCBpbiBjYXNlIG9mIGJhc2U2NC1lbmNvZGVkIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuZGF0YS5maWxlRm9ybURhdGFOYW1lID0gJ2ZpbGUnOyAvLyBmaWxlIGZvcm1EYXRhIG5hbWUgKCdDb250ZW50LURpc3Bvc2l0aW9uJyksIHNlcnZlciBzaWRlIHJlcXVlc3QgZm9ybSBuYW1lXHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGRvIG5vdCBibG9jayBpZiBub3QgY2FsbCB0byBpbnRlcm5hbCBBUEkgPyAoaW5pdENhbGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBamF4Q29uZmlnRnJvbVNlcnZlclByb21pc2UudGhlbigoKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBiZWhhdmlvciBkdXBsaWNhdGlvbiB3aXRoIHRoaXMuYWpheCwgbm90IERSWSwgdG8gaW1wcm92ZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0Q29uZmlnID0gdGhpcy5jb25maWd1cmVIdHRwQ2FsbChIdHRwTWV0aG9kLlBPU1QsIHVybCwgY29uZmlnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RDb25maWcpIC8vIGlmIG5vIGNvbmZpZyByZXR1cm5lZCwgY29uZmlndXJhdGlvbiBmYWlsZWQsIGRvIG5vdCBzdGFydCBhamF4IHJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuVXBsb2FkLnVwbG9hZDxUPig8bmcuYW5ndWxhckZpbGVVcGxvYWQuSUZpbGVVcGxvYWRDb25maWdGaWxlPnJlcXVlc3RDb25maWcpIC8vVE9ETyBNR0EgOiBub3Qgc2FmZSBoYXJkIGNhc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuPFQ+KHRoaXMub25TdWNjZXNzPFQ+KGNvbmZpZyksIHRoaXMub25FcnJvcjxUPihjb25maWcpLCBjb25maWcudXBsb2FkUHJvZ3Jlc3MpIC8vVE9ETyBNR0EgOiB1cGxvYWRQcm9ncmVzcyBjYWxsYmFjayBvayA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseSh0aGlzLmZpbmFsbHkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy9UT0RPIE1HQTogd2hhdCB0byByZXR1cm4gP1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gZG93bmxvYWQgYSBmaWxlIGluIHRoZSBmb3JtIG9mIGEgYnl0ZS1zdHJlYW0gZnJvbSBhbiBlbmRwb2ludCBhbmQgd3JhcCBpdCBpbnRvIGEgRmlsZUNvbnRlbnQgb2JqZWN0IHdpdGggbmFtZSwgdHlwZSAmIHNpemUgcHJvcGVydGllcyByZWFkIGZyb20gdGhlIEhUVFAgcmVzcG9uc2UgaGVhZGVycyBvZiB0aGUgc2VydmV1ci5cclxuICAgICAgICAgKiBJdCBpcyB0aGUgcmVzcG9uc2FiaWxpdHkgb2YgdGhlIGNvbnN1bWVyIHRvIGRvIHNvbWV0aGluZyB3aXRoIHRoZSB3cmFwcGVkIGJ5dGVBcnJheSAoZm9yIGV4YW1wbGUgZG93bmxvYWQgdGhlIGZpbGUsIG9yIHNob3cgaXQgaW5zaWRlIHRoZSB3ZWJQYWdlIGV0YykuXHJcbiAgICAgICAgICogVE9ETyBNR0E6IG5vdCBEUlkgd2l0aCBhamF4IG1ldGhvZCwgaG93IHRvIGtlZXAgaXQgaW4gc3luYyA/XHJcbiAgICAgICAgICogQHBhcmFtIHVybFxyXG4gICAgICAgICAqIEBwYXJhbSBleHBlY3RlZE5hbWVcclxuICAgICAgICAgKiBAcGFyYW0gZXhwZWN0ZWRTaXplXHJcbiAgICAgICAgICogQHBhcmFtIGV4cGVjdGVkVHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSBjb25maWdcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRGaWxlKHVybDogc3RyaW5nLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxGaWxlQ29udGVudD4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBamF4Q29uZmlnRnJvbVNlcnZlclByb21pc2UudGhlbigoKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGFuZ3VsYXJIdHRwQ29uZmlnID0gdGhpcy5jb25maWd1cmVIdHRwQ2FsbChIdHRwTWV0aG9kLkdFVCwgdXJsLCBjb25maWcpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIG5vIGNvbmZpZyByZXR1cm5lZCwgY29uZmlndXJhdGlvbiBmYWlsZWQsIGRvIG5vdCBzdGFydCBhamF4IHJlcXVlc3RcclxuICAgICAgICAgICAgICAgIGlmICghYW5ndWxhckh0dHBDb25maWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QoJ1VuYWJsZSB0byBjb25maWd1cmUgcmVxdWVzdCBjb3JyZWN0bHkuIEFib3J0aW5nIGdldEZpbGUgYWpheCBjYWxsLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljYWxseSBleHBlY3QgcmF3IHJlc3BvbnNlIHR5cGUsIG90aGVyd2lzZSBieXRlIHN0cmVhbSByZXNwb25zZXMgYXJlIGNvcnJ1cHRlZC5cclxuICAgICAgICAgICAgICAgIGFuZ3VsYXJIdHRwQ29uZmlnLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9FeHBlY3RlZCBBcnJheUJ1ZmZlciByZXNwb25zZSA9IGJ5dGUgYXJyYXlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRodHRwPEFycmF5QnVmZmVyPihhbmd1bGFySHR0cENvbmZpZylcclxuICAgICAgICAgICAgICAgICAgICAudGhlbjxGaWxlQ29udGVudD4oKGh0dHBSZXNwb25zZSkgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9iZW5lZml0IGZyb20gc3VjY2Vzc0NhbGxiYWNrIHZhbGlkYXRpb24gYmVmb3JlIGNvbnRpbnVpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5QnVmZmVyID0gdGhpcy5vblN1Y2Nlc3M8QXJyYXlCdWZmZXI+KGNvbmZpZykoaHR0cFJlc3BvbnNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHByb21pc2UgcmVqZWN0aW9uIHZzLiByZXR1cm4gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJyYXlCdWZmZXIpIHJldHVybiBudWxsOyAvL3N0b3AgcHJvY2Vzc2luZyBpZiB1bmFibGUgdG8gcmV0cmlldmUgYnl0ZSBhcnJheVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWFkIGZpbGUgaW5mbyBmcm9tIHJlc3BvbnNlLWhlYWRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVDb250ZW50OiBGaWxlQ29udGVudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuZ2V0RmlsZU5hbWVGcm9tSGVhZGVyQ29udGVudERpc3Bvc2l0aW9uKGh0dHBSZXNwb25zZS5oZWFkZXJzKCdjb250ZW50LWRpc3Bvc2l0aW9uJykpIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBOdW1iZXIoaHR0cFJlc3BvbnNlLmhlYWRlcnMoJ2NvbnRlbnQtbGVuZ3RoJykpIHx8IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBodHRwUmVzcG9uc2UuaGVhZGVycygnY29udGVudC10eXBlJykgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBhcnJheUJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVDb250ZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm9uRXJyb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkodGhpcy5maW5hbGx5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmllcyB0byBwYXJzZSB0aGUgaW5wdXQgdXJsIDpcclxuICAgICAgICAgKiBJZiBpdCBzZWVtcyB0byBiZSBhIGZ1bGwgVVJMLCB0aGVuIHJldHVybiBhcyBpcyAoY29uc2lkZXJzIGl0IGV4dGVybmFsIFVybCkgXHJcbiAgICAgICAgICogT3RoZXJ3aXNlLCB0cmllcyB0byBmaW5kIHRoZSBiYXNlIFVSTCBvZiB0aGUgY3VycmVudCBCbHVlU2t5IGFwcCB3aXRoIG9yIHdpdGhvdXQgdGhlIGluY2x1ZGVkIENvbnRyb2xsZXIgYW5kIHJldHVybnMgdGhlIGZ1bGwgVXJsIFxyXG4gICAgICAgICAqIEBwYXJhbSB1cmxJbnB1dCA6IFRPRE8gTUdBOiBkb2N1bWVudCBkaWZmZXJlbnQga2luZCBvZiB1cmxzIHRoYXQgdGhpcyBtZXRob2QgY2FuIHRha2UgYXMgaW5wdXQgKGZ1bGwsIHBhcnRpYWwgZXRjKVxyXG4gICAgICAgICAqIEByZXR1cm4gbnVsbCBpZiBub3QgYWJsZSB0byBjb21wdXRlIHVybC4gT3RoZXJ3aXNlLCB1cmwgb2YgdGhlIHJlcXVlc3QgZWl0aGVyIHBhcnRpYWwgb3IgZnVsbCBiYXNlZCBvbiBlbmRwb2ludFR5cGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVibGljIGJ1aWxkVXJsRnJvbUNvbnRleHQodXJsSW5wdXQ6IHN0cmluZywgZW5kcG9pbnRUeXBlPzogRW5kcG9pbnRUeXBlRW51bSk6IHN0cmluZyB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXVybElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ05vIFVSTCBpbnB1dCBwcm92aWRlZC4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBVcmwgc3RhcnRzIHdpdGggaHR0cDovLyBvciBodHRwczovLyA9PiByZXR1cm4gYXMgaXMsIGV2ZW4gaWYgZW5kcG9pbnRUeXBlIGlzIG5vdCBleHRlcm5hbC5cclxuICAgICAgICAgICAgaWYgKHVybElucHV0LnNsaWNlKDAsICdodHRwOi8vJy5sZW5ndGgpID09PSAnaHR0cDovLycgfHxcclxuICAgICAgICAgICAgICAgIHVybElucHV0LnNsaWNlKDAsICdodHRwczovLycubGVuZ3RoKSA9PT0gJ2h0dHBzOi8vJykge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlbmRwb2ludFR5cGUgIT09IEVuZHBvaW50VHlwZUVudW0uRXh0ZXJuYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLndhcm4oJ0Z1bGwgVVJMIHByb3ZpZGVkIGZvciBhIGNhbGwgdGhhdCBpcyBub3QgZmxhZ2dlZCBhcyBcXCdFeHRlcm5hbFxcJyBlbmRwb2ludFR5cGUsIHRoaXMgaXMgYmFkIHByYWN0aWNlIGFzIG9ubHkgdGhlIGJsdWVza3lXcmFwcGVyIHNob3VsZCBrbm93IGFib3V0IHRoZSBiYXNlVVJMIG9mIHRhcmdldCBlbmRwb2ludHMgKGxvYWRlZCBmcm9tIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IGVudikuIFVzZSBwYXJ0aWFsIFVSTHMuJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybElucHV0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBFbHNlLCB3ZSBoYXZlIGEgcGFydGlhbCBVUkwgdG8gY29tcGxldGU6IHVzZSBwcm92aWRlZCBlbmRwb2ludCB0eXBlIHRvIGRldGVybWluZSBob3cgdG8gY29tcGxldGUgdXJsLlxyXG5cclxuICAgICAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZSBmb3IgZW5kcG9pbnRUeXBlIGlmIG5vdCBwcm92aWRlZCBpcyBvcmlnaW4uIFRPRE8gTUdBOiBydWxlIHRvIGRpc2N1c3MsIGhlcmUgZm9yIHJldHJvLWNvbXBhdGliaWxpdHkuXHJcbiAgICAgICAgICAgIGVuZHBvaW50VHlwZSA9IGVuZHBvaW50VHlwZSB8fCBFbmRwb2ludFR5cGVFbnVtLkN1cnJlbnREb21haW47XHJcblxyXG4gICAgICAgICAgICB2YXIgYmFzZVVybDogc3RyaW5nO1xyXG5cclxuICAgICAgICAgICAgaWYgKGVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlRW51bS5FeHRlcm5hbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLndhcm4oJ1BhcnRpYWwgdXJsIHByb3ZpZGVkIGZvciBhIGNhbGwgd2l0aCBlbmRwb2ludFR5cGUgZmxhZ2dlZCBhcyBcXCdFeHRlcm5hbFxcJzogdGhlIGNhbGwgd2lsbCBwcm9iYWJseSBmYWlsLicpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBtb2RpZnkgcHJvdmlkZWQgdXJsIGlmIGV4dGVybmFsICh3ZSBjYW5ub3Qga25vdyBob3cgdG8gY29tcGxldGUgaXQsIGV2ZW4gaWYgcGFydGlhbCkuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsSW5wdXQ7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogbm90IGxvYWRpbmcgdGhlIGVuZHBvaW50Q29uZmlnIGZvciBjdXJyZW50IGRvbWFpbiBtZWFucyB3ZSBjYW4ndCBhY2Nlc3MgZW5kcG9pbnRBUElzdWZmaXggaWYgaXQgZXhpc3RzLCBzaG91bGQgd2UgbG9hZCB0aGUgZW5kcG9pbnRDb25maWcgZm9yIHRoaXMgY2FzZSB0b28gPz8gJiBoYW5kbGUgaXQgdGhlIHNhbWUgd2F5IGFzIG90aGVyIGVuZHBvaW50cyA/XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVnZXggdHJ5aW5nIHRvIGRldGVybWluZSBpZiB0aGUgaW5wdXQgZnJhZ21lbnQgY29udGFpbnMgYSAvIGJldHdlZW4gdHdvIGNoYXJhY3RlciBzdWl0ZXMgPT4gY29udHJvbGxlciBnaXZlbiBhcyBpbnB1dCwgb3RoZXJ3aXNlLCBhY3Rpb24gb24gc2FtZSBjb250cm9sbGVyIGV4cGVjdGVkXHJcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbGxlcklzUHJlc2VudFJlZ2V4ID0gL1xcdytcXC9cXHcrLztcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uSXNPblNhbWVDb250cm9sbGVyID0gIWNvbnRyb2xsZXJJc1ByZXNlbnRSZWdleC50ZXN0KHVybElucHV0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBiYXNlVXJsID0gdGhpcy5nZXRVcmxQYXRoKGFjdGlvbklzT25TYW1lQ29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgYWxsIG90aGVyIGVuZHBvaW50VHlwZXM6IGNvbXB1dGUgVVJMIGFzIGEgY29tYmluYXRpb24gb2YgYmFzZVVSTCAmIHN1ZmZpeCBpZiBwcmVzZW50LCBhcyBwcm92aWRlZCBieSBzZXJ2ZXItY29uZmlndXJhdGlvbi5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcgfHxcclxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5FbmRwb2ludENvbmZpZ3VyYXRpb25EaWN0aW9ubmFyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignRXhwZWN0ZWQgZW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnkgcHJvdmlkZWQgYnV0IG5vbmUgZm91bmQuIEFib3J0aW5nLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIEhBQ0tZOiBzZWFyY2ggYnkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGVuZHBvaW50IHR5cGUgaW4gZGljdCBkdWUgdG8gc2VyaWFsaXphdGlvbiBsaW1pdHNcclxuICAgICAgICAgICAgICAgIHZhciBlbmRwb2ludENvbmZpZyA9IHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuRW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnlbRW5kcG9pbnRUeXBlRW51bVtlbmRwb2ludFR5cGVdXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWVuZHBvaW50Q29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKGBFbmRwb2ludFR5cGUgJyR7RW5kcG9pbnRUeXBlRW51bVtlbmRwb2ludFR5cGVdfScgaXMgbm90ICdFeHRlcm5hbCcgb3IgJ0N1cnJlbnREb21haW4nLCBleHBlY3RlZCBjb3JyZXNwb25kaW5nIGVuZHBvaW50Q29uZmlndXJhdGlvbiBwcm92aWRlZCBpbiBibHVlc2t5QWpheENsaWVudENvbmZpZy5lbmRwb2ludENvbmZpZ3VyYXRpb25EaWN0aW9ubmFyeSBidXQgbm9uZSBmb3VuZC4gQWJvcnRpbmcuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYmFzZVVybCA9IGVuZHBvaW50Q29uZmlnLkVuZHBvaW50QmFzZVVSTCArIChlbmRwb2ludENvbmZpZy5FbmRwb2ludFN1ZmZpeCB8fCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhvdyB0byBoYW5kbGUgT00gYXBwcyBleHRlcm5hbCBjYWxscyB3aXRob3V0IHNlc3Npb24gcHJvdmlkZWQgPyB3aWxsIHJlc3VsdCBpbiBhIHJlZGlyZWN0IGFuZCBjYWxsIG1heSBmYWlsID9cclxuXHJcbiAgICAgICAgICAgIC8vIEJvb2xlYW4gdXNlZCB0byB0cnkgdG8gZGV0ZXJtaW5lIGNvcnJlY3QgZnVsbCB1cmwgKGFkZCAvIG9yIG5vdCBiZWZvcmUgdGhlIHVybCBmcmFnbWVudCBkZXBlbmRpbmcgb24gaWYgZm91bmQgb3Igbm90KVxyXG4gICAgICAgICAgICB2YXIgdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2ggPSB1cmxJbnB1dC5zbGljZSgwLCAxKSA9PT0gJy8nO1xyXG4gICAgICAgICAgICB2YXIgYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCA9IGJhc2VVcmwuc2xpY2UoYmFzZVVybC5sZW5ndGggLSAxLCBiYXNlVXJsLmxlbmd0aCkgPT09ICcvJztcclxuXHJcbiAgICAgICAgICAgIC8vYmFzZWQgb24gc3RhcnRpbmcvdHJhaWxpbmcgc2xhc2hlcywgcmV0dXJuIGZ1bGwgdXJsLlxyXG4gICAgICAgICAgICBpZiAoYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiB1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaClcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBsYXN0ICcvJyBvbiBiYXNlVXJsXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybC5zbGljZSgwLCBiYXNlVXJsLmxlbmd0aCAtIDEpICsgdXJsSW5wdXQ7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFiYXNlVXJsRnJhZ21lbnRFbmRzV2l0aFNsYXNoICYmICF1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaClcclxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVXJsICsgJy8nICsgdXJsSW5wdXQ7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChiYXNlVXJsRnJhZ21lbnRFbmRzV2l0aFNsYXNoICYmICF1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaCkgfHxcclxuICAgICAgICAgICAgICAgICghYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiB1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybCArIHVybElucHV0O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8jcmVnaW9uIHByaXZhdGUgbWV0aG9kc1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVdGlsaXR5IG1ldGhvZC5cclxuICAgICAgICAgKiBNYWluIGNhbGxlciB0aGF0IGFsbCB3cmFwcGVyIGNhbGxzIChnZXQsIGRlbGV0ZSwgcG9zdCwgcHV0KSBtdXN0IHVzZSB0byBzaGFyZSBjb21tb24gYmVoYXZpb3IuXHJcbiAgICAgICAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgYWpheDxUPihtZXRob2Q6IEh0dHBNZXRob2QsIHVybDogc3RyaW5nLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBtYWtlIHN1cmUgZ2V0Q29uZmlnIHJlc29sdmUgYXV0b21hdGljYWxseSB3aXRob3V0IG92ZXJoZWFkIG9uY2UgZmlyc3QgY2FsbCBzdWNlc3NmdWxsLlxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBIDogZG8gbm90IGJsb2NrIGlmIG5vdCBjYWxsIHRvIGludGVybmFsIEFQSSAoaW5pdENhbGwpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFqYXhDb25maWdGcm9tU2VydmVyUHJvbWlzZS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBhbmd1bGFySHR0cENvbmZpZyA9IHRoaXMuY29uZmlndXJlSHR0cENhbGwobWV0aG9kLCB1cmwsIGNvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXJIdHRwQ29uZmlnKSAvLyBpZiBubyBjb25maWcgcmV0dXJuZWQsIGNvbmZpZ3VyYXRpb24gZmFpbGVkLCBkbyBub3Qgc3RhcnQgYWpheCByZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGh0dHA8VD4oYW5ndWxhckh0dHBDb25maWcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuPFQ+KHRoaXMub25TdWNjZXNzPFQ+KGNvbmZpZyksIHRoaXMub25FcnJvcjxUPihjb25maWcpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLy5jYXRjaCBUT0RPIE1HQSBoYW5kbGUgY2F0Y2ggY2xhdXNlIGlmIGV4Y2VwdGlvbiBpbiBzdWNjZXNzIG9yIGVycm9yIGNhbGxiYWNrICFcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkodGhpcy5maW5hbGx5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIFByZXBhcmVzIGEge0BsaW5rIG5nIyRodHRwI2NvbmZpZyBjb25maWd9IG9iamVjdCBmb3IgJGh0dHAgY2FsbC5cclxuICAgICAgICAqIFRoZSBvcGVyYXRpb25zIGluY2x1ZGUgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyB3aGVuIG5vdCBwcm92aWRlZCwgYW5kIHNldHRpbmcgaHR0cCBoZWFkZXJzIGlmIG5lZWRlZCBmb3IgOlxyXG4gICAgICAgICogIC0gQWpheCBjYWxsc1xyXG4gICAgICAgICogIC0gQXV0aG9yaXphdGlvbiB0b2tlblxyXG4gICAgICAgICogIC0gQ3VycmVudCBVc2VyUm9sZS4gICBcclxuICAgICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgICAgKiBAcmV0dXJucyB7bmcuJGh0dHAuY29uZmlnfSB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgcmVhZHkgdG8gYmUgaW5qZWN0ZWQgaW50byBhICRodHRwIGNhbGwuIFxyXG4gICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBjb25maWd1cmVIdHRwQ2FsbCA9IChtZXRob2Q6IEh0dHBNZXRob2QsIHVybDogc3RyaW5nLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUmVxdWVzdENvbmZpZyA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyBpbnB1dCB2YWxpZGF0aW9uXHJcblxyXG4gICAgICAgICAgICBpZiAoIXVybCB8fCBtZXRob2QgPT09IG51bGwgfHwgbWV0aG9kID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVVJMICYgTUVUSE9EIHBhcmFtZXRlcnMgYXJlIG5lY2Vzc2FyeSBmb3IgaHR0cFdyYXBwZXIgY2FsbHMuIEFib3J0aW5nLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IGNvbmZpZyB2YWx1ZXMgYW5kIGN1c3RvbSBvbmVzIGJhc2VkIG9uIGVuZHBvaW50c1xyXG5cclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgY29uZmlnLmVuZHBvaW50VHlwZSA9IGNvbmZpZy5lbmRwb2ludFR5cGUgfHwgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluOyAvLyBkZWZhdWx0IHZhbHVlOiBpZiBub3Qgc3BlY2lmaWVkLCBlbmRwb2ludCB0byB1c2UgaXMgc3VwcG9zZWQgdG8gYmUgdGhlIG9yaWdpbi5cclxuXHJcbiAgICAgICAgICAgIC8vIHNlYXJjaCBieSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZW5kcG9pbnQgdHlwZVxyXG4gICAgICAgICAgICAvLyBUT0RPIE1HQTogbWFrZSBzdXJlIEVuZHBvaW50VHlwZUVudW1baW52YWxpZCB2YWx1ZV0gZG9lc24ndCByZXR1cm4gZGVmYXVsdCB2YWxpZCBlbnVtIHZhbHVlID8/PyBvdGhlcndpc2UsIGRhbmdlcm91cyAhXHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RW5kcG9pbnRDb25maWcgPSB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnICYmIHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuRW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnlbRW5kcG9pbnRUeXBlRW51bVtjb25maWcuZW5kcG9pbnRUeXBlXV07XHJcblxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkIGNhc3QgaXMgbm90IHNhZmUsIHdlIG1heSBmb3JnZXQgdG8gc2V0IHVybCAmIG1ldGhvZCBwYXJhbWV0ZXJzLiBUT0ZJWC5cclxuICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBnZXQgYWxsIG5vbi1maWx0ZXJlZCBwYXJhbWV0ZXJzICYga2VlcCB0aGVtIGZvciB0aGlzIG5ldyBvYmplY3QuXHJcbiAgICAgICAgICAgIHZhciBjb25maWdGdWxsID0gPG5nLklSZXF1ZXN0Q29uZmlnPmNvbmZpZztcclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IHN1cHBvcnQgbWFwcGluZyBiZXR3ZWVuIHVwbG9hZCAmIHBvc3QgaGVyZSA/XHJcbiAgICAgICAgICAgIGNvbmZpZ0Z1bGwubWV0aG9kID0gSHR0cE1ldGhvZFttZXRob2RdO1xyXG5cclxuICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XHJcblxyXG4gICAgICAgICAgICAvLyBjb25maWd1cmUgZGVmYXVsdCBjb25maWcgZmxhZ3MgYmFzZWQgb24gdGFyZ2V0IGVuZHBvaW50XHJcbiAgICAgICAgICAgIHN3aXRjaCAoY29uZmlnLmVuZHBvaW50VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLkNvcmVBcGk6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uTWFya2V0aW5nQXBpOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLlNlbGZjYXJlQXBpOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlamVjdCBleHBsaWNpdGx5IHdyb25nIGlucHV0IGNvbmZpZ3VyYXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLndhcm4oYFtCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXSBbJHtjb25maWdGdWxsLm1ldGhvZH0gLyAke3VybH1dIC0gQVBJIGNhbGwgaW50ZW5kZWQgd2l0aCBpbmNvbXBhdGlibGUgY29uZmlndXJhdGlvbiBvcHRpb25zLiBBYm9ydGluZyBhamF4IGNhbGwuYCwgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25maWcgdmFsdWVzIGZvciBBUEkgZW5kcG9pbnRzIGFyZSBkaWZmZXJlbnQgZnJvbSBkZWZhdWx0LCBzbyB3ZSBtdXN0IHNwZWNpZnkgdGhlbS5cclxuICAgICAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyID0gZmFsc2U7IC8vIGJ5IGRlZmF1bHQgYWxyZWFkeSBlbmFibGVkLCBidXQgZW5mb3JlIHRoaXMgaGVhZGVyIGFzIG5lY2Vzc2FyeSBmb3IgY2FsbHMgdG8gV2ViQVBJIGVuZHBvaW50cy5cclxuICAgICAgICAgICAgICAgICAgICBjb25maWcudXNlQ3VycmVudFVzZXJSb2xlID0gdHJ1ZTsgLy8gZm9yIGFwaSBjYWxscywgZm9yY2UgdGhpcyByb2xlIHRvIGJlIHBhc3NlZCBhcm91bmQgKHNob3VsZCBiZSBtYW5kYXRvcnkgdG8gY29udGV4dHVhbGl6ZSByZXF1ZXN0IHRvIHJlYWxtIG9mIGN1cnJlbnQgdXNlcikuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uUXVvdGVXaXphcmQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uT3JkZXJFbnRyeTpcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5PcmRlclRyYWNraW5nOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBPTSBhcHBzIGNhbGxlZCBhcyBlbmRwb2ludHMsIG1ha2Ugc3VyZSB0aGUgWG1sSHR0cFJlcXVlc3QgaGVhZGVyIGlzIHByZXNlbnQgKEFTUC5ORVQgYXBwcykuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGFkZCBjdXJyZW50VXNlclJvbGUgYnkgZGVmYXVsdCBzbyB0aGF0IE9NIGFwcHMgY2FuIGNvbnRleHR1YWxpc2UgdGhlIHJlcXVlc3QgP1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLk1ldHJhbmV0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLlRlY2huaWNhbEludmVudG9yeTpcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5UZW1wbGF0ZUdlbmVyYXRvcjpcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5TYWxlc2ZvcmNlOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IG5vIHNwZWNpZmljIGNvbmZpZyBmb3IgdGhvc2UgZXh0ZXJuYWwgZW5kcG9pbnRzID8gYWRkIGN1c3RvbSBvbmVzIGlmIG5lZWRlZCBoZXJlLlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLkN1cnJlbnREb21haW46XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGFqYXggY2FsbHMsIG1ha2Ugc3VyZSB0aGUgWG1sSHR0cFJlcXVlc3QgaGVhZGVyIGlzIHByZXNlbnQgKEFTUC5ORVQgYXBwcykuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZXIgcm9sZSBpcyB1c2VmdWxsIGV2ZW4gZm9yIGN1cnJlbnQgZG9tYWluIHNvIHRoYXQgc3J2IGNhbiBrbm93IHRoZSBjb250ZXh0LlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLkV4dGVybmFsOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgdG8gY29uZmlybTogd2UgbWF5IHdhbnQgdG8gY2FsbCBleHRlcm5hbCB1cmxzIHZpYSBhamF4LCBzbyBob3cgdG8gYmUgc3VyZSBvZiBkZWZhdWx0IHZhbHVlID9cclxuICAgICAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyID0gdHJ1ZTsgLy8gZG8gbm90IGFkZCBYbWxIdHRwUmVxdWVzdCBpZiBleHRlcm5hbCBVcmwgYnkgZGVmYXVsdDogbWlnaHQgY3JlYXRlIGNvbmZsaWN0cyBvbiBjZXJ0YWluIHNlcnZlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRoaXMgaGVhZGVyIG91dHNpZGUgb2YgQVNQIHdvcmxkLlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYFtCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXVske2NvbmZpZ0Z1bGwubWV0aG9kfSAvICR7dXJsfV0gLSBVbnN1cHBvcnRlZCBlbmRwb2ludFR5cGUgcHJvdmlkZWQ6ICcke0VuZHBvaW50VHlwZUVudW1bY29uZmlnLmVuZHBvaW50VHlwZSB8fCBFbmRwb2ludFR5cGVFbnVtLkN1cnJlbnREb21haW5dfScuIEFib3J0aW5nLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgLy9icmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogc2hvdWxkIHdlIGF1dGhvcml6ZSBubyB2YWxpZCBlbmRwb2ludCBjb25maWd1cmF0aW9uIGxvYWRlZCBmb3IgY3VycmVudCBkb21haW4gPyBBdXRoVG9rZW4gc3RpbGwgdXNlZnVsbCBvciBub3QgPyBCYXNlVVJMIHN0aWxsIHVzZWZ1bGwgb3Igbm90ID8gYXBpIHN1ZmZpeCA/IFxyXG4gICAgICAgICAgICAvLyBGb3IgZXh0ZXJuYWwgVVJMcywgb2J2aW91c2x5IGVuZHBvaW50IGNvbmZpZyBpcyBub3QgbWFuZGF0b3J5LCBidXQgaXQgY291bGQgYmUgcHJvdmlkZWQgaWYgbmVlZGVkOiBob3cgdG8gaGFuZGxlIHRoaXMgY2FzZT9cclxuXHJcbiAgICAgICAgICAgIC8vUmVqZWN0IGFqYXggY2FsbHMgaW50ZW5kZWQgdG8gZXh0ZXJuYWwgZW5kcG9pbnRzIHdpdGhvdXQgbmVjZXNzYXJ5IGNvbmZpZ3VyYXRpb24gbG9hZGVkIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5lbmRwb2ludFR5cGUgIT09IEVuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbiAmJlxyXG4gICAgICAgICAgICAgICAgY29uZmlnLmVuZHBvaW50VHlwZSAhPT0gRW5kcG9pbnRUeXBlRW51bS5FeHRlcm5hbCAmJlxyXG4gICAgICAgICAgICAgICAgIWN1cnJlbnRFbmRwb2ludENvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKGBbQmx1ZXNreUh0dHBXcmFwcGVyXVtjb25maWd1cmVIdHRwQ2FsbF1bJHtjb25maWdGdWxsLm1ldGhvZH0gLyAke3VybH1dIC0gQWpheCBjYWxsIGludGVuZGVkIHdpdGhvdXQgZXhwZWN0ZWQgZW5kcG9pbnQgY29uZmlndXJhdGlvbiBsb2FkZWQgZnJvbSB0aGUgc2VydmVyIGZvciBlbmRwb2ludFR5cGUgJyR7RW5kcG9pbnRUeXBlRW51bVtjb25maWcuZW5kcG9pbnRUeXBlXX0nLiBBYm9ydGluZy5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBzZXQgZGVmYXVsdCB2YWx1ZXMgYWZ0ZXIgZW5kcG9pbnQtc3BlY2lmaWMgY29uZmlndXJhdGlvbnNcclxuICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgfHwgZmFsc2U7IC8vIGRlZmF1bHQgdmFsdWUgaXMgZW5hYmxlZCAoYWpheCBjYWxscyBvbiAuTkVUIGVuZHBvaW50cykuXHJcbiAgICAgICAgICAgIGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUgPSBjb25maWcudXNlQ3VycmVudFVzZXJSb2xlIHx8IGZhbHNlOyAvLyBkZWZhdWx0IHZhbHVlOiBkb24ndCB0cmFuc21pdCBzZW5zaXRpdmUgaW5mb3JtYXRpb24gdG8gcmVtb3RlIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZC5cclxuICAgICAgICAgICAgY29uZmlnLmRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucyA9IGNvbmZpZy5kaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMgfHwgZmFsc2U7IC8vc2V0IGRlZmF1bHQgdmFsdWUgZm9yIGRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucyB0byBmYWxzZSBhcyBpdCdzIHBhcnQgb2YgdGhlIG5vcm1hbCBiZWhhdmlvciBleHBlY3RlZCBmb3IgdGhpcyBzZXJ2aWNlLlxyXG5cclxuICAgICAgICAgICAgLy8gVHJ5IHRvIGJ1aWxkIGEgdmFsaWQgdXJsIGZyb20gaW5wdXQgJiBlbmRwb2ludFR5cGUuXHJcbiAgICAgICAgICAgIGNvbmZpZ0Z1bGwudXJsID0gdGhpcy5idWlsZFVybEZyb21Db250ZXh0KHVybCwgY29uZmlnLmVuZHBvaW50VHlwZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZ0Z1bGwudXJsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYFtCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXSAtIFVuYWJsZSB0byBidWlsZCB1cmwgZnJvbSB1cmxJbnB1dCAnJHt1cmx9JyB3aXRoIGVuZHBvaW50VHlwZSAnJHtFbmRwb2ludFR5cGVFbnVtW2NvbmZpZy5lbmRwb2ludFR5cGVdfScuIEFib3J0aW5nIGFqYXggY2FsbC5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIpXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkIGNvZGVkIGhlYWRlciB0byBwdXQgaW4gQ09OU1RcclxuICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcclxuXHJcbiAgICAgICAgICAgIGlmIChjb25maWcudXNlQ3VycmVudFVzZXJSb2xlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWplY3QgY2FsbCB3aGVuIG1pc3NpbmcgbWFuZGF0b3J5IGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuQ3VycmVudFVzZXJSb2xlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKGBbQmx1ZXNreUh0dHBXcmFwcGVyXVtjb25maWd1cmVIdHRwQ2FsbF1bJHtjb25maWdGdWxsLm1ldGhvZH0gLyAke3VybH1dIC0gQWpheCBjYWxsIGludGVuZGVkIHdpdGhvdXQgbmVjZXNzYXJ5IHVzZXJSb2xlIHNldCBpbiBjb25maWcuIEFib3J0aW5nLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZCBjb2RlZCBoZWFkZXIgdG8gcHV0IGluIENPTlNUXHJcbiAgICAgICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnNbJ09BLVVzZXJSb2xlJ10gPSB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLkN1cnJlbnRVc2VyUm9sZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgYXV0aCB0b2tlbiBwcm92aWRlZCBmb3IgdGFyZ2V0IGVuZHBvaW50LCBhZGQgaXQgaW4gaGVhZGVyXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50RW5kcG9pbnRDb25maWcgJiYgY3VycmVudEVuZHBvaW50Q29uZmlnLkF1dGhUb2tlbikgeyAvLyBwcm90ZWN0IGFnYWluc3QgY2FzZXMgd2hlcmUgZW5kcG9pbnRUeXBlIGlzIGN1cnJlbnQgZG9tYWluIG9yIGV4dGVybmFsOiBlbmRwb2ludENvbmZpZyBudWxsL3VuZGVmaW5lZC5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiByZWplY3QgYXV0aFRva2VuIGZvciBlbmRwb2ludHMgdGhhdCBhcmUgbm90ICdzYWZlJyB0byBzaGFyZSBhdXRoIHRva2VuIHdpdGgsIHN1Y2ggYXMgRXh0ZXJuYWwgb25lcyA/IE9yIGF1dGhvcml6ZSB0aGlzIHNvIHRoYXQgc2VydmVyIGNhbiBsb2FkIGFuIGF1dGggdG9rZW4gZm9yIGNlcnRhaW4gZXh0ZXJuYWwgZW5kcG9pbnRzID9cclxuXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgdG9rZW4gdmFsaWRpdHkgZW5kRGF0ZTogcmVuZXcgYXV0aCBiZWZvcmUgdGhlIGNhbGwgISBXaGF0J3MgdGhlIGJlc3QgbW9tZW50IHRvIGRvIGl0ID9cclxuXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkIGNvZGVkIGhlYWRlciB0byBwdXQgaW4gQ09OU1RcclxuICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0JlYXJlciAnICsgY3VycmVudEVuZHBvaW50Q29uZmlnLkF1dGhUb2tlbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogT0Ugc3BlY2lmaWMgY29kZSwgdG8gcmVtb3ZlLCBvciBhdCBsZWFzdCBwdXQgaW4gYXMgY29uZmlnIHBhcmFtXHJcbiAgICAgICAgICAgIGlmICgoPGFueT50aGlzLiR3aW5kb3cpLmJsb2NrX1VJICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHR5cGUgY2FzdGluZywgaXMgaXQgb2theSBvciBub3QgPyBiZXR0ZXIgYXBwcm9hY2ggP1xyXG4gICAgICAgICAgICAgICAgKDxhbnk+dGhpcy4kd2luZG93KS5wcmV2ZW50QmxvY2tVSSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY29uZmlnRnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN1Y2Nlc3MgaGFuZGxlci5cclxuICAgICAgICAgKiBDYXB0dXJlcyB0aGUgaW5wdXQgcGFyYW1ldGVycyBhdCB0aGUgbW9tZW50IG9mIGl0cyBkZWNsYXJhdGlvbiAmIHJldHVybiB0aGUgcmVhbCBoYW5kbGVyIHRvIGJlIGNhbGxlZCB1cG9uIHByb21pc2UgY29tcGxldGlvbi5cclxuICAgICAgICAgKiBJbnB1dCBwYXJhbWV0ZXJzOlxyXG4gICAgICAgICAqICAtIGNhbGxpbmdDb25maWc6IGNvbmZpZ3VyYXRpb24gdXNlZCB0byBtYWtlIHRoZSBhamF4IGNhbGwsIGluIGNhc2UgdGhlIHJldHVybmVkIHByb21pc2UgaXMgbnVsbC9lbXB0eSBhbmQgZG9lc24ndCBjb250YWluIG5lY2Vzc2FyeSBkYXRhIGZvciBkZWJ1Z2dpbmcuXHJcbiAgICAgICAgICogIC0gZ2V0Q29tcGxldGVSZXNwb25zZU9iamVjdDogZmxhZyBpbmRpY2F0aW9uIGlmIHdlIG11c3QgcmV0dXJuIHRoZSBmdWxsIHJlc3BvbnNlIG9iamVjdCBhbG9uZyB3aXRoIGhlYWRlcnMgYW5kIHN0YXR1cyBvciBvbmx5IHRoZSBpbm5lciBkYXRhLiBCeSBkZWZhdWx0ICYgaWYgbm90IHNwZWNpZmllZCwgb25seSByZXR1cm5zIGlubmVyIGRhdGEuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBvblN1Y2Nlc3MgPSA8VD4ob3JpZ2luYWxDb25maWc6IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IChodHRwUHJvbWlzZTogbmcuSUh0dHBQcm9taXNlQ2FsbGJhY2tBcmc8VD4pID0+IFQgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gPFQ+KGh0dHBQcm9taXNlOiBuZy5JSHR0cFByb21pc2VDYWxsYmFja0FyZzxUPik6IFQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFodHRwUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihgW0hUVFAgbm8tcmVzcG9uc2VdIFVuZXhwZWN0ZWQgJGh0dHAgZXJyb3IsIG5vIHJlc3BvbnNlIHByb21pc2UgcmV0dXJuZWQuYCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxDb25maWcuZGlzYWJsZVRvYXN0ZXJOb3RpZmljYXRpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvYXN0ZXIuZXJyb3IoJ1VuZXhwZWN0ZWQgYmVoYXZpb3InLCAnUGxlYXNlIGNvbnRhY3QgeW91ciBsb2NhbCBzdXBwb3J0IHRlYW0uJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBtdWx0aS10eXBlIHJldHVybiBpbiBjYXNlIG9mIHJlamVjdGlvbiBvciBkbyBzb21ldGhpbmcgZWxzZSA/IHRoaXMgbWV0aG9kIGlzIGN1cnJlbnRseSB1c2VkIHN5bmNocm9ub3VzbHkgd2l0aG91dCBwcm9taXNlIHdhaXRpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gdGhpcy4kcS5yZWplY3QoaHR0cFByb21pc2UpOyAvLyBSZWplY3QgcHJvbWlzZVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHJlamVjdCBpZiBzdGF0dXMgIT0gMlhYID9cclxuXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgd2hlbiBBUEkgaXMgZml4ZWQuIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzExNzQ2ODk0L3doYXQtaXMtdGhlLXByb3Blci1yZXN0LXJlc3BvbnNlLWNvZGUtZm9yLWEtdmFsaWQtcmVxdWVzdC1idXQtYW4tZW1wdHktZGF0YVxyXG4gICAgICAgICAgICAgICAgLy9pZiAoKHByb21pc2VDYWxsYmFjay5kYXRhID09PSBudWxsIHx8IHByb21pc2VDYWxsYmFjay5kYXRhID09PSB1bmRlZmluZWQpICYmIHByb21pc2VDYWxsYmFjay5zdGF0dXMgIT09IDIwNCkge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgdGhpcy4kbG9nLmVycm9yKCdVbmV4cGVjdGVkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciwgZXhwZWN0ZWQgcmVzcG9uc2UgZGF0YSBidXQgbm9uZSBmb3VuZC4nKTtcclxuICAgICAgICAgICAgICAgIC8vICAgIHRoaXMudG9hc3Rlci53YXJuaW5nKCdVbmV4cGVjdGVkIHJlc3BvbnNlJywgJ1BsZWFzZSBjb250YWN0IHlvdXIgbG9jYWwgc3VwcG9ydCB0ZWFtLicpO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KHByb21pc2VDYWxsYmFjayk7IC8vIFJlamVjdCBwcm9taXNlIGlmIG5vdCB3ZWxsLWZvcm1lZCBkYXRhXHJcbiAgICAgICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHNhbWUgYmVoYXZpb3IgYWxzbyBvbiBhIEdFVCByZXF1ZXN0ID8gaWYgcmVxdWVzdCBpcyBHRVQgYW5kIHJlc3BvbnNlIGlzIDIwMCB3aXRoIG5vIGRhdGEsIHJldHVybiBlcnJvciA/IChwYXNzIGluIHBhcmFtZXRlciByZXF1ZXN0IGNvbnRleHQgdG8gbG9nIHRoaXMgZXJyb3IpLlxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGdldCBmdWxsIHVybCBvZiByZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZGVidWcoYFtIVFRQICR7aHR0cFByb21pc2UuY29uZmlnLm1ldGhvZH1dIFske2h0dHBQcm9taXNlLmNvbmZpZy51cmx9XWAsIGh0dHBQcm9taXNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gb25seSB0aGUgZGF0YSBleHBlY3RlZCBmb3IgY2FsbGVyXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFByb21pc2UuZGF0YTtcclxuXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFcnJvciBoYW5kbGVyXHJcbiAgICAgICAgICogVE9ETyBNR0E6IGFuZ3VsYXIgc2lnbmF0dXJlcyBpbmRpY2F0ZXMgdGhhdCBwYXJhbWV0ZXIgaXMgcmVqZWN0aW9uIHJlYXNvbiwgbm90IG5lY2Vzc2FyaWx5IGh0dHBQcm9taXNlOiBpbnZlc3RpZ2F0ZSAmIGZpeCBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgKiBAcGFyYW0gaHR0cFByb21pc2UgXHJcbiAgICAgICAgICogQHJldHVybnMge30gXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBvbkVycm9yID0gPFQ+KG9yaWdpbmFsQ29uZmlnOiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiAoaHR0cFByb21pc2U6IG5nLklIdHRwUHJvbWlzZUNhbGxiYWNrQXJnPGFueT4pID0+IGFueSA9PiB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gPFQ+KGh0dHBQcm9taXNlOiBuZy5JSHR0cFByb21pc2VDYWxsYmFja0FyZzxhbnk+KTogYW55ID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHN1cHBvc2UgaW4gY2FzZSBvZiBubyByZXNwb25zZSB0aGF0IHRoZSBzcnYgZGlkbid0IHNlbmQgYW55IHJlc3BvbnNlLlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBNR0E6IG1heSBhbHNvIGJlIGEgZmF1bHQgaW4gaW50ZXJuYWwgJGh0dHAgLyBhamF4IGNsaWVudCBzaWRlIGxpYiwgdG8gZGlzdGluZ3Vpc2guXHJcbiAgICAgICAgICAgICAgICBpZiAoIWh0dHBQcm9taXNlIHx8ICFodHRwUHJvbWlzZS5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaHR0cFByb21pc2UuZGF0YSA9ICdTZXJ2ZXIgbm90IHJlc3BvbmRpbmcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLnN0YXR1cyA9IDUwMztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsQ29uZmlnLmRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSBodHRwUHJvbWlzZS5oZWFkZXJzKCdDb250ZW50LVR5cGUnKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgY29udGVudFR5cGUgdG8gdHJ5IHRvIGRpc3BsYXkgZXJyb3IgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSAmJiAoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTEgfHwgY29udGVudFR5cGUuaW5kZXhPZigndGV4dC9wbGFpbicpID4gLTEpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZTogc3RyaW5nID0gXCJcIjsgLy9kZWZhdWx0IG1lc3NhZ2VcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBlcnJvciBoYW5kbGluZyBtb3JlIGdlbmVyaWNhbGx5IGJhc2VkIG9uIGlucHV0IGVycm9yIG1lc3NhZ2UgY29udHJhY3QgaW5zdGVhZCBvZiBleHBlY3Rpbmcgc3BlY2lmaWMgZXJyb3Igc3RyY3R1cmUuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIChyZXNwb25zZS5kYXRhLk1vZGVsU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgLy9UT0RPIE1HQSA6IGhhbmRsZSB0aGlzIHdoZW4gd2VsbCBmb3JtYXR0ZWQgc2VydmVyLXNpZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy99IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh0dHBQcm9taXNlLmRhdGEuTWVzc2FnZSAmJiBhbmd1bGFyLmlzU3RyaW5nKGh0dHBQcm9taXNlLmRhdGEuTWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5ndWxhci5pc1N0cmluZyhodHRwUHJvbWlzZS5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGh0dHBQcm9taXNlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBtb3JlIHJlc3BvbnNlIGNvZGVzIGdyYWNlZnVsbHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChodHRwUHJvbWlzZS5zdGF0dXMgPT09IDQwNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2FzdGVyLndhcm5pbmcoJ05vdCBGb3VuZCcsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2FzdGVyLmVycm9yKCdTZXJ2ZXIgcmVzcG9uc2UgZXJyb3InLCBtZXNzYWdlICsgJ1xcbiBTdGF0dXM6ICcgKyBodHRwUHJvbWlzZS5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvYXN0ZXIuZXJyb3IoJ0ludGVybmFsIHNlcnZlciBlcnJvcicsICdTdGF0dXM6ICcgKyBodHRwUHJvbWlzZS5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBnZXQgZnVsbCB1cmwgb2YgcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKGBbSFRUUCAke2h0dHBQcm9taXNlLmNvbmZpZy5tZXRob2R9XSBbJHtodHRwUHJvbWlzZS5jb25maWcudXJsfV1gLCBodHRwUHJvbWlzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgcmVjb3ZlciBmcm9tIGVycm9yLCBzbyB3ZSBwcm9wYWdhdGUgaXQgOiBiZWxvdyBoYW5kbGVycyBoYXZlIHRoZSBjaG9pY2Ugb2YgcmVhZGluZyB0aGUgZXJyb3Igd2l0aCBhbiBlcnJvciBoYW5kbGVyIG9yIG5vdC4gU2VlICRxIHByb21pc2VzIGJlaGF2aW9yIGhlcmUgOiBodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3FcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgZGVzaXJlZCBzbyB0aGF0IHdlIHNob3cgZXJyb3IgaW5zaWRlIHNwZWNpZmljIHNlcnZlciBjb21tdW5pY2F0aW9uIG1vZGFscyBhdCBzcGVjaWZpYyBwbGFjZXMgaW4gdGhlIGFwcCwgb3RoZXJ3aXNlIHNob3cgYSBnbG9iYWwgYWxlcnQgbWVzc2FnZSwgb3IgZXZlbiBkbyBub3Qgc2hvdyBhbnl0aGluZyBpZiBub3QgbmVjZXNzYXJ5IChkbyBub3QgYWQgYW4gZXJyb3IgaGFuZGxlciBpbiBiZWxvdyBoYW5kbGVycyBvZiB0aGlzIHByb21pc2UpLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KGh0dHBQcm9taXNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRnVuY3Rpb24gY2FsbGVkIGF0IHRoZSBlbmQgb2YgYW4gYWpheCBjYWxsLCByZWdhcmRsZXNzIG9mIGl0J3Mgc3VjY2VzcyBvciBmYWlsdXJlLlxyXG4gICAgICAgICAqIEBwYXJhbSByZXNwb25zZVxyXG4gICAgICAgICAqIFRPRE8gTUdBIGludmVyc2lvbiBvZiByZXNwb25zYWJpbGl0eTogbWFrZSB0aGlzIGV4dGVuc2libGUgc28gdGhhdCBzcGVjaWZjIGFwcHMgY2FuIHBsdWcgaW50byB0aGlzIGV2ZW50IHdvcmtmbG93XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBmaW5hbGx5ID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBPRS1zcGVjaWZpYyBjb2RlXHJcbiAgICAgICAgICAgIGlmICgoPGFueT50aGlzLiR3aW5kb3cpLmJsb2NrX1VJICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHR5cGUgY2FzdGluZywgaXMgaXQgb2theSBvciBub3QgPyBiZXR0ZXIgYXBwcm9hY2ggP1xyXG4gICAgICAgICAgICAgICAgKDxhbnk+dGhpcy4kd2luZG93KS5wcmV2ZW50QmxvY2tVSSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVE9ETyBNR0EgOiB1c2luZyBtZXRob2QgZnJvbSBMYXlvdXQuanMgOiB0byBkb2N1bWVudCB0byBub3QgaGFuZGxlIGR1cGxpY2F0ZSBjb2RlICEhXHJcbiAgICAgICAgLy9UT0RPIE1HQTogdW5yb2J1c3QsIG5lZWRzIHNvbGlkIHJlZmFjdG8gdG8gbWFrZSBpdCBtb3JlIGdlbmVyaWMgd2hlbiBvbiBvcmlnaW4gZG9tYWluICFcclxuICAgICAgICBwcml2YXRlIGdldFVybFBhdGgoYWN0aW9uSXNPblNhbWVDb250cm9sbGVyOiBib29sZWFuKTogc3RyaW5nIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBiYXNlVXJsT21BcHBzUmVnZXggPSAvKFxcL1xcdytcXC9cXChTXFwoXFx3K1xcKVxcKSlcXC9cXHcrLztcclxuICAgICAgICAgICAgdmFyIGJhc2VVcmxBc3BBcHBzUmVnZXggPSAvKFxcL1xcdyspXFwvXFx3Ky87XHJcblxyXG4gICAgICAgICAgICB2YXIgdXJsID0gdGhpcy4kd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xyXG4gICAgICAgICAgICB2YXIgYmFzZVVybE9tQXBwc01hdGNoZXMgPSBiYXNlVXJsT21BcHBzUmVnZXguZXhlYyh1cmwpO1xyXG4gICAgICAgICAgICB2YXIgYmFzZVVybEFzcEFwcHNNYXRjaGVzID0gYmFzZVVybEFzcEFwcHNSZWdleC5leGVjKHVybCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZTogc3RyaW5nID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIGJhc2VVcmw6IHN0cmluZyA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvLyAyIG1hdGNoZXMgPSByZWdleCBtYXRjaGVzICsgdGhlIGNhcHR1cmluZyBncm91cFxyXG4gICAgICAgICAgICBpZiAoYmFzZVVybE9tQXBwc01hdGNoZXMgJiYgYmFzZVVybE9tQXBwc01hdGNoZXMubGVuZ3RoICYmIGJhc2VVcmxPbUFwcHNNYXRjaGVzLmxlbmd0aCA9PT0gMikge1xyXG5cclxuICAgICAgICAgICAgICAgIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWUgPSBiYXNlVXJsT21BcHBzTWF0Y2hlc1swXTtcclxuICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBiYXNlVXJsT21BcHBzTWF0Y2hlc1sxXTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiYXNlVXJsQXNwQXBwc01hdGNoZXMgJiYgYmFzZVVybEFzcEFwcHNNYXRjaGVzLmxlbmd0aCAmJiBiYXNlVXJsQXNwQXBwc01hdGNoZXMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lID0gYmFzZVVybEFzcEFwcHNNYXRjaGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgYmFzZVVybCA9IGJhc2VVcmxBc3BBcHBzTWF0Y2hlc1sxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGFjdGlvbklzT25TYW1lQ29udHJvbGxlciAmJiBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiYXNlVXJsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9UT0RPIE1HQTogT00tc3BlY2lmaWMgQVNQIE1WQyBjb2RlLCBub3QgdXNlZCBBVE0sIHRvIHJlbW92ZVxyXG4gICAgICAgIHByaXZhdGUgZ2V0Q3VycmVudFNlc3Npb25JRCgpOiBzdHJpbmcge1xyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQSA6IG1hZ2ljIHJlZ2V4cCB0byBmZXRjaCBTZXNzaW9uSUQgaW4gVVJMLCB0byBzdG9yZSBlbHNld2hlcmUgIVxyXG4gICAgICAgICAgICB2YXIgc2Vzc2lvblJlZ2V4ID0gL2h0dHBzOlxcL1xcL1tcXHcuXStcXC9bXFx3Ll0rXFwvKFxcKFNcXChcXHcrXFwpXFwpKVxcLy4qLztcclxuICAgICAgICAgICAgLy92YXIgc2Vzc2lvblJlZ2V4ID0gL2h0dHBzOlxcL1xcL1tcXHcuXStcXC9PcmRlckVudHJ5XFwvKFxcKFNcXChcXHcrXFwpXFwpKVxcLy4qLztcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdXBkYXRlIHJlZ2V4cCB0byB0aGUgb25lIGJlbG93XHJcbiAgICAgICAgICAgIC8vdmFyIGJhc2VVcmxSZWdleCA9IC8oaHR0cHM6XFwvXFwvW1xcdy4tXStcXC9bXFx3Li1dK1xcL1xcKFNcXChcXHcrXFwpXFwpXFwvKVxcdysvO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy4kbG9jYXRpb24uYWJzVXJsKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVnZXhwQXJyYXkgPSBzZXNzaW9uUmVnZXguZXhlYyhwYXRoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghcmVnZXhwQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVW5hYmxlIHRvIHJlY29nbml6ZWQgc2VhcmNoZWQgcGF0dGVybiBpbiBjdXJyZW50IHVybCBsb2NhdGlvbiB0byByZXRyaWV2ZSBzZXNzaW9uSUQuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlZ2V4cEFycmF5Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdVbmFibGUgdG8gZmluZCBzZXNzaW9uSUQgaW4gc2VhcmNoZWQgcGF0dGVybiBpbiBjdXJyZW50IHVybC4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVnZXhwQXJyYXkubGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdUb28gbWFueSBtYXRjaGVzIGZvdW5kIGZvciB0aGUgc2Vzc2lvbklEIHNlYXJjaCBpbiB0aGUgY3VycmVudCB1cmwuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZWdleHBBcnJheVsxXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyaW0gdGhlIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyIHRvIHJldHVybiBvbmx5IHRoZSBmaWxlbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0gY29udGVudERpc3Bvc2l0aW9uSGVhZGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBnZXRGaWxlTmFtZUZyb21IZWFkZXJDb250ZW50RGlzcG9zaXRpb24oY29udGVudERpc3Bvc2l0aW9uSGVhZGVyOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29udGVudERpc3Bvc2l0aW9uSGVhZGVyLnNwbGl0KCc7JylbMV0udHJpbSgpLnNwbGl0KCc9JylbMV07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlcGxhY2UoL1wiL2csICcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgfVxyXG59IiwiXG5cblxuXG52YXIgYmx1ZXNreTtcbihmdW5jdGlvbiAoYmx1ZXNreSkge1xuICAgIHZhciBjb3JlO1xuICAgIChmdW5jdGlvbiAoY29yZSkge1xuICAgICAgICB2YXIgc2VydmljZTtcbiAgICAgICAgKGZ1bmN0aW9uIChzZXJ2aWNlKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb3ZpZGVyIGZvciB0aGUgQmx1ZXNreUh0dHBXcmFwcGVyLlxuICAgICAgICAgICAgICogRW5hYmxlcyBwZXItY29uc3VtZXIgY29uZmlndXJhdGlvbiBvZiB0aGUgaHR0cCBzZXJ2aWNlIHRvIHNldCBjdXN0b20gY29uZmlndXJhdGlvbiBVUkwgdG8gZmV0Y2ggZGF0YSBmcm9tOlxuICAgICAgICAgICAgICogIC0gQ2xpZW50IGluaXRpYWwgY29uZmlndXJhdGlvbiBVUkwgZnJvbSB0aGUgb3JpZ2luIHRoZSBhcHAgd2FzIGxvYWRlZCBmcm9tLlxuICAgICAgICAgICAgICogIC0gVXNlclJvbGUgdG8gdXNlIG9mIGFscmVhZHkgZmV0Y2hlZCBmcm9tIGFub3RoZXIgcGxhY2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQmx1ZXNreUh0dHBXcmFwcGVyUHJvdmlkZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIC8vI3JlZ2lvbiBwcml2YXRlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDbGllbnRDb25maWdJbml0aWFsaXphdGlvblVybCA9ICdCbHVlc2t5QWpheENsaWVudENvbmZpZ3VyYXRpb24vR2V0QWpheENsaWVudENvbmZpZ3VyYXRpb24nOyAvLyBieSBkZWZhdWx0LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVXNlclJvbGUgPSBudWxsOyAvLyBieSBkZWZhdWx0IG5vdC1zZXQuXG4gICAgICAgICAgICAgICAgICAgIC8vI2VuZHJlZ2lvblxuICAgICAgICAgICAgICAgICAgICAvLyBQcm92aWRlcidzIGZhY3RvcnkgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLyogQG5nSW5qZWN0ICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGdldCA9IGZ1bmN0aW9uIChfLCAkaHR0cCwgJHdpbmRvdywgJGxvZywgJHEsICRsb2NhdGlvbiwgVXBsb2FkLCB0b2FzdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHNlcnZpY2UuQmx1ZXNreUh0dHBXcmFwcGVyKF8sICRodHRwLCAkd2luZG93LCAkbG9nLCAkcSwgJGxvY2F0aW9uLCBVcGxvYWQsIHRvYXN0ZXIsIF90aGlzLmdldENsaWVudENvbmZpZ0luaXRpYWxpemF0aW9uVXJsLCBfdGhpcy5zZWxlY3RlZFVzZXJSb2xlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8jZW5kcmVnaW9uXG4gICAgICAgICAgICAgICAgLy8jcmVnaW9uIHB1YmxpYyBjb25maWd1cmF0aW9uIG1ldGhvZHNcbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlci5wcm90b3R5cGUuc2V0Q2xpZW50Q29uZmlnVVJMID0gZnVuY3Rpb24gKGNsaWVudENvbmZpZ1VybFRvVXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2xpZW50Q29uZmlnSW5pdGlhbGl6YXRpb25VcmwgPSBjbGllbnRDb25maWdVcmxUb1VzZSB8fCB0aGlzLmdldENsaWVudENvbmZpZ0luaXRpYWxpemF0aW9uVXJsO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyUHJvdmlkZXIucHJvdG90eXBlLnNldFVzZXJSb2xlVG9Vc2UgPSBmdW5jdGlvbiAodXNlclJvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFVzZXJSb2xlID0gdXNlclJvbGUgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlcjtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICBzZXJ2aWNlLkJsdWVza3lIdHRwV3JhcHBlclByb3ZpZGVyID0gQmx1ZXNreUh0dHBXcmFwcGVyUHJvdmlkZXI7XG4gICAgICAgICAgICBhbmd1bGFyLm1vZHVsZSgnYmx1ZXNreS5odHRwV3JhcHBlcicsIFsndG9hc3RlcicsICduZ0FuaW1hdGUnLCAnbmdGaWxlVXBsb2FkJ10pXG4gICAgICAgICAgICAgICAgLmNvbnN0YW50KCdfJywgd2luZG93Ll8pXG4gICAgICAgICAgICAgICAgLmNvbnN0YW50KCdtb21lbnQnLCB3aW5kb3cubW9tZW50KVxuICAgICAgICAgICAgICAgIC5wcm92aWRlcignYmx1ZXNreUh0dHBXcmFwcGVyJywgQmx1ZXNreUh0dHBXcmFwcGVyUHJvdmlkZXIpO1xuICAgICAgICB9KShzZXJ2aWNlID0gY29yZS5zZXJ2aWNlIHx8IChjb3JlLnNlcnZpY2UgPSB7fSkpO1xuICAgIH0pKGNvcmUgPSBibHVlc2t5LmNvcmUgfHwgKGJsdWVza3kuY29yZSA9IHt9KSk7XG59KShibHVlc2t5IHx8IChibHVlc2t5ID0ge30pKTtcblxudmFyIGJsdWVza3k7XG4oZnVuY3Rpb24gKGJsdWVza3kpIHtcbiAgICB2YXIgY29yZTtcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcbiAgICAgICAgdmFyIHNlcnZpY2U7XG4gICAgICAgIChmdW5jdGlvbiAoc2VydmljZSkge1xuICAgICAgICAgICAgdmFyIEVuZHBvaW50VHlwZUVudW0gPSBibHVlc2t5LmNvcmUubW9kZWwuY2xpZW50Q29uZmlnLkVuZHBvaW50VHlwZUVudW07XG4gICAgICAgICAgICAoZnVuY3Rpb24gKEh0dHBNZXRob2QpIHtcbiAgICAgICAgICAgICAgICBIdHRwTWV0aG9kW0h0dHBNZXRob2RbXCJHRVRcIl0gPSAwXSA9IFwiR0VUXCI7XG4gICAgICAgICAgICAgICAgSHR0cE1ldGhvZFtIdHRwTWV0aG9kW1wiUE9TVFwiXSA9IDFdID0gXCJQT1NUXCI7XG4gICAgICAgICAgICAgICAgSHR0cE1ldGhvZFtIdHRwTWV0aG9kW1wiUFVUXCJdID0gMl0gPSBcIlBVVFwiO1xuICAgICAgICAgICAgICAgIEh0dHBNZXRob2RbSHR0cE1ldGhvZFtcIlBBVENIXCJdID0gM10gPSBcIlBBVENIXCI7XG4gICAgICAgICAgICAgICAgSHR0cE1ldGhvZFtIdHRwTWV0aG9kW1wiREVMRVRFXCJdID0gNF0gPSBcIkRFTEVURVwiO1xuICAgICAgICAgICAgfSkoc2VydmljZS5IdHRwTWV0aG9kIHx8IChzZXJ2aWNlLkh0dHBNZXRob2QgPSB7fSkpO1xuICAgICAgICAgICAgdmFyIEh0dHBNZXRob2QgPSBzZXJ2aWNlLkh0dHBNZXRob2Q7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB2YXIgQmx1ZXNreUh0dHBXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyNlbmRyZWdpb25cbiAgICAgICAgICAgICAgICAvLyNyZWdpb24gY3RvclxuICAgICAgICAgICAgICAgIC8qIEBuZ0luamVjdCAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEJsdWVza3lIdHRwV3JhcHBlcihfLCAkaHR0cCwgJHdpbmRvdywgJGxvZywgJHEsICRsb2NhdGlvbiwgVXBsb2FkLCB0b2FzdGVyLCBjb25maWdJbml0aWFsaXphdGlvblVSTCwgc2VsZWN0ZWRVc2VyUm9sZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAxIC0gZmV0Y2ggdGhlIGNvbmZpZ3VyYXRpb24gZGF0YSBuZWNlc3NhcnkgZm9yIHRoaXMgc2VydmljZSB0byBydW4gZnJvbSB0aGUgcHJvdmlkZWQgZW5kcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fID0gXztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kaHR0cCA9ICRodHRwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR3aW5kb3cgPSAkd2luZG93O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cgPSAkbG9nO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRxID0gJHE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvY2F0aW9uID0gJGxvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLlVwbG9hZCA9IFVwbG9hZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2FzdGVyID0gdG9hc3RlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWdJbml0aWFsaXphdGlvblVSTCA9IGNvbmZpZ0luaXRpYWxpemF0aW9uVVJMO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVXNlclJvbGUgPSBzZWxlY3RlZFVzZXJSb2xlO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgKiBQcmVwYXJlcyBhIHtAbGluayBuZyMkaHR0cCNjb25maWcgY29uZmlnfSBvYmplY3QgZm9yICRodHRwIGNhbGwuXG4gICAgICAgICAgICAgICAgICAgICogVGhlIG9wZXJhdGlvbnMgaW5jbHVkZSBzZXR0aW5nIGRlZmF1bHQgdmFsdWVzIHdoZW4gbm90IHByb3ZpZGVkLCBhbmQgc2V0dGluZyBodHRwIGhlYWRlcnMgaWYgbmVlZGVkIGZvciA6XG4gICAgICAgICAgICAgICAgICAgICogIC0gQWpheCBjYWxsc1xuICAgICAgICAgICAgICAgICAgICAqICAtIEF1dGhvcml6YXRpb24gdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgKiAgLSBDdXJyZW50IFVzZXJSb2xlLlxuICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge25nLiRodHRwLmNvbmZpZ30gdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHJlYWR5IHRvIGJlIGluamVjdGVkIGludG8gYSAkaHR0cCBjYWxsLlxuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZUh0dHBDYWxsID0gZnVuY3Rpb24gKG1ldGhvZCwgdXJsLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlucHV0IHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXJsIHx8IG1ldGhvZCA9PT0gbnVsbCB8fCBtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoJ1VSTCAmIE1FVEhPRCBwYXJhbWV0ZXJzIGFyZSBuZWNlc3NhcnkgZm9yIGh0dHBXcmFwcGVyIGNhbGxzLiBBYm9ydGluZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IGNvbmZpZyB2YWx1ZXMgYW5kIGN1c3RvbSBvbmVzIGJhc2VkIG9uIGVuZHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmVuZHBvaW50VHlwZSA9IGNvbmZpZy5lbmRwb2ludFR5cGUgfHwgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluOyAvLyBkZWZhdWx0IHZhbHVlOiBpZiBub3Qgc3BlY2lmaWVkLCBlbmRwb2ludCB0byB1c2UgaXMgc3VwcG9zZWQgdG8gYmUgdGhlIG9yaWdpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBieSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZW5kcG9pbnQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBNR0E6IG1ha2Ugc3VyZSBFbmRwb2ludFR5cGVFbnVtW2ludmFsaWQgdmFsdWVdIGRvZXNuJ3QgcmV0dXJuIGRlZmF1bHQgdmFsaWQgZW51bSB2YWx1ZSA/Pz8gb3RoZXJ3aXNlLCBkYW5nZXJvdXMgIVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRFbmRwb2ludENvbmZpZyA9IF90aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnICYmIF90aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLkVuZHBvaW50Q29uZmlndXJhdGlvbkRpY3Rpb25uYXJ5W0VuZHBvaW50VHlwZUVudW1bY29uZmlnLmVuZHBvaW50VHlwZV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZCBjYXN0IGlzIG5vdCBzYWZlLCB3ZSBtYXkgZm9yZ2V0IHRvIHNldCB1cmwgJiBtZXRob2QgcGFyYW1ldGVycy4gVE9GSVguXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGdldCBhbGwgbm9uLWZpbHRlcmVkIHBhcmFtZXRlcnMgJiBrZWVwIHRoZW0gZm9yIHRoaXMgbmV3IG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25maWdGdWxsID0gY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogc3VwcG9ydCBtYXBwaW5nIGJldHdlZW4gdXBsb2FkICYgcG9zdCBoZXJlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwubWV0aG9kID0gSHR0cE1ldGhvZFttZXRob2RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25maWd1cmUgZGVmYXVsdCBjb25maWcgZmxhZ3MgYmFzZWQgb24gdGFyZ2V0IGVuZHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbmZpZy5lbmRwb2ludFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uQ29yZUFwaTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uTWFya2V0aW5nQXBpOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5TZWxmY2FyZUFwaTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVqZWN0IGV4cGxpY2l0bHkgd3JvbmcgaW5wdXQgY29uZmlndXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cud2FybihcIltCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXSBbXCIgKyBjb25maWdGdWxsLm1ldGhvZCArIFwiIC8gXCIgKyB1cmwgKyBcIl0gLSBBUEkgY2FsbCBpbnRlbmRlZCB3aXRoIGluY29tcGF0aWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuIEFib3J0aW5nIGFqYXggY2FsbC5cIiwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbmZpZyB2YWx1ZXMgZm9yIEFQSSBlbmRwb2ludHMgYXJlIGRpZmZlcmVudCBmcm9tIGRlZmF1bHQsIHNvIHdlIG11c3Qgc3BlY2lmeSB0aGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyID0gZmFsc2U7IC8vIGJ5IGRlZmF1bHQgYWxyZWFkeSBlbmFibGVkLCBidXQgZW5mb3JlIHRoaXMgaGVhZGVyIGFzIG5lY2Vzc2FyeSBmb3IgY2FsbHMgdG8gV2ViQVBJIGVuZHBvaW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnVzZUN1cnJlbnRVc2VyUm9sZSA9IHRydWU7IC8vIGZvciBhcGkgY2FsbHMsIGZvcmNlIHRoaXMgcm9sZSB0byBiZSBwYXNzZWQgYXJvdW5kIChzaG91bGQgYmUgbWFuZGF0b3J5IHRvIGNvbnRleHR1YWxpemUgcmVxdWVzdCB0byByZWFsbSBvZiBjdXJyZW50IHVzZXIpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uUXVvdGVXaXphcmQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLk9yZGVyRW50cnk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLk9yZGVyVHJhY2tpbmc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBPTSBhcHBzIGNhbGxlZCBhcyBlbmRwb2ludHMsIG1ha2Ugc3VyZSB0aGUgWG1sSHR0cFJlcXVlc3QgaGVhZGVyIGlzIHByZXNlbnQgKEFTUC5ORVQgYXBwcykuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogYWRkIGN1cnJlbnRVc2VyUm9sZSBieSBkZWZhdWx0IHNvIHRoYXQgT00gYXBwcyBjYW4gY29udGV4dHVhbGlzZSB0aGUgcmVxdWVzdCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5NZXRyYW5ldDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uVGVjaG5pY2FsSW52ZW50b3J5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5UZW1wbGF0ZUdlbmVyYXRvcjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uU2FsZXNmb3JjZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogbm8gc3BlY2lmaWMgY29uZmlnIGZvciB0aG9zZSBleHRlcm5hbCBlbmRwb2ludHMgPyBhZGQgY3VzdG9tIG9uZXMgaWYgbmVlZGVkIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgYWpheCBjYWxscywgbWFrZSBzdXJlIHRoZSBYbWxIdHRwUmVxdWVzdCBoZWFkZXIgaXMgcHJlc2VudCAoQVNQLk5FVCBhcHBzKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VyIHJvbGUgaXMgdXNlZnVsbCBldmVuIGZvciBjdXJyZW50IGRvbWFpbiBzbyB0aGF0IHNydiBjYW4ga25vdyB0aGUgY29udGV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnVzZUN1cnJlbnRVc2VyUm9sZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5FeHRlcm5hbDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSB0byBjb25maXJtOiB3ZSBtYXkgd2FudCB0byBjYWxsIGV4dGVybmFsIHVybHMgdmlhIGFqYXgsIHNvIGhvdyB0byBiZSBzdXJlIG9mIGRlZmF1bHQgdmFsdWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyID0gdHJ1ZTsgLy8gZG8gbm90IGFkZCBYbWxIdHRwUmVxdWVzdCBpZiBleHRlcm5hbCBVcmwgYnkgZGVmYXVsdDogbWlnaHQgY3JlYXRlIGNvbmZsaWN0cyBvbiBjZXJ0YWluIHNlcnZlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRoaXMgaGVhZGVyIG91dHNpZGUgb2YgQVNQIHdvcmxkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKFwiW0JsdWVza3lIdHRwV3JhcHBlcl1bY29uZmlndXJlSHR0cENhbGxdW1wiICsgY29uZmlnRnVsbC5tZXRob2QgKyBcIiAvIFwiICsgdXJsICsgXCJdIC0gVW5zdXBwb3J0ZWQgZW5kcG9pbnRUeXBlIHByb3ZpZGVkOiAnXCIgKyBFbmRwb2ludFR5cGVFbnVtW2NvbmZpZy5lbmRwb2ludFR5cGUgfHwgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluXSArIFwiJy4gQWJvcnRpbmcuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHNob3VsZCB3ZSBhdXRob3JpemUgbm8gdmFsaWQgZW5kcG9pbnQgY29uZmlndXJhdGlvbiBsb2FkZWQgZm9yIGN1cnJlbnQgZG9tYWluID8gQXV0aFRva2VuIHN0aWxsIHVzZWZ1bGwgb3Igbm90ID8gQmFzZVVSTCBzdGlsbCB1c2VmdWxsIG9yIG5vdCA/IGFwaSBzdWZmaXggPyBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBleHRlcm5hbCBVUkxzLCBvYnZpb3VzbHkgZW5kcG9pbnQgY29uZmlnIGlzIG5vdCBtYW5kYXRvcnksIGJ1dCBpdCBjb3VsZCBiZSBwcm92aWRlZCBpZiBuZWVkZWQ6IGhvdyB0byBoYW5kbGUgdGhpcyBjYXNlP1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9SZWplY3QgYWpheCBjYWxscyBpbnRlbmRlZCB0byBleHRlcm5hbCBlbmRwb2ludHMgd2l0aG91dCBuZWNlc3NhcnkgY29uZmlndXJhdGlvbiBsb2FkZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5lbmRwb2ludFR5cGUgIT09IEVuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5lbmRwb2ludFR5cGUgIT09IEVuZHBvaW50VHlwZUVudW0uRXh0ZXJuYWwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhY3VycmVudEVuZHBvaW50Q29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihcIltCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXVtcIiArIGNvbmZpZ0Z1bGwubWV0aG9kICsgXCIgLyBcIiArIHVybCArIFwiXSAtIEFqYXggY2FsbCBpbnRlbmRlZCB3aXRob3V0IGV4cGVjdGVkIGVuZHBvaW50IGNvbmZpZ3VyYXRpb24gbG9hZGVkIGZyb20gdGhlIHNlcnZlciBmb3IgZW5kcG9pbnRUeXBlICdcIiArIEVuZHBvaW50VHlwZUVudW1bY29uZmlnLmVuZHBvaW50VHlwZV0gKyBcIicuIEFib3J0aW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHNldCBkZWZhdWx0IHZhbHVlcyBhZnRlciBlbmRwb2ludC1zcGVjaWZpYyBjb25maWd1cmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgfHwgZmFsc2U7IC8vIGRlZmF1bHQgdmFsdWUgaXMgZW5hYmxlZCAoYWpheCBjYWxscyBvbiAuTkVUIGVuZHBvaW50cykuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcudXNlQ3VycmVudFVzZXJSb2xlID0gY29uZmlnLnVzZUN1cnJlbnRVc2VyUm9sZSB8fCBmYWxzZTsgLy8gZGVmYXVsdCB2YWx1ZTogZG9uJ3QgdHJhbnNtaXQgc2Vuc2l0aXZlIGluZm9ybWF0aW9uIHRvIHJlbW90ZSBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVRvYXN0ZXJOb3RpZmljYXRpb25zID0gY29uZmlnLmRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucyB8fCBmYWxzZTsgLy9zZXQgZGVmYXVsdCB2YWx1ZSBmb3IgZGlzYWJsZVRvYXN0ZXJOb3RpZmljYXRpb25zIHRvIGZhbHNlIGFzIGl0J3MgcGFydCBvZiB0aGUgbm9ybWFsIGJlaGF2aW9yIGV4cGVjdGVkIGZvciB0aGlzIHNlcnZpY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gYnVpbGQgYSB2YWxpZCB1cmwgZnJvbSBpbnB1dCAmIGVuZHBvaW50VHlwZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwudXJsID0gX3RoaXMuYnVpbGRVcmxGcm9tQ29udGV4dCh1cmwsIGNvbmZpZy5lbmRwb2ludFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWdGdWxsLnVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoXCJbQmx1ZXNreUh0dHBXcmFwcGVyXVtjb25maWd1cmVIdHRwQ2FsbF0gLSBVbmFibGUgdG8gYnVpbGQgdXJsIGZyb20gdXJsSW5wdXQgJ1wiICsgdXJsICsgXCInIHdpdGggZW5kcG9pbnRUeXBlICdcIiArIEVuZHBvaW50VHlwZUVudW1bY29uZmlnLmVuZHBvaW50VHlwZV0gKyBcIicuIEFib3J0aW5nIGFqYXggY2FsbC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZCBjb2RlZCBoZWFkZXIgdG8gcHV0IGluIENPTlNUXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzWydYLVJlcXVlc3RlZC1XaXRoJ10gPSAnWE1MSHR0cFJlcXVlc3QnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWplY3QgY2FsbCB3aGVuIG1pc3NpbmcgbWFuZGF0b3J5IGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5DdXJyZW50VXNlclJvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihcIltCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXVtcIiArIGNvbmZpZ0Z1bGwubWV0aG9kICsgXCIgLyBcIiArIHVybCArIFwiXSAtIEFqYXggY2FsbCBpbnRlbmRlZCB3aXRob3V0IG5lY2Vzc2FyeSB1c2VyUm9sZSBzZXQgaW4gY29uZmlnLiBBYm9ydGluZy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkIGNvZGVkIGhlYWRlciB0byBwdXQgaW4gQ09OU1RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnNbJ09BLVVzZXJSb2xlJ10gPSBfdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5DdXJyZW50VXNlclJvbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhdXRoIHRva2VuIHByb3ZpZGVkIGZvciB0YXJnZXQgZW5kcG9pbnQsIGFkZCBpdCBpbiBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RW5kcG9pbnRDb25maWcgJiYgY3VycmVudEVuZHBvaW50Q29uZmlnLkF1dGhUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHJlamVjdCBhdXRoVG9rZW4gZm9yIGVuZHBvaW50cyB0aGF0IGFyZSBub3QgJ3NhZmUnIHRvIHNoYXJlIGF1dGggdG9rZW4gd2l0aCwgc3VjaCBhcyBFeHRlcm5hbCBvbmVzID8gT3IgYXV0aG9yaXplIHRoaXMgc28gdGhhdCBzZXJ2ZXIgY2FuIGxvYWQgYW4gYXV0aCB0b2tlbiBmb3IgY2VydGFpbiBleHRlcm5hbCBlbmRwb2ludHMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSB0b2tlbiB2YWxpZGl0eSBlbmREYXRlOiByZW5ldyBhdXRoIGJlZm9yZSB0aGUgY2FsbCAhIFdoYXQncyB0aGUgYmVzdCBtb21lbnQgdG8gZG8gaXQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY29kZWQgaGVhZGVyIHRvIHB1dCBpbiBDT05TVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0JlYXJlciAnICsgY3VycmVudEVuZHBvaW50Q29uZmlnLkF1dGhUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IE9FIHNwZWNpZmljIGNvZGUsIHRvIHJlbW92ZSwgb3IgYXQgbGVhc3QgcHV0IGluIGFzIGNvbmZpZyBwYXJhbVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLiR3aW5kb3cuYmxvY2tfVUkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHR5cGUgY2FzdGluZywgaXMgaXQgb2theSBvciBub3QgPyBiZXR0ZXIgYXBwcm9hY2ggP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiR3aW5kb3cucHJldmVudEJsb2NrVUkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ0Z1bGw7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBTdWNjZXNzIGhhbmRsZXIuXG4gICAgICAgICAgICAgICAgICAgICAqIENhcHR1cmVzIHRoZSBpbnB1dCBwYXJhbWV0ZXJzIGF0IHRoZSBtb21lbnQgb2YgaXRzIGRlY2xhcmF0aW9uICYgcmV0dXJuIHRoZSByZWFsIGhhbmRsZXIgdG8gYmUgY2FsbGVkIHVwb24gcHJvbWlzZSBjb21wbGV0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgKiBJbnB1dCBwYXJhbWV0ZXJzOlxuICAgICAgICAgICAgICAgICAgICAgKiAgLSBjYWxsaW5nQ29uZmlnOiBjb25maWd1cmF0aW9uIHVzZWQgdG8gbWFrZSB0aGUgYWpheCBjYWxsLCBpbiBjYXNlIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIG51bGwvZW1wdHkgYW5kIGRvZXNuJ3QgY29udGFpbiBuZWNlc3NhcnkgZGF0YSBmb3IgZGVidWdnaW5nLlxuICAgICAgICAgICAgICAgICAgICAgKiAgLSBnZXRDb21wbGV0ZVJlc3BvbnNlT2JqZWN0OiBmbGFnIGluZGljYXRpb24gaWYgd2UgbXVzdCByZXR1cm4gdGhlIGZ1bGwgcmVzcG9uc2Ugb2JqZWN0IGFsb25nIHdpdGggaGVhZGVycyBhbmQgc3RhdHVzIG9yIG9ubHkgdGhlIGlubmVyIGRhdGEuIEJ5IGRlZmF1bHQgJiBpZiBub3Qgc3BlY2lmaWVkLCBvbmx5IHJldHVybnMgaW5uZXIgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TdWNjZXNzID0gZnVuY3Rpb24gKG9yaWdpbmFsQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGh0dHBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFodHRwUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKFwiW0hUVFAgbm8tcmVzcG9uc2VdIFVuZXhwZWN0ZWQgJGh0dHAgZXJyb3IsIG5vIHJlc3BvbnNlIHByb21pc2UgcmV0dXJuZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsQ29uZmlnLmRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRvYXN0ZXIuZXJyb3IoJ1VuZXhwZWN0ZWQgYmVoYXZpb3InLCAnUGxlYXNlIGNvbnRhY3QgeW91ciBsb2NhbCBzdXBwb3J0IHRlYW0uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiByZWplY3QgaWYgc3RhdHVzICE9IDJYWCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIHdoZW4gQVBJIGlzIGZpeGVkLiBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMTc0Njg5NC93aGF0LWlzLXRoZS1wcm9wZXItcmVzdC1yZXNwb25zZS1jb2RlLWZvci1hLXZhbGlkLXJlcXVlc3QtYnV0LWFuLWVtcHR5LWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmICgocHJvbWlzZUNhbGxiYWNrLmRhdGEgPT09IG51bGwgfHwgcHJvbWlzZUNhbGxiYWNrLmRhdGEgPT09IHVuZGVmaW5lZCkgJiYgcHJvbWlzZUNhbGxiYWNrLnN0YXR1cyAhPT0gMjA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgdGhpcy4kbG9nLmVycm9yKCdVbmV4cGVjdGVkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciwgZXhwZWN0ZWQgcmVzcG9uc2UgZGF0YSBidXQgbm9uZSBmb3VuZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICB0aGlzLnRvYXN0ZXIud2FybmluZygnVW5leHBlY3RlZCByZXNwb25zZScsICdQbGVhc2UgY29udGFjdCB5b3VyIGxvY2FsIHN1cHBvcnQgdGVhbS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QocHJvbWlzZUNhbGxiYWNrKTsgLy8gUmVqZWN0IHByb21pc2UgaWYgbm90IHdlbGwtZm9ybWVkIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBzYW1lIGJlaGF2aW9yIGFsc28gb24gYSBHRVQgcmVxdWVzdCA/IGlmIHJlcXVlc3QgaXMgR0VUIGFuZCByZXNwb25zZSBpcyAyMDAgd2l0aCBubyBkYXRhLCByZXR1cm4gZXJyb3IgPyAocGFzcyBpbiBwYXJhbWV0ZXIgcmVxdWVzdCBjb250ZXh0IHRvIGxvZyB0aGlzIGVycm9yKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBnZXQgZnVsbCB1cmwgb2YgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZGVidWcoXCJbSFRUUCBcIiArIGh0dHBQcm9taXNlLmNvbmZpZy5tZXRob2QgKyBcIl0gW1wiICsgaHR0cFByb21pc2UuY29uZmlnLnVybCArIFwiXVwiLCBodHRwUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIG9ubHkgdGhlIGRhdGEgZXhwZWN0ZWQgZm9yIGNhbGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBodHRwUHJvbWlzZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICogVE9ETyBNR0E6IGFuZ3VsYXIgc2lnbmF0dXJlcyBpbmRpY2F0ZXMgdGhhdCBwYXJhbWV0ZXIgaXMgcmVqZWN0aW9uIHJlYXNvbiwgbm90IG5lY2Vzc2FyaWx5IGh0dHBQcm9taXNlOiBpbnZlc3RpZ2F0ZSAmIGZpeCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIGh0dHBQcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt9XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IgPSBmdW5jdGlvbiAob3JpZ2luYWxDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaHR0cFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzdXBwb3NlIGluIGNhc2Ugb2Ygbm8gcmVzcG9uc2UgdGhhdCB0aGUgc3J2IGRpZG4ndCBzZW5kIGFueSByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQTogbWF5IGFsc28gYmUgYSBmYXVsdCBpbiBpbnRlcm5hbCAkaHR0cCAvIGFqYXggY2xpZW50IHNpZGUgbGliLCB0byBkaXN0aW5ndWlzaC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWh0dHBQcm9taXNlIHx8ICFodHRwUHJvbWlzZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLmRhdGEgPSAnU2VydmVyIG5vdCByZXNwb25kaW5nJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cFByb21pc2Uuc3RhdHVzID0gNTAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsQ29uZmlnLmRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSBodHRwUHJvbWlzZS5oZWFkZXJzKCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBjb250ZW50VHlwZSB0byB0cnkgdG8gZGlzcGxheSBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSAmJiAoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTEgfHwgY29udGVudFR5cGUuaW5kZXhPZigndGV4dC9wbGFpbicpID4gLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiXCI7IC8vZGVmYXVsdCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgZXJyb3IgaGFuZGxpbmcgbW9yZSBnZW5lcmljYWxseSBiYXNlZCBvbiBpbnB1dCBlcnJvciBtZXNzYWdlIGNvbnRyYWN0IGluc3RlYWQgb2YgZXhwZWN0aW5nIHNwZWNpZmljIGVycm9yIHN0cmN0dXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAocmVzcG9uc2UuZGF0YS5Nb2RlbFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAvL1RPRE8gTUdBIDogaGFuZGxlIHRoaXMgd2hlbiB3ZWxsIGZvcm1hdHRlZCBzZXJ2ZXItc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy99IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2UgJiYgYW5ndWxhci5pc1N0cmluZyhodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGh0dHBQcm9taXNlLmRhdGEuTWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFuZ3VsYXIuaXNTdHJpbmcoaHR0cFByb21pc2UuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gaHR0cFByb21pc2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBtb3JlIHJlc3BvbnNlIGNvZGVzIGdyYWNlZnVsbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHR0cFByb21pc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50b2FzdGVyLndhcm5pbmcoJ05vdCBGb3VuZCcsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9hc3Rlci5lcnJvcignU2VydmVyIHJlc3BvbnNlIGVycm9yJywgbWVzc2FnZSArICdcXG4gU3RhdHVzOiAnICsgaHR0cFByb21pc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRvYXN0ZXIuZXJyb3IoJ0ludGVybmFsIHNlcnZlciBlcnJvcicsICdTdGF0dXM6ICcgKyBodHRwUHJvbWlzZS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGdldCBmdWxsIHVybCBvZiByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihcIltIVFRQIFwiICsgaHR0cFByb21pc2UuY29uZmlnLm1ldGhvZCArIFwiXSBbXCIgKyBodHRwUHJvbWlzZS5jb25maWcudXJsICsgXCJdXCIsIGh0dHBQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCByZWNvdmVyIGZyb20gZXJyb3IsIHNvIHdlIHByb3BhZ2F0ZSBpdCA6IGJlbG93IGhhbmRsZXJzIGhhdmUgdGhlIGNob2ljZSBvZiByZWFkaW5nIHRoZSBlcnJvciB3aXRoIGFuIGVycm9yIGhhbmRsZXIgb3Igbm90LiBTZWUgJHEgcHJvbWlzZXMgYmVoYXZpb3IgaGVyZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgZGVzaXJlZCBzbyB0aGF0IHdlIHNob3cgZXJyb3IgaW5zaWRlIHNwZWNpZmljIHNlcnZlciBjb21tdW5pY2F0aW9uIG1vZGFscyBhdCBzcGVjaWZpYyBwbGFjZXMgaW4gdGhlIGFwcCwgb3RoZXJ3aXNlIHNob3cgYSBnbG9iYWwgYWxlcnQgbWVzc2FnZSwgb3IgZXZlbiBkbyBub3Qgc2hvdyBhbnl0aGluZyBpZiBub3QgbmVjZXNzYXJ5IChkbyBub3QgYWQgYW4gZXJyb3IgaGFuZGxlciBpbiBiZWxvdyBoYW5kbGVycyBvZiB0aGlzIHByb21pc2UpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kcS5yZWplY3QoaHR0cFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEZ1bmN0aW9uIGNhbGxlZCBhdCB0aGUgZW5kIG9mIGFuIGFqYXggY2FsbCwgcmVnYXJkbGVzcyBvZiBpdCdzIHN1Y2Nlc3Mgb3IgZmFpbHVyZS5cbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAqIFRPRE8gTUdBIGludmVyc2lvbiBvZiByZXNwb25zYWJpbGl0eTogbWFrZSB0aGlzIGV4dGVuc2libGUgc28gdGhhdCBzcGVjaWZjIGFwcHMgY2FuIHBsdWcgaW50byB0aGlzIGV2ZW50IHdvcmtmbG93XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsbHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBPRS1zcGVjaWZpYyBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuJHdpbmRvdy5ibG9ja19VSSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdHlwZSBjYXN0aW5nLCBpcyBpdCBva2F5IG9yIG5vdCA/IGJldHRlciBhcHByb2FjaCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJHdpbmRvdy5wcmV2ZW50QmxvY2tVSSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmlndXJhdGlvbkVuZHBvaW50VXJsID0gdGhpcy5idWlsZFVybEZyb21Db250ZXh0KGNvbmZpZ0luaXRpYWxpemF0aW9uVVJMLCBFbmRwb2ludFR5cGVFbnVtLkN1cnJlbnREb21haW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb25FbmRwb2ludFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKFwiW0JsdWVza3lIdHRwV3JhcHBlcl1bSW5pdGlhbGl6YXRpb25dIC0gVW5hYmxlIHRvIGJ1aWxkIHVybCBmcm9tIGluaXRpYWxDb25maWcgdXJsICdcIiArIGNvbmZpZ0luaXRpYWxpemF0aW9uVVJMICsgXCInIHdpdGggZW5kcG9pbnRUeXBlICdcIiArIEVuZHBvaW50VHlwZUVudW1bRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluXSArIFwiJy4gQWJvcnRpbmcgYmx1ZXNreUh0dHBTZXJ2aWNlIGluaXQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGN1c3RvbSBjb25maWcgZm9yIGhlYWRlcnMgaGFyZCBjb2RlZCwgdG8gbXV0dWFsaXplIHdpdGggY29uc3RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRBamF4Q29uZmlnRnJvbVNlcnZlclByb21pc2UgPSB0aGlzLiRodHRwLmdldChjb25maWd1cmF0aW9uRW5kcG9pbnRVcmwsIHsgaGVhZGVyczogeyAnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCcgfSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNsaWVudENvbmZpZ1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHJlamVjdCBzdGF0dXMgbm90IGluIDJYWCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsaWVudENvbmZpZ1Byb21pc2UuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBcIltCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIFVuYWJsZSB0byByZXRyaWV2ZSBodHRwIGNvbmZpZyBkYXRhIGZyb20gJ1wiICsgY29uZmlnSW5pdGlhbGl6YXRpb25VUkwgKyBcIicuIEFib3J0aW5nIGJsdWVza3lIdHRwV3JhcHBlclNlcnZpY2UgaW5pdGlhbGl6YXRpb24uXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHRvYXN0ZXIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kcS5yZWplY3QobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuaW5mbygnW0JsdWVza3lIdHRwV3JhcHBlcl1bSW5pdGlhbGl6YXRpb25dIC0gU3VjY2Vzc2Z1bGx5IGxvYWRlZCBjbGllbnRDb25maWcgZnJvbSBzcnY6JywgY2xpZW50Q29uZmlnUHJvbWlzZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnID0gY2xpZW50Q29uZmlnUHJvbWlzZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudENvbmZpZ1Byb21pc2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgICAgIC8vIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcignW0JsdWVza3lIdHRwV3JhcHBlcl1bSW5pdGlhbGl6YXRpb25dIC0gVW5hYmxlIHRvIHJldHJpZXZlIEFQSSBjb25maWcuIEFib3J0aW5nIGJsdWVza3lIdHRwV3JhcHBlclNlcnZpY2UgaW5pdGlhbGl6YXRpb24uIFNydiBtc2c6ICcsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHNob3cgdG9hc3RlciA/IGJhc2VkIG9uIHByb3ZpZGVyIGNvbmZpZyBmbGFnID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kcS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKFxuICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChibHVlc2t5Q2xpZW50Q29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgY2FzZSB3aGVyZSBjbGllbnQtc2lkZSB1c2VyUm9sZSB3YXMgcHJvdmlkZWQgYW5kIG5vdCA9PSBzcnYtc2lkZSB1c2VyIHJvbGUgIVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFibHVlc2t5Q2xpZW50Q29uZmlnLkN1cnJlbnRVc2VyUm9sZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgbm90IHByb3ZpZGVkIGJ5IGRvbWFpbiBmcm9tIHdoaWNoIGNvZGUgd2FzIGxvYWRlZCwgdGhlbiB0cnkgdG8gZmV0Y2ggZGVmYXVsdCB1c2VyUm9sZSBmcm9tIENBUEkgZW5kcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmluZm8oJ1tCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIE5vIGRlZmF1bHQgVXNlclJvbGUgcHJvdmlkZWQgYnkgY3VycmVudCBkb21haW4sIHRyeWluZyB0byBmZXRjaCBpdCBmcm9tIENBUEkuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvcmVBcGlDb25maWcgPSBibHVlc2t5Q2xpZW50Q29uZmlnLkVuZHBvaW50Q29uZmlndXJhdGlvbkRpY3Rpb25uYXJ5W0VuZHBvaW50VHlwZUVudW1bRW5kcG9pbnRUeXBlRW51bS5Db3JlQXBpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb3JlQXBpQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnW0JsdWVza3lIdHRwV3JhcHBlcl1bSW5pdGlhbGl6YXRpb25dIC0gRmFpbGVkIHRvIHJldHJpZXZlIG5lY2Vzc2FyeSBDb3JlQXBpIGVuZHBvaW50IGNvbmZpZyB0byBmZXRjaCB1c2VyU1NPLiBBYm9ydGluZy4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kcS5yZWplY3QobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogZmFjdG9yaXplIHdpdGggY29uZmlndXJlSHR0cENhbGwoKSAhISB0aGlzIGlzIGEgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIGNhbm5vdCB1c2UgYWpheCgpIERSWSBtZXRob2QgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1c3RvbUNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1gtUmVxdWVzdGVkLVdpdGgnOiAnWE1MSHR0cFJlcXVlc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyICcgKyBjb3JlQXBpQ29uZmlnLkF1dGhUb2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0VXNlclNzb0Z1bGxVcmwgPSBfdGhpcy5idWlsZFVybEZyb21Db250ZXh0KCd1c2VyLXNzbz9wcm9maWxlPScsIEVuZHBvaW50VHlwZUVudW0uQ29yZUFwaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRodHRwLmdldChnZXRVc2VyU3NvRnVsbFVybCwgY3VzdG9tQ29uZmlnKS50aGVuKGZ1bmN0aW9uICh1c2VyU3NvUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJTc29Qcm9taXNlIHx8ICF1c2VyU3NvUHJvbWlzZS5kYXRhIHx8ICF1c2VyU3NvUHJvbWlzZS5kYXRhLlVzZXJSb2xlRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3JlQXBpQ29uZmlnTWlzc2luZ01zZyA9ICdbQmx1ZXNreUh0dHBXcmFwcGVyXVtJbml0aWFsaXphdGlvbl0gLSBVbmFibGUgdG8gcmV0cmlldmUgQ29yZUFQSSBkZWZhdWx0IHVzZXJTU08uIEFib3J0aW5nIGh0dHBXcmFwcGVyU2VydmljZSBpbml0aWFsaXphdGlvbi4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihjb3JlQXBpQ29uZmlnTWlzc2luZ01zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJHEucmVqZWN0KGNvcmVBcGlDb25maWdNaXNzaW5nTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlclNzbyA9IHVzZXJTc29Qcm9taXNlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuaW5mbyhcIltCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIERlZmF1bHQgdXNlclNTTyBsb2FkZWQgZnJvbSBDQVBJOiAnXCIgKyB1c2VyU3NvLlVzZXJEaXNwbGF5TmFtZSArIFwiJy5cIiwgdXNlclNzbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZFVzZXJSb2xlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5pbmZvKFwiW0JsdWVza3lIdHRwV3JhcHBlcl1bSW5pdGlhbGl6YXRpb25dIC0gQ2xpZW50IGFwcCBwcm92aWRlZCBzYXZlZCBVc2VyUm9sZS4gQXNzaWduaW5nIGl0LlwiLCBfdGhpcy5zZWxlY3RlZFVzZXJSb2xlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogbWFrZSBzdXJlIHNlbGVjdGVkVXNlclJvbGUgaXMgYXZhaWxhYmxlIGluIHRoZSBsaXN0IG9mIHVzZXJTU08gcm9sZXMsIG90aGVyd2lzZSBzZWxlY3QgZGVmYXVsdCAhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhvdyB0byBpbmZvcm0gYmFjayB0aGUgREEgdGhhdCBzZWxlY3RlZFVzZXJSb2xlIHdhcyByZXNldCA/IGludmVydCByZXNwb25zYWJpbGl0eSAmIHN0b3JlIHVzZXJSb2xlIGluIGxvY2FsU3RvcmFnZSBmcm9tIHRoaXMgc2VydmljZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1c2VyUm9sZVRvVXNlID0gc2VsZWN0ZWRVc2VyUm9sZSB8fCB1c2VyU3NvLlVzZXJSb2xlRW50cnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHRoaXMgbmVlZHMgdG8gYmUgcHV0IGluIHNoYXJlZCBleHRlbnNpb24gbWV0aG9kIC8gc2VydmljZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5DdXJyZW50VXNlclJvbGUgPSB1c2VyUm9sZVRvVXNlLk5hbWUgKyBcIiBcIiArIHVzZXJSb2xlVG9Vc2UuUm9sZSArIFwiIFwiICsgdXNlclJvbGVUb1VzZS5TaWxvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5DdXJyZW50VXNlciA9IHVzZXJTc287XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBibHVlc2t5Q2xpZW50Q29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogd2Ugb25seSBsb2FkIHVzZXJTU08gaWYgbm8gdXNlclJvbGUgd2FzIHByb3ZpZGVkIHNydi1zaWRlLCBzaG91bGQgd2UgbG9hZCBpdCBpbiBhbGwgY2FzZXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgZGVmaW5lZCB1c2VyUm9sZSBzZW50IGZyb20gb3JpZ2luIGFwcCwgdXNlIGl0ICYgc2V0IGl0IGFzIGRlZmF1bHQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsdWVza3lDbGllbnRDb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyNlbmRyZWdpb25cbiAgICAgICAgICAgICAgICAvLyNyZWdpb24gcHVibGljIG1ldGhvZHNcbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmwsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4KEh0dHBNZXRob2QuR0VULCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICh1cmwsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4KEh0dHBNZXRob2QuREVMRVRFLCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuZGF0YSA9IGRhdGEgfHwgY29uZmlnLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheChIdHRwTWV0aG9kLlBPU1QsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBkYXRhIHx8IGNvbmZpZy5kYXRhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4KEh0dHBNZXRob2QuUFVULCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLnBhdGNoID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBkYXRhIHx8IGNvbmZpZy5kYXRhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4KEh0dHBNZXRob2QuUEFUQ0gsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRPRE8gTUdBOiBub3QgRFJZIHdpdGggYWpheCBtZXRob2QsIGhvdyB0byBrZWVwIGl0IGluIHN5bmMgP1xuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB1cmxcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZmlsZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh1cmwsIGZpbGUsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGUgJiYgKCFjb25maWcgfHwgIWNvbmZpZy5maWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdDYW5ub3Qgc3RhcnQgdXBsb2FkIHdpdGggbnVsbCB7ZmlsZX0gcGFyYW1ldGVyLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuZmlsZSA9IGZpbGUgfHwgY29uZmlnLmZpbGU7IC8vVE9ETyBNR0EgOiBkbyBub3QgZXhwb3NlIGZpbGUgaW4gSUJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyA/XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gY29uZmlnLmRhdGEgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcudXBsb2FkSW5CYXNlNjRKc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBtYWtlIHN1cmUgdGhpcyBkZWxheXMgbmV4dCBjYWxsIGFuZCB1cGxvYWQgaXMgbm90IGRvbmUgYmVmb3JlIGJhc2U2NCBlbmNvZGluZyBpcyBmaW5pc2hlZCwgZXZlbiBpZiBwcm9taXNlIGlzIGFscmVhZHkgcmVzb2x2ZWQgPz8/XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5VcGxvYWQuYmFzZTY0RGF0YVVybChmaWxlKS50aGVuKGZ1bmN0aW9uIChmaWxlQmFzZTY0VXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZC1jb2RlZCBrZXkgdG8gZmV0Y2ggYmFzZTY0IGVuY29kaW5nLCB0byBwYXJhbWV0cml6ZSB3aXRoIHNlcnZlci1zaWRlICFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGF0YS5maWxlQmFzZTY0VXJsID0gZmlsZUJhc2U2NFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25vcm1hbCBwb3N0IGluIGNhc2Ugb2YgYmFzZTY0LWVuY29kZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hamF4KEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGF0YS5maWxlRm9ybURhdGFOYW1lID0gJ2ZpbGUnOyAvLyBmaWxlIGZvcm1EYXRhIG5hbWUgKCdDb250ZW50LURpc3Bvc2l0aW9uJyksIHNlcnZlciBzaWRlIHJlcXVlc3QgZm9ybSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogZG8gbm90IGJsb2NrIGlmIG5vdCBjYWxsIHRvIGludGVybmFsIEFQSSA/IChpbml0Q2FsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFqYXhDb25maWdGcm9tU2VydmVyUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogYmVoYXZpb3IgZHVwbGljYXRpb24gd2l0aCB0aGlzLmFqYXgsIG5vdCBEUlksIHRvIGltcHJvdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdENvbmZpZyA9IF90aGlzLmNvbmZpZ3VyZUh0dHBDYWxsKEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0Q29uZmlnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuVXBsb2FkLnVwbG9hZChyZXF1ZXN0Q29uZmlnKSAvL1RPRE8gTUdBIDogbm90IHNhZmUgaGFyZCBjYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihfdGhpcy5vblN1Y2Nlc3MoY29uZmlnKSwgX3RoaXMub25FcnJvcihjb25maWcpLCBjb25maWcudXBsb2FkUHJvZ3Jlc3MpIC8vVE9ETyBNR0EgOiB1cGxvYWRQcm9ncmVzcyBjYWxsYmFjayBvayA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseShfdGhpcy5maW5hbGx5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy9UT0RPIE1HQTogd2hhdCB0byByZXR1cm4gP1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gZG93bmxvYWQgYSBmaWxlIGluIHRoZSBmb3JtIG9mIGEgYnl0ZS1zdHJlYW0gZnJvbSBhbiBlbmRwb2ludCBhbmQgd3JhcCBpdCBpbnRvIGEgRmlsZUNvbnRlbnQgb2JqZWN0IHdpdGggbmFtZSwgdHlwZSAmIHNpemUgcHJvcGVydGllcyByZWFkIGZyb20gdGhlIEhUVFAgcmVzcG9uc2UgaGVhZGVycyBvZiB0aGUgc2VydmV1ci5cbiAgICAgICAgICAgICAgICAgKiBJdCBpcyB0aGUgcmVzcG9uc2FiaWxpdHkgb2YgdGhlIGNvbnN1bWVyIHRvIGRvIHNvbWV0aGluZyB3aXRoIHRoZSB3cmFwcGVkIGJ5dGVBcnJheSAoZm9yIGV4YW1wbGUgZG93bmxvYWQgdGhlIGZpbGUsIG9yIHNob3cgaXQgaW5zaWRlIHRoZSB3ZWJQYWdlIGV0YykuXG4gICAgICAgICAgICAgICAgICogVE9ETyBNR0E6IG5vdCBEUlkgd2l0aCBhamF4IG1ldGhvZCwgaG93IHRvIGtlZXAgaXQgaW4gc3luYyA/XG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHVybFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBleHBlY3RlZE5hbWVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXhwZWN0ZWRTaXplXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV4cGVjdGVkVHlwZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLmdldEZpbGUgPSBmdW5jdGlvbiAodXJsLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWpheENvbmZpZ0Zyb21TZXJ2ZXJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ3VsYXJIdHRwQ29uZmlnID0gX3RoaXMuY29uZmlndXJlSHR0cENhbGwoSHR0cE1ldGhvZC5HRVQsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vIGNvbmZpZyByZXR1cm5lZCwgY29uZmlndXJhdGlvbiBmYWlsZWQsIGRvIG5vdCBzdGFydCBhamF4IHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYW5ndWxhckh0dHBDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJHEucmVqZWN0KCdVbmFibGUgdG8gY29uZmlndXJlIHJlcXVlc3QgY29ycmVjdGx5LiBBYm9ydGluZyBnZXRGaWxlIGFqYXggY2FsbC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljYWxseSBleHBlY3QgcmF3IHJlc3BvbnNlIHR5cGUsIG90aGVyd2lzZSBieXRlIHN0cmVhbSByZXNwb25zZXMgYXJlIGNvcnJ1cHRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXJIdHRwQ29uZmlnLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0V4cGVjdGVkIEFycmF5QnVmZmVyIHJlc3BvbnNlID0gYnl0ZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRodHRwKGFuZ3VsYXJIdHRwQ29uZmlnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChodHRwUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2JlbmVmaXQgZnJvbSBzdWNjZXNzQ2FsbGJhY2sgdmFsaWRhdGlvbiBiZWZvcmUgY29udGludWluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJheUJ1ZmZlciA9IF90aGlzLm9uU3VjY2Vzcyhjb25maWcpKGh0dHBSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogcHJvbWlzZSByZWplY3Rpb24gdnMuIHJldHVybiBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFycmF5QnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy9zdG9wIHByb2Nlc3NpbmcgaWYgdW5hYmxlIHRvIHJldHJpZXZlIGJ5dGUgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlYWQgZmlsZSBpbmZvIGZyb20gcmVzcG9uc2UtaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlQ29udGVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogX3RoaXMuZ2V0RmlsZU5hbWVGcm9tSGVhZGVyQ29udGVudERpc3Bvc2l0aW9uKGh0dHBSZXNwb25zZS5oZWFkZXJzKCdjb250ZW50LWRpc3Bvc2l0aW9uJykpIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IE51bWJlcihodHRwUmVzcG9uc2UuaGVhZGVycygnY29udGVudC1sZW5ndGgnKSkgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogaHR0cFJlc3BvbnNlLmhlYWRlcnMoJ2NvbnRlbnQtdHlwZScpIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBhcnJheUJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgX3RoaXMub25FcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseShfdGhpcy5maW5hbGx5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUcmllcyB0byBwYXJzZSB0aGUgaW5wdXQgdXJsIDpcbiAgICAgICAgICAgICAgICAgKiBJZiBpdCBzZWVtcyB0byBiZSBhIGZ1bGwgVVJMLCB0aGVuIHJldHVybiBhcyBpcyAoY29uc2lkZXJzIGl0IGV4dGVybmFsIFVybClcbiAgICAgICAgICAgICAgICAgKiBPdGhlcndpc2UsIHRyaWVzIHRvIGZpbmQgdGhlIGJhc2UgVVJMIG9mIHRoZSBjdXJyZW50IEJsdWVTa3kgYXBwIHdpdGggb3Igd2l0aG91dCB0aGUgaW5jbHVkZWQgQ29udHJvbGxlciBhbmQgcmV0dXJucyB0aGUgZnVsbCBVcmxcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdXJsSW5wdXQgOiBUT0RPIE1HQTogZG9jdW1lbnQgZGlmZmVyZW50IGtpbmQgb2YgdXJscyB0aGF0IHRoaXMgbWV0aG9kIGNhbiB0YWtlIGFzIGlucHV0IChmdWxsLCBwYXJ0aWFsIGV0YylcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIG51bGwgaWYgbm90IGFibGUgdG8gY29tcHV0ZSB1cmwuIE90aGVyd2lzZSwgdXJsIG9mIHRoZSByZXF1ZXN0IGVpdGhlciBwYXJ0aWFsIG9yIGZ1bGwgYmFzZWQgb24gZW5kcG9pbnRUeXBlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUuYnVpbGRVcmxGcm9tQ29udGV4dCA9IGZ1bmN0aW9uICh1cmxJbnB1dCwgZW5kcG9pbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXJsSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignTm8gVVJMIGlucHV0IHByb3ZpZGVkLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgVXJsIHN0YXJ0cyB3aXRoIGh0dHA6Ly8gb3IgaHR0cHM6Ly8gPT4gcmV0dXJuIGFzIGlzLCBldmVuIGlmIGVuZHBvaW50VHlwZSBpcyBub3QgZXh0ZXJuYWwuXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmxJbnB1dC5zbGljZSgwLCAnaHR0cDovLycubGVuZ3RoKSA9PT0gJ2h0dHA6Ly8nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmxJbnB1dC5zbGljZSgwLCAnaHR0cHM6Ly8nLmxlbmd0aCkgPT09ICdodHRwczovLycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRwb2ludFR5cGUgIT09IEVuZHBvaW50VHlwZUVudW0uRXh0ZXJuYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLndhcm4oJ0Z1bGwgVVJMIHByb3ZpZGVkIGZvciBhIGNhbGwgdGhhdCBpcyBub3QgZmxhZ2dlZCBhcyBcXCdFeHRlcm5hbFxcJyBlbmRwb2ludFR5cGUsIHRoaXMgaXMgYmFkIHByYWN0aWNlIGFzIG9ubHkgdGhlIGJsdWVza3lXcmFwcGVyIHNob3VsZCBrbm93IGFib3V0IHRoZSBiYXNlVVJMIG9mIHRhcmdldCBlbmRwb2ludHMgKGxvYWRlZCBmcm9tIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IGVudikuIFVzZSBwYXJ0aWFsIFVSTHMuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsSW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSwgd2UgaGF2ZSBhIHBhcnRpYWwgVVJMIHRvIGNvbXBsZXRlOiB1c2UgcHJvdmlkZWQgZW5kcG9pbnQgdHlwZSB0byBkZXRlcm1pbmUgaG93IHRvIGNvbXBsZXRlIHVybC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZSBmb3IgZW5kcG9pbnRUeXBlIGlmIG5vdCBwcm92aWRlZCBpcyBvcmlnaW4uIFRPRE8gTUdBOiBydWxlIHRvIGRpc2N1c3MsIGhlcmUgZm9yIHJldHJvLWNvbXBhdGliaWxpdHkuXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50VHlwZSA9IGVuZHBvaW50VHlwZSB8fCBFbmRwb2ludFR5cGVFbnVtLkN1cnJlbnREb21haW47XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVXJsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kcG9pbnRUeXBlID09PSBFbmRwb2ludFR5cGVFbnVtLkV4dGVybmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cud2FybignUGFydGlhbCB1cmwgcHJvdmlkZWQgZm9yIGEgY2FsbCB3aXRoIGVuZHBvaW50VHlwZSBmbGFnZ2VkIGFzIFxcJ0V4dGVybmFsXFwnOiB0aGUgY2FsbCB3aWxsIHByb2JhYmx5IGZhaWwuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgbW9kaWZ5IHByb3ZpZGVkIHVybCBpZiBleHRlcm5hbCAod2UgY2Fubm90IGtub3cgaG93IHRvIGNvbXBsZXRlIGl0LCBldmVuIGlmIHBhcnRpYWwpLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybElucHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBub3QgbG9hZGluZyB0aGUgZW5kcG9pbnRDb25maWcgZm9yIGN1cnJlbnQgZG9tYWluIG1lYW5zIHdlIGNhbid0IGFjY2VzcyBlbmRwb2ludEFQSXN1ZmZpeCBpZiBpdCBleGlzdHMsIHNob3VsZCB3ZSBsb2FkIHRoZSBlbmRwb2ludENvbmZpZyBmb3IgdGhpcyBjYXNlIHRvbyA/PyAmIGhhbmRsZSBpdCB0aGUgc2FtZSB3YXkgYXMgb3RoZXIgZW5kcG9pbnRzID9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZ2V4IHRyeWluZyB0byBkZXRlcm1pbmUgaWYgdGhlIGlucHV0IGZyYWdtZW50IGNvbnRhaW5zIGEgLyBiZXR3ZWVuIHR3byBjaGFyYWN0ZXIgc3VpdGVzID0+IGNvbnRyb2xsZXIgZ2l2ZW4gYXMgaW5wdXQsIG90aGVyd2lzZSwgYWN0aW9uIG9uIHNhbWUgY29udHJvbGxlciBleHBlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXJJc1ByZXNlbnRSZWdleCA9IC9cXHcrXFwvXFx3Ky87XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aW9uSXNPblNhbWVDb250cm9sbGVyID0gIWNvbnRyb2xsZXJJc1ByZXNlbnRSZWdleC50ZXN0KHVybElucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSB0aGlzLmdldFVybFBhdGgoYWN0aW9uSXNPblNhbWVDb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBhbGwgb3RoZXIgZW5kcG9pbnRUeXBlczogY29tcHV0ZSBVUkwgYXMgYSBjb21iaW5hdGlvbiBvZiBiYXNlVVJMICYgc3VmZml4IGlmIHByZXNlbnQsIGFzIHByb3ZpZGVkIGJ5IHNlcnZlci1jb25maWd1cmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuRW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ0V4cGVjdGVkIGVuZHBvaW50Q29uZmlndXJhdGlvbkRpY3Rpb25uYXJ5IHByb3ZpZGVkIGJ1dCBub25lIGZvdW5kLiBBYm9ydGluZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIEhBQ0tZOiBzZWFyY2ggYnkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGVuZHBvaW50IHR5cGUgaW4gZGljdCBkdWUgdG8gc2VyaWFsaXphdGlvbiBsaW1pdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRwb2ludENvbmZpZyA9IHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuRW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnlbRW5kcG9pbnRUeXBlRW51bVtlbmRwb2ludFR5cGVdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZW5kcG9pbnRDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoXCJFbmRwb2ludFR5cGUgJ1wiICsgRW5kcG9pbnRUeXBlRW51bVtlbmRwb2ludFR5cGVdICsgXCInIGlzIG5vdCAnRXh0ZXJuYWwnIG9yICdDdXJyZW50RG9tYWluJywgZXhwZWN0ZWQgY29ycmVzcG9uZGluZyBlbmRwb2ludENvbmZpZ3VyYXRpb24gcHJvdmlkZWQgaW4gYmx1ZXNreUFqYXhDbGllbnRDb25maWcuZW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnkgYnV0IG5vbmUgZm91bmQuIEFib3J0aW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBlbmRwb2ludENvbmZpZy5FbmRwb2ludEJhc2VVUkwgKyAoZW5kcG9pbnRDb25maWcuRW5kcG9pbnRTdWZmaXggfHwgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhvdyB0byBoYW5kbGUgT00gYXBwcyBleHRlcm5hbCBjYWxscyB3aXRob3V0IHNlc3Npb24gcHJvdmlkZWQgPyB3aWxsIHJlc3VsdCBpbiBhIHJlZGlyZWN0IGFuZCBjYWxsIG1heSBmYWlsID9cbiAgICAgICAgICAgICAgICAgICAgLy8gQm9vbGVhbiB1c2VkIHRvIHRyeSB0byBkZXRlcm1pbmUgY29ycmVjdCBmdWxsIHVybCAoYWRkIC8gb3Igbm90IGJlZm9yZSB0aGUgdXJsIGZyYWdtZW50IGRlcGVuZGluZyBvbiBpZiBmb3VuZCBvciBub3QpXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaCA9IHVybElucHV0LnNsaWNlKDAsIDEpID09PSAnLyc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVXJsRnJhZ21lbnRFbmRzV2l0aFNsYXNoID0gYmFzZVVybC5zbGljZShiYXNlVXJsLmxlbmd0aCAtIDEsIGJhc2VVcmwubGVuZ3RoKSA9PT0gJy8nO1xuICAgICAgICAgICAgICAgICAgICAvL2Jhc2VkIG9uIHN0YXJ0aW5nL3RyYWlsaW5nIHNsYXNoZXMsIHJldHVybiBmdWxsIHVybC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VVcmxGcmFnbWVudEVuZHNXaXRoU2xhc2ggJiYgdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgbGFzdCAnLycgb24gYmFzZVVybFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmwuc2xpY2UoMCwgYmFzZVVybC5sZW5ndGggLSAxKSArIHVybElucHV0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiAhdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2gpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybCArICcvJyArIHVybElucHV0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiAhdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2gpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoIWJhc2VVcmxGcmFnbWVudEVuZHNXaXRoU2xhc2ggJiYgdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2gpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmwgKyB1cmxJbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyNlbmRyZWdpb25cbiAgICAgICAgICAgICAgICAvLyNyZWdpb24gcHJpdmF0ZSBtZXRob2RzXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVXRpbGl0eSBtZXRob2QuXG4gICAgICAgICAgICAgICAgICogTWFpbiBjYWxsZXIgdGhhdCBhbGwgd3JhcHBlciBjYWxscyAoZ2V0LCBkZWxldGUsIHBvc3QsIHB1dCkgbXVzdCB1c2UgdG8gc2hhcmUgY29tbW9uIGJlaGF2aW9yLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLmFqYXggPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogbWFrZSBzdXJlIGdldENvbmZpZyByZXNvbHZlIGF1dG9tYXRpY2FsbHkgd2l0aG91dCBvdmVyaGVhZCBvbmNlIGZpcnN0IGNhbGwgc3VjZXNzZnVsbC5cbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGRvIG5vdCBibG9jayBpZiBub3QgY2FsbCB0byBpbnRlcm5hbCBBUEkgKGluaXRDYWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBamF4Q29uZmlnRnJvbVNlcnZlclByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5ndWxhckh0dHBDb25maWcgPSBfdGhpcy5jb25maWd1cmVIdHRwQ2FsbChtZXRob2QsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmd1bGFySHR0cENvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJGh0dHAoYW5ndWxhckh0dHBDb25maWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKF90aGlzLm9uU3VjY2Vzcyhjb25maWcpLCBfdGhpcy5vbkVycm9yKGNvbmZpZykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KF90aGlzLmZpbmFsbHkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdXNpbmcgbWV0aG9kIGZyb20gTGF5b3V0LmpzIDogdG8gZG9jdW1lbnQgdG8gbm90IGhhbmRsZSBkdXBsaWNhdGUgY29kZSAhIVxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHVucm9idXN0LCBuZWVkcyBzb2xpZCByZWZhY3RvIHRvIG1ha2UgaXQgbW9yZSBnZW5lcmljIHdoZW4gb24gb3JpZ2luIGRvbWFpbiAhXG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5nZXRVcmxQYXRoID0gZnVuY3Rpb24gKGFjdGlvbklzT25TYW1lQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybE9tQXBwc1JlZ2V4ID0gLyhcXC9cXHcrXFwvXFwoU1xcKFxcdytcXClcXCkpXFwvXFx3Ky87XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVXJsQXNwQXBwc1JlZ2V4ID0gLyhcXC9cXHcrKVxcL1xcdysvO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gdGhpcy4kd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybE9tQXBwc01hdGNoZXMgPSBiYXNlVXJsT21BcHBzUmVnZXguZXhlYyh1cmwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybEFzcEFwcHNNYXRjaGVzID0gYmFzZVVybEFzcEFwcHNSZWdleC5leGVjKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyAyIG1hdGNoZXMgPSByZWdleCBtYXRjaGVzICsgdGhlIGNhcHR1cmluZyBncm91cFxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVVybE9tQXBwc01hdGNoZXMgJiYgYmFzZVVybE9tQXBwc01hdGNoZXMubGVuZ3RoICYmIGJhc2VVcmxPbUFwcHNNYXRjaGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSA9IGJhc2VVcmxPbUFwcHNNYXRjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IGJhc2VVcmxPbUFwcHNNYXRjaGVzWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJhc2VVcmxBc3BBcHBzTWF0Y2hlcyAmJiBiYXNlVXJsQXNwQXBwc01hdGNoZXMubGVuZ3RoICYmIGJhc2VVcmxBc3BBcHBzTWF0Y2hlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWUgPSBiYXNlVXJsQXNwQXBwc01hdGNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gYmFzZVVybEFzcEFwcHNNYXRjaGVzWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIgJiYgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYmFzZVVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogT00tc3BlY2lmaWMgQVNQIE1WQyBjb2RlLCBub3QgdXNlZCBBVE0sIHRvIHJlbW92ZVxuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUuZ2V0Q3VycmVudFNlc3Npb25JRCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IG1hZ2ljIHJlZ2V4cCB0byBmZXRjaCBTZXNzaW9uSUQgaW4gVVJMLCB0byBzdG9yZSBlbHNld2hlcmUgIVxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Vzc2lvblJlZ2V4ID0gL2h0dHBzOlxcL1xcL1tcXHcuXStcXC9bXFx3Ll0rXFwvKFxcKFNcXChcXHcrXFwpXFwpKVxcLy4qLztcbiAgICAgICAgICAgICAgICAgICAgLy92YXIgc2Vzc2lvblJlZ2V4ID0gL2h0dHBzOlxcL1xcL1tcXHcuXStcXC9PcmRlckVudHJ5XFwvKFxcKFNcXChcXHcrXFwpXFwpKVxcLy4qLztcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBNR0EgOiB1cGRhdGUgcmVnZXhwIHRvIHRoZSBvbmUgYmVsb3dcbiAgICAgICAgICAgICAgICAgICAgLy92YXIgYmFzZVVybFJlZ2V4ID0gLyhodHRwczpcXC9cXC9bXFx3Li1dK1xcL1tcXHcuLV0rXFwvXFwoU1xcKFxcdytcXClcXClcXC8pXFx3Ky87XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy4kbG9jYXRpb24uYWJzVXJsKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWdleHBBcnJheSA9IHNlc3Npb25SZWdleC5leGVjKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4cEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ1VuYWJsZSB0byByZWNvZ25pemVkIHNlYXJjaGVkIHBhdHRlcm4gaW4gY3VycmVudCB1cmwgbG9jYXRpb24gdG8gcmV0cmlldmUgc2Vzc2lvbklELicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdleHBBcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVW5hYmxlIHRvIGZpbmQgc2Vzc2lvbklEIGluIHNlYXJjaGVkIHBhdHRlcm4gaW4gY3VycmVudCB1cmwuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2V4cEFycmF5Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVG9vIG1hbnkgbWF0Y2hlcyBmb3VuZCBmb3IgdGhlIHNlc3Npb25JRCBzZWFyY2ggaW4gdGhlIGN1cnJlbnQgdXJsLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdleHBBcnJheVsxXTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRyaW0gdGhlIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyIHRvIHJldHVybiBvbmx5IHRoZSBmaWxlbmFtZS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY29udGVudERpc3Bvc2l0aW9uSGVhZGVyXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5nZXRGaWxlTmFtZUZyb21IZWFkZXJDb250ZW50RGlzcG9zaXRpb24gPSBmdW5jdGlvbiAoY29udGVudERpc3Bvc2l0aW9uSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGVudERpc3Bvc2l0aW9uSGVhZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb250ZW50RGlzcG9zaXRpb25IZWFkZXIuc3BsaXQoJzsnKVsxXS50cmltKCkuc3BsaXQoJz0nKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKC9cIi9nLCAnJyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmx1ZXNreUh0dHBXcmFwcGVyO1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgIHNlcnZpY2UuQmx1ZXNreUh0dHBXcmFwcGVyID0gQmx1ZXNreUh0dHBXcmFwcGVyO1xuICAgICAgICB9KShzZXJ2aWNlID0gY29yZS5zZXJ2aWNlIHx8IChjb3JlLnNlcnZpY2UgPSB7fSkpO1xuICAgIH0pKGNvcmUgPSBibHVlc2t5LmNvcmUgfHwgKGJsdWVza3kuY29yZSA9IHt9KSk7XG59KShibHVlc2t5IHx8IChibHVlc2t5ID0ge30pKTtcbiJdfQ==
