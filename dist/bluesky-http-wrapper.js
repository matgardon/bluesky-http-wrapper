"use strict";

"use strict";

"use strict";
var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var service;
        (function (service) {
            /**
             * Provider for the BlueskyHttpWrapper.
             * Enables per-consumer configuration of the http service to set custom configuration URL to fetch data from:
             *  - Client initial configuration URL from the origin the app was loaded from.
             *  - UserRole to use of already fetched from another place.
             */
            var BlueskyHttpWrapperProvider = /** @class */ (function () {
                function BlueskyHttpWrapperProvider() {
                    //#region private properties
                    var _this = this;
                    this.getClientConfigInitializationUrl = 'BlueskyAjaxClientConfiguration/GetAjaxClientConfiguration'; // by default.
                    //#endregion
                    // Provider's factory function
                    /* @ngInject */
                    this.$get = ["$http", "$window", "$log", "$q", "Upload", "toaster", function ($http, $window, $log, $q, Upload, toaster) {
                        return new service.BlueskyHttpWrapper($http, $window, $log, $q, Upload, toaster, _this.selectedUserRole, _this.getClientConfigInitializationUrl);
                    }];
                    this.$get.$inject = ["$http", "$window", "$log", "$q", "Upload", "toaster"];
                }
                //#endregion
                //#region public configuration methods
                BlueskyHttpWrapperProvider.prototype.setClientConfigURL = function (clientConfigUrlToUse) {
                    this.getClientConfigInitializationUrl = clientConfigUrlToUse || this.getClientConfigInitializationUrl;
                };
                BlueskyHttpWrapperProvider.prototype.setUserRoleToUse = function (userRole) {
                    this.selectedUserRole = userRole || undefined;
                };
                return BlueskyHttpWrapperProvider;
            }());
            service.BlueskyHttpWrapperProvider = BlueskyHttpWrapperProvider;
            angular.module('bluesky.httpWrapper', ['toaster', 'ngAnimate', 'ngFileUpload'])
                .constant('_', window._)
                .constant('moment', window.moment)
                .provider('blueskyHttpWrapper', BlueskyHttpWrapperProvider);
        })(service = core.service || (core.service = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

"use strict";
var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var service;
        (function (service) {
            var EndpointTypeEnum = bluesky.core.model.clientConfig.EndpointTypeEnum;
            // import AjaxClientEndpointConfigurationDto = bluesky.core.model.clientConfig.IAjaxClientEndpointConfigurationDto;
            var HttpMethod;
            (function (HttpMethod) {
                HttpMethod[HttpMethod["GET"] = 0] = "GET";
                HttpMethod[HttpMethod["POST"] = 1] = "POST";
                HttpMethod[HttpMethod["PUT"] = 2] = "PUT";
                HttpMethod[HttpMethod["PATCH"] = 3] = "PATCH";
                HttpMethod[HttpMethod["DELETE"] = 4] = "DELETE";
            })(HttpMethod = service.HttpMethod || (service.HttpMethod = {}));
            ;
            var BlueskyHttpWrapper = /** @class */ (function () {
                //#endregion
                //#region ctor
                /* @ngInject */
                BlueskyHttpWrapper.$inject = ["$http", "$window", "$log", "$q", "Upload", "toaster", "selectedUserRole", "configInitializationURL"];
                function BlueskyHttpWrapper($http, $window, $log, $q, Upload, toaster, selectedUserRole, configInitializationURL) {
                    // 1 - fetch the configuration data necessary for this service to run from the provided endpoint
                    var _this = this;
                    this.$http = $http;
                    this.$window = $window;
                    this.$log = $log;
                    this.$q = $q;
                    this.Upload = Upload;
                    this.toaster = toaster;
                    this.selectedUserRole = selectedUserRole;
                    /**
                     * Prepares bluesky-specific configuration based on provided inputs.
                     * The operations include setting default values when not provided, and setting http headers if needed for :
                     *  - Ajax calls
                     *  - Authorization token
                     *  - Current UserRole.
                     * @param config user input config if provided.
                     * @returns the configuration object with automatic rules applied.
                     */
                    this.setupBlueskyConfig = function (config) {
                        // set default config values and custom ones based on endpoints
                        config = config || {};
                        config.endpointType = config.endpointType || EndpointTypeEnum.CurrentDomain; // default value: if not specified, endpoint to use is supposed to be the origin.
                        // search by string representation of endpoint type
                        // TODO MGA: make sure EndpointTypeEnum[invalid value] doesn't return default valid enum value ??? otherwise, dangerous !
                        var currentEndpointConfig = _this.blueskyAjaxClientConfig && _this.blueskyAjaxClientConfig.EndpointConfigurationDictionnary[EndpointTypeEnum[config.endpointType]];
                        config.headers = config.headers || {};
                        // configure default config flags based on target endpoint
                        switch (config.endpointType) {
                            case EndpointTypeEnum.CoreApi:
                            case EndpointTypeEnum.MarketingApi:
                            case EndpointTypeEnum.SelfcareApi:
                            case EndpointTypeEnum.MetraNetApi:
                            case EndpointTypeEnum.ResourceApi:
                            case EndpointTypeEnum.MonitoringApi:
                                // Reject explicitly wrong input configurations
                                if (config.disableXmlHttpRequestHeader) {
                                    _this.$log.warn("[BlueskyHttpWrapper][setupBlueskyConfig] - API call intended with incompatible configuration options. Aborting ajax call.", config);
                                    return undefined;
                                }
                                // config values for API endpoints are different from default, so we must specify them.
                                config.disableXmlHttpRequestHeader = false; // by default already enabled, but enfore this header as necessary for calls to WebAPI endpoints.
                                config.useCurrentUserRole = true; // for api calls, force this role to be passed around (should be mandatory to contextualize request to realm of current user).
                                break;
                            case EndpointTypeEnum.QuoteWizard:
                            case EndpointTypeEnum.OrderEntry:
                            case EndpointTypeEnum.OrderTracking:
                                // for OM apps called as endpoints, make sure the XmlHttpRequest header is present (ASP.NET apps).
                                config.disableXmlHttpRequestHeader = false;
                                //TODO MGA: add currentUserRole by default so that OM apps can contextualise the request ?
                                break;
                            case EndpointTypeEnum.Metranet:
                            case EndpointTypeEnum.TechnicalInventory:
                            case EndpointTypeEnum.TemplateGenerator:
                            case EndpointTypeEnum.Salesforce:
                                //TODO MGA: no specific config for those external endpoints ? add custom ones if needed here.
                                break;
                            case EndpointTypeEnum.CurrentDomain:
                                // for ajax calls, make sure the XmlHttpRequest header is present (ASP.NET apps).
                                config.disableXmlHttpRequestHeader = false;
                                // user role is usefull even for current domain so that srv can know the context.
                                config.useCurrentUserRole = true;
                                break;
                            case EndpointTypeEnum.External:
                                //TODO MGA to confirm: we may want to call external urls via ajax, so how to be sure of default value ?
                                config.disableXmlHttpRequestHeader = true; // do not add XmlHttpRequest if external Url by default: might create conflicts on certain servers that don't support this header outside of ASP world.
                                break;
                            default:
                                _this.$log.error("[BlueskyHttpWrapper][setupBlueskyConfig] - Unsupported endpointType provided: '" + EndpointTypeEnum[config.endpointType || EndpointTypeEnum.CurrentDomain] + "'. Aborting.", config);
                                return undefined;
                        }
                        //TODO MGA: should we authorize no valid endpoint configuration loaded for current domain ? AuthToken still usefull or not ? BaseURL still usefull or not ? api suffix ? 
                        // For external URLs, obviously endpoint config is not mandatory, but it could be provided if needed: how to handle this case?
                        //Reject ajax calls intended to external endpoints without necessary configuration loaded from the server.
                        if (config.endpointType !== EndpointTypeEnum.CurrentDomain &&
                            config.endpointType !== EndpointTypeEnum.External &&
                            !currentEndpointConfig) {
                            _this.$log.error("[BlueskyHttpWrapper][setupBlueskyConfig] - Ajax call intended without expected endpoint configuration loaded from the server for endpointType '" + EndpointTypeEnum[config.endpointType] + "'. Aborting.", config);
                            return undefined;
                        }
                        //TODO MGA: set default values after endpoint-specific configurations
                        config.disableXmlHttpRequestHeader = config.disableXmlHttpRequestHeader || false; // default value is enabled (ajax calls on .NET endpoints).
                        config.useCurrentUserRole = config.useCurrentUserRole || false; // default value: don't transmit sensitive information to remote if not explicitly specified.
                        config.disableToasterNotifications = config.disableToasterNotifications || false; //set default value for disableToasterNotifications to false as it's part of the normal behavior expected for this service.
                        if (!config.disableXmlHttpRequestHeader)
                            //TODO MGA: hard coded header to put in CONST
                            config.headers['X-Requested-With'] = 'XMLHttpRequest';
                        if (config.useCurrentUserRole) {
                            // Reject call when missing mandatory information
                            if (!_this.blueskyAjaxClientConfig.CurrentUserRole) {
                                _this.$log.error("[BlueskyHttpWrapper][setupBlueskyConfig] - Ajax call intended without necessary userRole set in config. Aborting.", config);
                                return undefined;
                            }
                            //TODO MGA: hard coded header to put in CONST
                            config.headers['OA-UserRole'] = _this.blueskyAjaxClientConfig.CurrentUserRole;
                        }
                        // If auth token provided for target endpoint, add it in header
                        // protect against cases where endpointType is current domain or external: endpointConfig null/undefined.
                        if (currentEndpointConfig && currentEndpointConfig.AuthToken) {
                            //TODO MGA: reject authToken for endpoints that are not 'safe' to share auth token with, such as External ones ? Or authorize this so that server can load an auth token for certain external endpoints ?
                            //TODO MGA: handle token validity endDate: renew auth before the call ! What's the best moment to do it ?
                            //TODO MGA: hard coded header to put in CONST
                            config.headers['Authorization'] = 'Bearer ' + currentEndpointConfig.AuthToken;
                        }
                        //TODO MGA: OE specific code, to remove, or at least put in as config param
                        if (_this.$window.block_UI !== undefined)
                            // TODO MGA : type casting, is it okay or not ? better approach ?
                            _this.$window.preventBlockUI = true;
                        return config;
                    };
                    this.extractAngularConfigFromBlueskyConfig = function (method, url, blueskyConfig) {
                        // input validation
                        if (!url || method === null || method === undefined) {
                            _this.$log.error('URL & METHOD parameters are necessary to configure httpWrapper calls. Aborting.');
                            return undefined;
                        }
                        if (!blueskyConfig) {
                            _this.$log.error('bluesky config missing. Aborting.');
                            return undefined;
                        }
                        //TODO MGA: hard cast is not safe, we may forget to set url & method parameters. TOFIX.
                        // automatically get all non-filtered parameters & keep them for this new object.
                        var angularConfig = blueskyConfig;
                        //TODO MGA: support mapping between upload & post here ?
                        angularConfig.method = HttpMethod[method];
                        // Try to build a valid url from input & endpointType.
                        var finalUrlToFetch = _this.buildUrlFromContext(url, blueskyConfig.endpointType);
                        if (!finalUrlToFetch) {
                            _this.$log.error('[BlueskyHttpWrapper - ajax call builder] - unable to construct valid url to call. aborting.');
                            return undefined;
                        }
                        angularConfig.url = finalUrlToFetch;
                        if (!angularConfig.url) {
                            _this.$log.error("[BlueskyHttpWrapper][configureHttpCall] - Unable to build url from urlInput '" + url + "' with endpointType '" + (blueskyConfig.endpointType ? EndpointTypeEnum[blueskyConfig.endpointType] : "unknown endpoint") + "'. Aborting ajax call.");
                            return undefined;
                        }
                        return angularConfig;
                    };
                    /**
                     * Success handler.
                     * Captures the input parameters at the moment of its declaration & return the real handler to be called upon promise completion.
                     * Input parameters:
                     *  - callingConfig: configuration used to make the ajax call, in case the returned promise is null/empty and doesn't contain necessary data for debugging.
                     *  - getCompleteResponseObject: flag indication if we must return the full response object along with headers and status or only the inner data. By default & if not specified, only returns inner data.
                     */
                    this.onSuccess = function (originalConfig) {
                        if (!originalConfig) {
                            _this.$log.warn('unable to retrieve originalConfig in onSuccess. Please provide complete config.');
                        }
                        return function (httpPromise) {
                            if (!httpPromise) {
                                var msg = "[HTTP no-response] Unexpected $http error, no response promise returned.";
                                _this.$log.error(msg);
                                if (!originalConfig.disableToasterNotifications)
                                    _this.toaster.error('unexpected behavior', 'Please contact your local support team.');
                                throw new Error(msg);
                                //TODO MGA: handle multi-type return in case of rejection or do something else ? this method is currently used synchronously without promise waiting.
                                //return this.$q.reject(httpPromise); // Reject promise
                            }
                            //TODO MGA: reject if status != 2XX ?
                            //TODO MGA: handle when API is fixed. See http://stackoverflow.com/questions/11746894/what-is-the-proper-rest-response-code-for-a-valid-request-but-an-empty-data
                            //if ((promiseCallback.data === null || promiseCallback.data === undefined) && promiseCallback.status !== 204) {
                            //    this.$log.error('Unexpected response from the server, expected response data but none found.');
                            //    this.toaster.warning('Unexpected response', 'Please contact your local support team.');
                            //    return this.$q.reject(promiseCallback); // Reject promise if not well-formed data
                            //}
                            //TODO MGA: same behavior also on a GET request ? if request is GET and response is 200 with no data, return error ? (pass in parameter request context to log this error).
                            //TODO MGA: get full url of request
                            _this.$log.debug("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "]", httpPromise);
                            // return only the data expected for caller
                            return httpPromise.data;
                        };
                    };
                    /**
                     * Error handler
                     * TODO MGA: angular signatures indicates that parameter is rejection reason, not necessarily httpPromise: investigate & fix if necessary
                     * @param httpPromise
                     * @returns {}
                     */
                    this.onError = function (originalConfig) {
                        if (!originalConfig) {
                            _this.$log.warn('unable to retrieve originalConfig in onSuccess. Please provide complete config.');
                        }
                        return function (httpPromise) {
                            // We suppose in case of no response that the srv didn't send any response.
                            // TODO MGA: may also be a fault in internal $http / ajax client side lib, to distinguish.
                            if (!httpPromise || !httpPromise.data) {
                                httpPromise.data = 'Server not responding';
                                httpPromise.status = 503;
                            }
                            if (!originalConfig.disableToasterNotifications) {
                                var contentType = httpPromise.headers('Content-Type');
                                //check contentType to try to display error message
                                if (contentType && (contentType.indexOf('application/json') > -1 || contentType.indexOf('text/plain') > -1)) {
                                    var message = ''; //default message
                                    //TODO MGA: handle error handling more generically based on input error message contract instead of expecting specific error strcture.
                                    //if (response.data.ModelState) {
                                    //    //TODO MGA : handle this when well formatted server-side
                                    //} else
                                    if (angular.isString(httpPromise.data)) {
                                        message = httpPromise.data;
                                    }
                                    else if (httpPromise.data.Message && angular.isString(httpPromise.data.Message)) {
                                        message = httpPromise.data.Message;
                                    }
                                    if (httpPromise.status >= 400 && httpPromise.status < 500) {
                                        if (httpPromise.data &&
                                            httpPromise.data.ModelState &&
                                            httpPromise.data.ModelState.Validation &&
                                            httpPromise.data.ModelState.Validation.length > 0) {
                                            var messageContent = httpPromise.data.ModelState.Validation.join(', ');
                                            _this.toaster.warning(message || 'bad request', messageContent);
                                        }
                                        else if (httpPromise.status === 404) {
                                            _this.toaster.warning('not found', message);
                                        }
                                        else {
                                            _this.toaster.warning('bad request', message);
                                        }
                                    }
                                    else {
                                        _this.toaster.error('server response error', message + ". (status: " + httpPromise.status + ")");
                                    }
                                }
                                else {
                                    _this.toaster.error('internal server error', 'status: ' + httpPromise.status);
                                }
                            }
                            //TODO MGA: get full url of request
                            _this.$log.error("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "]", httpPromise);
                            // We don't recover from error, so we propagate it : below handlers have the choice of reading the error with an error handler or not. See $q promises behavior here : https://github.com/kriskowal/q
                            // This behavior is desired so that we show error inside specific server communication modals at specific places in the app, otherwise show a global alert message, or even do not show anything if not necessary (do not ad an error handler in below handlers of this promise).
                            return _this.$q.reject(httpPromise);
                        };
                    };
                    /**
                     * Function called at the end of an ajax call, regardless of it's success or failure.
                     * @param response
                     * TODO MGA inversion of responsability: make this extensible so that specifc apps can plug into this event workflow
                     */
                    this.finally = function () {
                        //TODO MGA: OE-specific code
                        if (_this.$window.block_UI !== undefined)
                            // TODO MGA : type casting, is it okay or not ? better approach ?
                            _this.$window.preventBlockUI = false;
                    };
                    var configurationEndpointUrl = this.buildUrlFromContext(configInitializationURL, EndpointTypeEnum.CurrentDomain);
                    if (!configurationEndpointUrl) {
                        this.$log.error("[BlueskyHttpWrapper][Initialization] - Unable to build url from initialConfig url '" + configInitializationURL + "' with endpointType '" + EndpointTypeEnum[EndpointTypeEnum.CurrentDomain] + "'. Aborting blueskyHttpService init.");
                        return;
                    }
                    //TODO MGA: custom config for headers hard coded, to mutualize with const
                    //TODO MGA: log properly as other ajax calls
                    this.getAjaxConfigFromServerPromise =
                        this.$http
                            .get(configurationEndpointUrl, { headers: { 'X-Requested-With': 'XMLHttpRequest' } })
                            .then(
                        // success
                        function (clientConfigPromise) {
                            //TODO MGA: reject status not in 2XX ?
                            if (!clientConfigPromise.data) {
                                var msg = "[BlueskyHttpWrapper][Initialization] - Unable to retrieve http config data from '" + configInitializationURL + "'. Aborting               blueskyHttpWrapperService initialization.";
                                _this.$log.error(msg);
                                //TODO MGA: toaster ?
                                // return this.$q.reject(msg);
                                throw new Error(msg);
                            }
                            _this.$log.info('[BlueskyHttpWrapper][Initialization] - Successfully loaded clientConfig from srv:', clientConfigPromise.data);
                            _this.blueskyAjaxClientConfig = clientConfigPromise.data;
                            return clientConfigPromise.data;
                        }, 
                        // error
                        function (error) {
                            var msg = '[BlueskyHttpWrapper][Initialization] - Unable to retrieve API config. Aborting blueskyHttpWrapperService initialization.';
                            _this.$log.error(msg + 'Original msg: ', error);
                            //TODO MGA: show toaster ? based on provider config flag ?
                            return _this.$q.reject(error);
                        })
                            .then(
                        //success, get userSSO from capi if needed
                        function (blueskyClientConfig) {
                            if (blueskyClientConfig.CurrentUserRole &&
                                selectedUserRole &&
                                (selectedUserRole.Name + ' ' + selectedUserRole.Role + ' ' + selectedUserRole.Silo) !== blueskyClientConfig.CurrentUserRole) {
                                throw new Error('[BlueskyHttpWrapper][Initialization] - client & srv-side selected user roles provided but they differ. internal error to fix.');
                            }
                            if (!blueskyClientConfig.CurrentUserRole) {
                                //If not provided by domain from which code was loaded, then try to fetch default userRole from CAPI endpoint
                                _this.$log.info('[BlueskyHttpWrapper][Initialization] - No default UserRole provided by current domain, trying to fetch it from CAPI.');
                                var coreApiConfig = blueskyClientConfig.EndpointConfigurationDictionnary[EndpointTypeEnum[EndpointTypeEnum.CoreApi]];
                                if (!coreApiConfig) {
                                    var msg = '[BlueskyHttpWrapper][Initialization] - Failed to retrieve necessary CoreApi endpoint config to fetch userSSO. Aborting.';
                                    _this.$log.error(msg);
                                    throw new Error(msg);
                                }
                                //TODO MGA: factorize with configureHttpCall() !! this is a special case where we cannot use ajax() DRY method ...
                                var customConfig = {
                                    headers: {
                                        'X-Requested-With': 'XMLHttpRequest',
                                        'Authorization': 'Bearer ' + coreApiConfig.AuthToken
                                    }
                                };
                                var getUserSsoFullUrl = _this.buildUrlFromContext('user-sso?profile=', EndpointTypeEnum.CoreApi);
                                if (!getUserSsoFullUrl) {
                                    var msg = '[BlueskyHttpWrapper][Initialization] - Failed to construct userSSO url for capi. Aborting.';
                                    _this.$log.error(msg);
                                    throw new Error(msg);
                                }
                                //TODO MGA: log properly as other ajax calls
                                return _this.$http.get(getUserSsoFullUrl, customConfig).then(
                                //success
                                function (userSsoPromise) {
                                    if (!userSsoPromise || !userSsoPromise.data || !userSsoPromise.data.UserRoleEntry) {
                                        var coreApiConfigMissingMsg = '[BlueskyHttpWrapper][Initialization] - Unable to retrieve CoreAPI default userSSO. Aborting httpWrapperService initialization.';
                                        _this.$log.error(coreApiConfigMissingMsg);
                                        throw new Error(coreApiConfigMissingMsg);
                                    }
                                    if (!userSsoPromise.data.UserDisplayName || !userSsoPromise.data.UserIdentifier) {
                                        var noUserIdMsg = '[BlueskyHttpWrapper][Initialization] - CoreAPI userSSO is not fully populated: unable to retrieve UserIdentifier or DisplayName. Aborting httpWrapperService initialization.';
                                        _this.$log.error(noUserIdMsg);
                                        throw new Error(noUserIdMsg);
                                    }
                                    var userSso = userSsoPromise.data;
                                    _this.$log.info("[BlueskyHttpWrapper][Initialization] - Default userSSO loaded from CAPI: '" + userSso.UserDisplayName + "'.", userSso);
                                    if (selectedUserRole)
                                        _this.$log.info("[BlueskyHttpWrapper][Initialization] - Client app provided persisted UserRole. Assigning it.", _this.selectedUserRole);
                                    //TODO MGA: make sure selectedUserRole is available in the list of userSSO roles, otherwise select default !
                                    //TODO MGA: how to inform back the DA that selectedUserRole was reset ? invert responsability & store userRole in localStorage from this service ?
                                    var userRoleToUse = selectedUserRole || userSso.UserRoleEntry;
                                    //TODO MGA: this needs to be put in shared extension method / service
                                    _this.blueskyAjaxClientConfig.CurrentUserRole = userRoleToUse.Name + " " + userRoleToUse.Role + " " + userRoleToUse.Silo;
                                    _this.blueskyAjaxClientConfig.CurrentUser = userSso;
                                    return blueskyClientConfig;
                                }, 
                                //error
                                function (error) {
                                    var msg = '[BlueskyHttpWrapper][Initialization] - Unable to retrieve user SSO from capi. Probably due to invalid certificates preventing us to communicate with CAPI. Aborting.';
                                    _this.$log.error(msg + ' Original msg:', error);
                                    //TODO MGA: show toaster ? based on provider config flag ?
                                    return _this.$q.reject(msg);
                                });
                            }
                            else {
                                //TODO MGA: we only load userSSO if no userRole was provided srv-side, should we load it in all cases ?
                                // already defined userRole sent from origin app, use it & set it as default.
                                return blueskyClientConfig;
                            }
                        });
                    //error
                    // (error: any): ng.IPromise<never> => {
                    //     //TODO MGA: should not be needed, fail case it consumer promises
                    // });
                }
                //#endregion
                //#region public methods
                BlueskyHttpWrapper.prototype.get = function (url, config) {
                    return this.ajax(HttpMethod.GET, url, config);
                };
                BlueskyHttpWrapper.prototype.delete = function (url, config) {
                    return this.ajax(HttpMethod.DELETE, url, config);
                };
                BlueskyHttpWrapper.prototype.post = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    ;
                    return this.ajax(HttpMethod.POST, url, config);
                };
                BlueskyHttpWrapper.prototype.put = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    return this.ajax(HttpMethod.PUT, url, config);
                };
                BlueskyHttpWrapper.prototype.patch = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    return this.ajax(HttpMethod.PATCH, url, config);
                };
                /**
                 * TODO MGA: not DRY with ajax method, how to keep it in sync ?
                 * @param url
                 * @param file
                 * @param config
                 */
                BlueskyHttpWrapper.prototype.upload = function (url, file, config) {
                    var _this = this;
                    if (!file && (!config || !config.file)) {
                        var msg = 'Cannot start upload with null {file} parameter.';
                        this.$log.error(msg);
                        return this.$q.reject(msg);
                    }
                    config = config || {};
                    config.file = file || config.file; //TODO MGA : do not expose file in IBlueskyHttpRequestConfig ?
                    config.data = config.data || {};
                    if (config.uploadInBase64Json) {
                        //TODO MGA: make sure this delays next call and upload is not done before base64 encoding is finished, even if promise is already resolved ???
                        return this.Upload.base64DataUrl(file).then(function (fileBase64Url) {
                            //TODO MGA: hard-coded key to fetch base64 encoding, to parametrize with server-side !
                            if (config && config.data)
                                config.data.fileBase64Url = fileBase64Url; //TODO MGA should not have to handle else
                            //normal post in case of base64-encoded data
                            return _this.ajax(HttpMethod.POST, url, config);
                        });
                    }
                    else {
                        config.data.fileFormDataName = 'file'; // file formData name ('Content-Disposition'), server side request form name
                        //TODO MGA : do not block if not call to internal API ? (initCall)
                        return this.getAjaxConfigFromServerPromise.then(function () {
                            var blueskyConfig = _this.setupBlueskyConfig(config);
                            var angularConfig = _this.extractAngularConfigFromBlueskyConfig(HttpMethod.POST, url, blueskyConfig);
                            if (!angularConfig || !blueskyConfig) {
                                return _this.$q.reject('[blueskyHttpWrapper-AjaxCall] unable to configure correctly angular config object necessary for ajax call. aborting.');
                            }
                            return _this.Upload.upload(angularConfig)
                                .then(_this.onSuccess(blueskyConfig), _this.onError(blueskyConfig), (config && config.uploadProgress) ? config.uploadProgress : undefined)
                                .finally(_this.finally);
                        });
                    }
                };
                /**
                 * This method is used to download a file in the form of a byte-stream from an endpoint and wrap it into a FileContent object with name, type & size properties read from the HTTP response headers of the serveur.
                 * It is the responsability of the consumer to do something with the wrapped byteArray (for example download the file, or show it inside the webPage etc).
                 * TODO MGA: not DRY with ajax method, how to keep it in sync ?
                 * @param url
                 * @param expectedName
                 * @param expectedSize
                 * @param expectedType
                 * @param config
                 */
                BlueskyHttpWrapper.prototype.getFile = function (url, config) {
                    var _this = this;
                    return this.getAjaxConfigFromServerPromise.then(function () {
                        var blueskyConfig = _this.setupBlueskyConfig(config);
                        var angularConfig = _this.extractAngularConfigFromBlueskyConfig(HttpMethod.GET, url, blueskyConfig);
                        if (!angularConfig || !blueskyConfig) {
                            return _this.$q.reject('[blueskyHttpWrapper-AjaxCall] unable to configure correctly angular config object necessary for ajax call. aborting.');
                        }
                        // specifically expect raw response type, otherwise byte stream responses are corrupted.
                        angularConfig.responseType = 'arraybuffer';
                        //Expected ArrayBuffer response = byte array
                        return _this.$http(angularConfig)
                            .then(function (httpResponse) {
                            // success
                            //benefit from successCallback validation before continuing
                            //TODO MGA understand why TS validation doesn't catch above if clause to validate blueskyConfig
                            if (!blueskyConfig)
                                return _this.$q.reject('[blueskyHttpWrapper-AjaxCall] unable to configure correctly angular config object necessary for ajax call. aborting.');
                            var arrayBuffer = _this.onSuccess(blueskyConfig)(httpResponse);
                            //TODO MGA: promise rejection vs. return null ?
                            if (!arrayBuffer)
                                throw new Error('[BlueskyHttpWrapper-getFile] - unable to retrieve byte array.'); //stop processing if unable to retrieve byte array
                            //read file info from response-headers
                            var fileContent = {
                                name: _this.getFileNameFromHeaderContentDisposition(httpResponse.headers('content-disposition')) || 'unknown',
                                size: Number(httpResponse.headers('content-length')) || 0,
                                type: httpResponse.headers('content-type') || 'application/octet-stream',
                                content: arrayBuffer
                            };
                            return fileContent;
                        }, 
                        // error
                        _this.onError(blueskyConfig))
                            .finally(_this.finally);
                    });
                };
                /**
                 * Tries to parse the input url :
                 * If it seems to be a full URL, then return as is (considers it external Url)
                 * Otherwise, tries to find the base URL of the current BlueSky app with or without the included Controller and returns the full Url
                 * @param urlInput : TODO MGA: document different kind of urls that this method can take as input (full, partial etc)
                 * @return null if not able to compute url. Otherwise, url of the request either partial or full based on endpointType.
                 */
                BlueskyHttpWrapper.prototype.buildUrlFromContext = function (urlInput, endpointType) {
                    if (!urlInput) {
                        this.$log.error('No URL input provided.');
                        return undefined;
                    }
                    // If Url starts with http:// or https:// => return as is, even if endpointType is not external.
                    if (urlInput.slice(0, 'http://'.length) === 'http://' ||
                        urlInput.slice(0, 'https://'.length) === 'https://') {
                        if (endpointType !== EndpointTypeEnum.External)
                            this.$log.warn('Full URL provided for a call that is not flagged as \'External\' endpointType, this is bad practice as only the blueskyWrapper should know about the baseURL of target endpoints (loaded from server, depending on the current env). Use partial URLs.');
                        return urlInput;
                    }
                    // Else, we have a partial URL to complete: use provided endpoint type to determine how to complete url.
                    // Default value for endpointType if not provided is origin. TODO MGA: rule to discuss, here for retro-compatibility.
                    endpointType = endpointType || EndpointTypeEnum.CurrentDomain;
                    var baseUrl;
                    if (endpointType === EndpointTypeEnum.External) {
                        this.$log.warn('Partial url provided for a call with endpointType flagged as \'External\': the call will probably fail.');
                        // do not modify provided url if external (we cannot know how to complete it, even if partial).
                        return urlInput;
                    }
                    else if (endpointType === EndpointTypeEnum.CurrentDomain) {
                        //TODO MGA: not loading the endpointConfig for current domain means we can't access endpointAPIsuffix if it exists, should we load the endpointConfig for this case too ?? & handle it the same way as other endpoints ?
                        // Regex trying to determine if the input fragment contains a / between two character suites => controller given as input, otherwise, action on same controller expected
                        var controllerIsPresentRegex = /\w+\/\w+/;
                        var actionIsOnSameController = !controllerIsPresentRegex.test(urlInput);
                        baseUrl = this.getUrlPath(actionIsOnSameController);
                    }
                    else {
                        // For all other endpointTypes: compute URL as a combination of baseURL & suffix if present, as provided by server-configuration.
                        if (!this.blueskyAjaxClientConfig ||
                            !this.blueskyAjaxClientConfig.EndpointConfigurationDictionnary) {
                            this.$log.error('Expected endpointConfigurationDictionnary provided but none found. Aborting.');
                            return undefined;
                        }
                        // TODO MGA HACKY: search by string representation of endpoint type in dict due to serialization limits
                        var endpointConfig = this.blueskyAjaxClientConfig.EndpointConfigurationDictionnary[EndpointTypeEnum[endpointType]];
                        if (!endpointConfig) {
                            this.$log.error("EndpointType '" + EndpointTypeEnum[endpointType] + "' is not 'External' or 'CurrentDomain', expected corresponding endpointConfiguration provided in blueskyAjaxClientConfig.endpointConfigurationDictionnary but none found. Aborting.");
                            return undefined;
                        }
                        baseUrl = endpointConfig.EndpointBaseURL + (endpointConfig.EndpointSuffix || '');
                    }
                    //TODO MGA: how to handle OM apps external calls without session provided ? will result in a redirect and call may fail ?
                    // Boolean used to try to determine correct full url (add / or not before the url fragment depending on if found or not)
                    var urlFragmentStartsWithSlash = urlInput.slice(0, 1) === '/';
                    var baseUrlFragmentEndsWithSlash = baseUrl.slice(baseUrl.length - 1, baseUrl.length) === '/';
                    //based on starting/trailing slashes, return full url.
                    if (baseUrlFragmentEndsWithSlash && urlFragmentStartsWithSlash)
                        // remove last '/' on baseUrl
                        return baseUrl.slice(0, baseUrl.length - 1) + urlInput;
                    else if (!baseUrlFragmentEndsWithSlash && !urlFragmentStartsWithSlash)
                        return baseUrl + '/' + urlInput;
                    else if ((baseUrlFragmentEndsWithSlash && !urlFragmentStartsWithSlash) ||
                        (!baseUrlFragmentEndsWithSlash && urlFragmentStartsWithSlash))
                        return baseUrl + urlInput;
                    return undefined;
                };
                //#endregion
                //#region private methods
                /**
                 * Utility method.
                 * Main caller that all wrapper calls (get, delete, post, put) must use to share common behavior.
                 * @param config
                 */
                BlueskyHttpWrapper.prototype.ajax = function (method, url, config) {
                    var _this = this;
                    //TODO MGA : make sure getConfig resolve automatically without overhead once first call sucessfull.
                    //TODO MGA : do not block if not call to internal API (initCall)
                    return this.getAjaxConfigFromServerPromise.then(function () {
                        var blueskyConfig = _this.setupBlueskyConfig(config);
                        var angularConfig = _this.extractAngularConfigFromBlueskyConfig(method, url, blueskyConfig);
                        if (!angularConfig || !blueskyConfig) {
                            return _this.$q.reject('[blueskyHttpWrapper-AjaxCall] unable to configure correctly angular config object necessary for ajax call. aborting.');
                        }
                        return _this.$http(angularConfig)
                            .then(_this.onSuccess(blueskyConfig), _this.onError(blueskyConfig))
                            .finally(_this.finally);
                    });
                };
                // TODO MGA : using method from Layout.js : to document to not handle duplicate code !!
                //TODO MGA: unrobust, needs solid refacto to make it more generic when on origin domain !
                BlueskyHttpWrapper.prototype.getUrlPath = function (actionIsOnSameController) {
                    var baseUrlOmAppsRegex = /(\/\w+\/\(S\(\w+\)\))\/\w+/;
                    var baseUrlAspAppsRegex = /(\/\w+)\/\w+/;
                    var url = this.$window.location.pathname;
                    var baseUrlOmAppsMatches = baseUrlOmAppsRegex.exec(url);
                    var baseUrlAspAppsMatches = baseUrlAspAppsRegex.exec(url);
                    var baseUrlWithControllerName = undefined;
                    var baseUrl = undefined;
                    // 2 matches = regex matches + the capturing group
                    if (baseUrlOmAppsMatches && baseUrlOmAppsMatches.length && baseUrlOmAppsMatches.length === 2) {
                        baseUrlWithControllerName = baseUrlOmAppsMatches[0];
                        baseUrl = baseUrlOmAppsMatches[1];
                    }
                    else if (baseUrlAspAppsMatches && baseUrlAspAppsMatches.length && baseUrlAspAppsMatches.length === 2) {
                        baseUrlWithControllerName = baseUrlAspAppsMatches[0];
                        baseUrl = baseUrlAspAppsMatches[1];
                    }
                    if (actionIsOnSameController && baseUrlWithControllerName) {
                        return baseUrlWithControllerName;
                    }
                    else if (baseUrl) {
                        return baseUrl;
                    }
                    return '';
                };
                //TODO MGA: OM-specific ASP MVC code, not used ATM, to remove
                // private getCurrentSessionID(): string {
                //     //TODO MGA : magic regexp to fetch SessionID in URL, to store elsewhere !
                //     var sessionRegex = /https:\/\/[\w.]+\/[\w.]+\/(\(S\(\w+\)\))\/.*/;
                //     //var sessionRegex = /https:\/\/[\w.]+\/OrderEntry\/(\(S\(\w+\)\))\/.*/;
                //     // TODO MGA : update regexp to the one below
                //     //var baseUrlRegex = /(https:\/\/[\w.-]+\/[\w.-]+\/\(S\(\w+\)\)\/)\w+/;
                //     var path = this.$location.absUrl();
                //     var regexpArray = sessionRegex.exec(path);
                //     if (!regexpArray) {
                //         this.$log.error('Unable to recognized searched pattern in current url location to retrieve sessionID.');
                //         return '';
                //     }
                //     if (regexpArray.length === 1) {
                //         this.$log.error('Unable to find sessionID in searched pattern in current url.');
                //         return '';
                //     }
                //     if (regexpArray.length > 2) {
                //         this.$log.error('Too many matches found for the sessionID search in the current url.');
                //         return '';
                //     }
                //     return regexpArray[1];
                // }
                /**
                 * Trim the content-disposition header to return only the filename.
                 * @param contentDispositionHeader
                 */
                BlueskyHttpWrapper.prototype.getFileNameFromHeaderContentDisposition = function (contentDispositionHeader) {
                    if (!contentDispositionHeader)
                        return undefined;
                    var result = contentDispositionHeader.split(';')[1].trim().split('=')[1];
                    return result.replace(/"/g, '');
                };
                return BlueskyHttpWrapper;
            }());
            service.BlueskyHttpWrapper = BlueskyHttpWrapper;
        })(service = core.service || (core.service = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1vZGVscy9ibHVlc2t5LWh0dHAtcmVxdWVzdC1jb25maWcubW9kZWwuanMiLCJtb2RlbHMvZmlsZS1jb250ZW50Lm1vZGVsLmpzIiwiYmx1ZXNreS1odHRwLXdyYXBwZXIuanMiLCJibHVlc2t5LWh0dHAtd3JhcHBlci5wcm92aWRlci50cyIsImJsdWVza3ktaHR0cC13cmFwcGVyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7O0FDSUE7QUNKQSxJQUFVO0FBQVYsQ0FBQSxVQUFVLFNBQU87SUFBQyxJQUFBO0lBQUEsQ0FBQSxVQUFBLE1BQUk7UUFBQyxJQUFBO1FBQUEsQ0FBQSxVQUFBLFNBQU87Ozs7Ozs7WUFTMUIsSUFBQSw0Q0FBQSxZQUFBO2dCQUFBLFNBQUEsNkJBQUE7O29CQUFBLElBQUEsUUFBQTtvQkFJWSxLQUFBLG1DQUEyQzs7OztvQkFtQjVDLEtBQUEsK0RBQU8sVUFDVixPQUNBLFNBQ0EsTUFDQSxJQUNBLFFBQ0EsU0FBZ0M7d0JBRWhDLE9BQU8sSUFBSSxRQUFBLG1CQUFtQixPQUFPLFNBQVMsTUFBTSxJQUFJLFFBQVEsU0FBUyxNQUFLLGtCQUFrQixNQUFLOzs7Ozs7Z0JBcEJsRywyQkFBQSxVQUFBLHFCQUFQLFVBQTBCLHNCQUF3QztvQkFDOUQsS0FBSyxtQ0FBbUMsd0JBQXdCLEtBQUs7O2dCQUdsRSwyQkFBQSxVQUFBLG1CQUFQLFVBQXdCLFVBQXNDO29CQUMxRCxLQUFLLG1CQUFtQixZQUFZOztnQkFpQjVDLE9BQUE7O1lBakNhLFFBQUEsNkJBQTBCO1lBbUN2QyxRQUFRLE9BQU8sdUJBQXVCLENBQUMsV0FBVyxhQUFhO2lCQUMxRCxTQUE2QixLQUFLLE9BQU87aUJBQ3pDLFNBQThCLFVBQVUsT0FBTztpQkFDL0MsU0FBUyxzQkFBc0I7V0EvQ2pCLFVBQUEsS0FBQSxZQUFBLEtBQUEsVUFBTztPQUFaLE9BQUEsUUFBQSxTQUFBLFFBQUEsT0FBSTtHQUFaLFlBQUEsVUFBTzs7QURnRGpCO0FF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LDRCQUE0QixzQkFBc0I7d0JBQ2xELFVBQVUsc0JBQXNCOztvQkFHcEMsSUFBSSw0QkFBNEIsMkJBQTJCO3dCQUN2RCxPQUFPOzt5QkFDSixJQUFJLFNBQVM7d0JBQ2hCLE9BQU87O29CQUdYLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQXNDSCxtQkFBQSxVQUFBLDBDQUFSLFVBQWdELDBCQUFnQztvQkFDNUUsSUFBSSxDQUFDO3dCQUEwQixPQUFPO29CQUV0QyxJQUFJLFNBQVMseUJBQXlCLE1BQU0sS0FBSyxHQUFHLE9BQU8sTUFBTSxLQUFLO29CQUV0RSxPQUFPLE9BQU8sUUFBUSxNQUFNOztnQkFJcEMsT0FBQTs7WUFwd0JhLFFBQUEscUJBQWtCO1dBN0NaLFVBQUEsS0FBQSxZQUFBLEtBQUEsVUFBTztPQUFaLE9BQUEsUUFBQSxTQUFBLFFBQUEsT0FBSTtHQUFaLFlBQUEsVUFBTztBRitxQmpCIiwiZmlsZSI6ImJsdWVza3ktaHR0cC13cmFwcGVyLmpzIiwic291cmNlc0NvbnRlbnQiOltudWxsLG51bGwsIlwidXNlIHN0cmljdFwiO1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYmx1ZXNreTtcbihmdW5jdGlvbiAoYmx1ZXNreSkge1xuICAgIHZhciBjb3JlO1xuICAgIChmdW5jdGlvbiAoY29yZSkge1xuICAgICAgICB2YXIgc2VydmljZTtcbiAgICAgICAgKGZ1bmN0aW9uIChzZXJ2aWNlKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb3ZpZGVyIGZvciB0aGUgQmx1ZXNreUh0dHBXcmFwcGVyLlxuICAgICAgICAgICAgICogRW5hYmxlcyBwZXItY29uc3VtZXIgY29uZmlndXJhdGlvbiBvZiB0aGUgaHR0cCBzZXJ2aWNlIHRvIHNldCBjdXN0b20gY29uZmlndXJhdGlvbiBVUkwgdG8gZmV0Y2ggZGF0YSBmcm9tOlxuICAgICAgICAgICAgICogIC0gQ2xpZW50IGluaXRpYWwgY29uZmlndXJhdGlvbiBVUkwgZnJvbSB0aGUgb3JpZ2luIHRoZSBhcHAgd2FzIGxvYWRlZCBmcm9tLlxuICAgICAgICAgICAgICogIC0gVXNlclJvbGUgdG8gdXNlIG9mIGFscmVhZHkgZmV0Y2hlZCBmcm9tIGFub3RoZXIgcGxhY2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8jcmVnaW9uIHByaXZhdGUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENsaWVudENvbmZpZ0luaXRpYWxpemF0aW9uVXJsID0gJ0JsdWVza3lBamF4Q2xpZW50Q29uZmlndXJhdGlvbi9HZXRBamF4Q2xpZW50Q29uZmlndXJhdGlvbic7IC8vIGJ5IGRlZmF1bHQuXG4gICAgICAgICAgICAgICAgICAgIC8vI2VuZHJlZ2lvblxuICAgICAgICAgICAgICAgICAgICAvLyBQcm92aWRlcidzIGZhY3RvcnkgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLyogQG5nSW5qZWN0ICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGdldCA9IGZ1bmN0aW9uICgkaHR0cCwgJHdpbmRvdywgJGxvZywgJHEsIFVwbG9hZCwgdG9hc3Rlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzZXJ2aWNlLkJsdWVza3lIdHRwV3JhcHBlcigkaHR0cCwgJHdpbmRvdywgJGxvZywgJHEsIFVwbG9hZCwgdG9hc3RlciwgX3RoaXMuc2VsZWN0ZWRVc2VyUm9sZSwgX3RoaXMuZ2V0Q2xpZW50Q29uZmlnSW5pdGlhbGl6YXRpb25VcmwpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyNlbmRyZWdpb25cbiAgICAgICAgICAgICAgICAvLyNyZWdpb24gcHVibGljIGNvbmZpZ3VyYXRpb24gbWV0aG9kc1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlclByb3ZpZGVyLnByb3RvdHlwZS5zZXRDbGllbnRDb25maWdVUkwgPSBmdW5jdGlvbiAoY2xpZW50Q29uZmlnVXJsVG9Vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDbGllbnRDb25maWdJbml0aWFsaXphdGlvblVybCA9IGNsaWVudENvbmZpZ1VybFRvVXNlIHx8IHRoaXMuZ2V0Q2xpZW50Q29uZmlnSW5pdGlhbGl6YXRpb25Vcmw7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlci5wcm90b3R5cGUuc2V0VXNlclJvbGVUb1VzZSA9IGZ1bmN0aW9uICh1c2VyUm9sZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVXNlclJvbGUgPSB1c2VyUm9sZSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmx1ZXNreUh0dHBXcmFwcGVyUHJvdmlkZXI7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgc2VydmljZS5CbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlciA9IEJsdWVza3lIdHRwV3JhcHBlclByb3ZpZGVyO1xuICAgICAgICAgICAgYW5ndWxhci5tb2R1bGUoJ2JsdWVza3kuaHR0cFdyYXBwZXInLCBbJ3RvYXN0ZXInLCAnbmdBbmltYXRlJywgJ25nRmlsZVVwbG9hZCddKVxuICAgICAgICAgICAgICAgIC5jb25zdGFudCgnXycsIHdpbmRvdy5fKVxuICAgICAgICAgICAgICAgIC5jb25zdGFudCgnbW9tZW50Jywgd2luZG93Lm1vbWVudClcbiAgICAgICAgICAgICAgICAucHJvdmlkZXIoJ2JsdWVza3lIdHRwV3JhcHBlcicsIEJsdWVza3lIdHRwV3JhcHBlclByb3ZpZGVyKTtcbiAgICAgICAgfSkoc2VydmljZSA9IGNvcmUuc2VydmljZSB8fCAoY29yZS5zZXJ2aWNlID0ge30pKTtcbiAgICB9KShjb3JlID0gYmx1ZXNreS5jb3JlIHx8IChibHVlc2t5LmNvcmUgPSB7fSkpO1xufSkoYmx1ZXNreSB8fCAoYmx1ZXNreSA9IHt9KSk7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIGJsdWVza3k7XG4oZnVuY3Rpb24gKGJsdWVza3kpIHtcbiAgICB2YXIgY29yZTtcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcbiAgICAgICAgdmFyIHNlcnZpY2U7XG4gICAgICAgIChmdW5jdGlvbiAoc2VydmljZSkge1xuICAgICAgICAgICAgdmFyIEVuZHBvaW50VHlwZUVudW0gPSBibHVlc2t5LmNvcmUubW9kZWwuY2xpZW50Q29uZmlnLkVuZHBvaW50VHlwZUVudW07XG4gICAgICAgICAgICAvLyBpbXBvcnQgQWpheENsaWVudEVuZHBvaW50Q29uZmlndXJhdGlvbkR0byA9IGJsdWVza3kuY29yZS5tb2RlbC5jbGllbnRDb25maWcuSUFqYXhDbGllbnRFbmRwb2ludENvbmZpZ3VyYXRpb25EdG87XG4gICAgICAgICAgICB2YXIgSHR0cE1ldGhvZDtcbiAgICAgICAgICAgIChmdW5jdGlvbiAoSHR0cE1ldGhvZCkge1xuICAgICAgICAgICAgICAgIEh0dHBNZXRob2RbSHR0cE1ldGhvZFtcIkdFVFwiXSA9IDBdID0gXCJHRVRcIjtcbiAgICAgICAgICAgICAgICBIdHRwTWV0aG9kW0h0dHBNZXRob2RbXCJQT1NUXCJdID0gMV0gPSBcIlBPU1RcIjtcbiAgICAgICAgICAgICAgICBIdHRwTWV0aG9kW0h0dHBNZXRob2RbXCJQVVRcIl0gPSAyXSA9IFwiUFVUXCI7XG4gICAgICAgICAgICAgICAgSHR0cE1ldGhvZFtIdHRwTWV0aG9kW1wiUEFUQ0hcIl0gPSAzXSA9IFwiUEFUQ0hcIjtcbiAgICAgICAgICAgICAgICBIdHRwTWV0aG9kW0h0dHBNZXRob2RbXCJERUxFVEVcIl0gPSA0XSA9IFwiREVMRVRFXCI7XG4gICAgICAgICAgICB9KShIdHRwTWV0aG9kID0gc2VydmljZS5IdHRwTWV0aG9kIHx8IChzZXJ2aWNlLkh0dHBNZXRob2QgPSB7fSkpO1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdmFyIEJsdWVza3lIdHRwV3JhcHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyNlbmRyZWdpb25cbiAgICAgICAgICAgICAgICAvLyNyZWdpb24gY3RvclxuICAgICAgICAgICAgICAgIC8qIEBuZ0luamVjdCAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEJsdWVza3lIdHRwV3JhcHBlcigkaHR0cCwgJHdpbmRvdywgJGxvZywgJHEsIFVwbG9hZCwgdG9hc3Rlciwgc2VsZWN0ZWRVc2VyUm9sZSwgY29uZmlnSW5pdGlhbGl6YXRpb25VUkwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMSAtIGZldGNoIHRoZSBjb25maWd1cmF0aW9uIGRhdGEgbmVjZXNzYXJ5IGZvciB0aGlzIHNlcnZpY2UgdG8gcnVuIGZyb20gdGhlIHByb3ZpZGVkIGVuZHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGh0dHAgPSAkaHR0cDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kd2luZG93ID0gJHdpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nID0gJGxvZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcSA9ICRxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLlVwbG9hZCA9IFVwbG9hZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2FzdGVyID0gdG9hc3RlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFVzZXJSb2xlID0gc2VsZWN0ZWRVc2VyUm9sZTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFByZXBhcmVzIGJsdWVza3ktc3BlY2lmaWMgY29uZmlndXJhdGlvbiBiYXNlZCBvbiBwcm92aWRlZCBpbnB1dHMuXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBvcGVyYXRpb25zIGluY2x1ZGUgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyB3aGVuIG5vdCBwcm92aWRlZCwgYW5kIHNldHRpbmcgaHR0cCBoZWFkZXJzIGlmIG5lZWRlZCBmb3IgOlxuICAgICAgICAgICAgICAgICAgICAgKiAgLSBBamF4IGNhbGxzXG4gICAgICAgICAgICAgICAgICAgICAqICAtIEF1dGhvcml6YXRpb24gdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICogIC0gQ3VycmVudCBVc2VyUm9sZS5cbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIGNvbmZpZyB1c2VyIGlucHV0IGNvbmZpZyBpZiBwcm92aWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdpdGggYXV0b21hdGljIHJ1bGVzIGFwcGxpZWQuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHVwQmx1ZXNreUNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IGNvbmZpZyB2YWx1ZXMgYW5kIGN1c3RvbSBvbmVzIGJhc2VkIG9uIGVuZHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmVuZHBvaW50VHlwZSA9IGNvbmZpZy5lbmRwb2ludFR5cGUgfHwgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluOyAvLyBkZWZhdWx0IHZhbHVlOiBpZiBub3Qgc3BlY2lmaWVkLCBlbmRwb2ludCB0byB1c2UgaXMgc3VwcG9zZWQgdG8gYmUgdGhlIG9yaWdpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBieSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZW5kcG9pbnQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBNR0E6IG1ha2Ugc3VyZSBFbmRwb2ludFR5cGVFbnVtW2ludmFsaWQgdmFsdWVdIGRvZXNuJ3QgcmV0dXJuIGRlZmF1bHQgdmFsaWQgZW51bSB2YWx1ZSA/Pz8gb3RoZXJ3aXNlLCBkYW5nZXJvdXMgIVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRFbmRwb2ludENvbmZpZyA9IF90aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnICYmIF90aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLkVuZHBvaW50Q29uZmlndXJhdGlvbkRpY3Rpb25uYXJ5W0VuZHBvaW50VHlwZUVudW1bY29uZmlnLmVuZHBvaW50VHlwZV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbmZpZ3VyZSBkZWZhdWx0IGNvbmZpZyBmbGFncyBiYXNlZCBvbiB0YXJnZXQgZW5kcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29uZmlnLmVuZHBvaW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5Db3JlQXBpOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5NYXJrZXRpbmdBcGk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLlNlbGZjYXJlQXBpOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5NZXRyYU5ldEFwaTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uUmVzb3VyY2VBcGk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLk1vbml0b3JpbmdBcGk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlamVjdCBleHBsaWNpdGx5IHdyb25nIGlucHV0IGNvbmZpZ3VyYXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLndhcm4oXCJbQmx1ZXNreUh0dHBXcmFwcGVyXVtzZXR1cEJsdWVza3lDb25maWddIC0gQVBJIGNhbGwgaW50ZW5kZWQgd2l0aCBpbmNvbXBhdGlibGUgY29uZmlndXJhdGlvbiBvcHRpb25zLiBBYm9ydGluZyBhamF4IGNhbGwuXCIsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbmZpZyB2YWx1ZXMgZm9yIEFQSSBlbmRwb2ludHMgYXJlIGRpZmZlcmVudCBmcm9tIGRlZmF1bHQsIHNvIHdlIG11c3Qgc3BlY2lmeSB0aGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyID0gZmFsc2U7IC8vIGJ5IGRlZmF1bHQgYWxyZWFkeSBlbmFibGVkLCBidXQgZW5mb3JlIHRoaXMgaGVhZGVyIGFzIG5lY2Vzc2FyeSBmb3IgY2FsbHMgdG8gV2ViQVBJIGVuZHBvaW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnVzZUN1cnJlbnRVc2VyUm9sZSA9IHRydWU7IC8vIGZvciBhcGkgY2FsbHMsIGZvcmNlIHRoaXMgcm9sZSB0byBiZSBwYXNzZWQgYXJvdW5kIChzaG91bGQgYmUgbWFuZGF0b3J5IHRvIGNvbnRleHR1YWxpemUgcmVxdWVzdCB0byByZWFsbSBvZiBjdXJyZW50IHVzZXIpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uUXVvdGVXaXphcmQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLk9yZGVyRW50cnk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLk9yZGVyVHJhY2tpbmc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBPTSBhcHBzIGNhbGxlZCBhcyBlbmRwb2ludHMsIG1ha2Ugc3VyZSB0aGUgWG1sSHR0cFJlcXVlc3QgaGVhZGVyIGlzIHByZXNlbnQgKEFTUC5ORVQgYXBwcykuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogYWRkIGN1cnJlbnRVc2VyUm9sZSBieSBkZWZhdWx0IHNvIHRoYXQgT00gYXBwcyBjYW4gY29udGV4dHVhbGlzZSB0aGUgcmVxdWVzdCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5NZXRyYW5ldDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uVGVjaG5pY2FsSW52ZW50b3J5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5UZW1wbGF0ZUdlbmVyYXRvcjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uU2FsZXNmb3JjZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogbm8gc3BlY2lmaWMgY29uZmlnIGZvciB0aG9zZSBleHRlcm5hbCBlbmRwb2ludHMgPyBhZGQgY3VzdG9tIG9uZXMgaWYgbmVlZGVkIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgYWpheCBjYWxscywgbWFrZSBzdXJlIHRoZSBYbWxIdHRwUmVxdWVzdCBoZWFkZXIgaXMgcHJlc2VudCAoQVNQLk5FVCBhcHBzKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VyIHJvbGUgaXMgdXNlZnVsbCBldmVuIGZvciBjdXJyZW50IGRvbWFpbiBzbyB0aGF0IHNydiBjYW4ga25vdyB0aGUgY29udGV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnVzZUN1cnJlbnRVc2VyUm9sZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5FeHRlcm5hbDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSB0byBjb25maXJtOiB3ZSBtYXkgd2FudCB0byBjYWxsIGV4dGVybmFsIHVybHMgdmlhIGFqYXgsIHNvIGhvdyB0byBiZSBzdXJlIG9mIGRlZmF1bHQgdmFsdWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyID0gdHJ1ZTsgLy8gZG8gbm90IGFkZCBYbWxIdHRwUmVxdWVzdCBpZiBleHRlcm5hbCBVcmwgYnkgZGVmYXVsdDogbWlnaHQgY3JlYXRlIGNvbmZsaWN0cyBvbiBjZXJ0YWluIHNlcnZlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRoaXMgaGVhZGVyIG91dHNpZGUgb2YgQVNQIHdvcmxkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKFwiW0JsdWVza3lIdHRwV3JhcHBlcl1bc2V0dXBCbHVlc2t5Q29uZmlnXSAtIFVuc3VwcG9ydGVkIGVuZHBvaW50VHlwZSBwcm92aWRlZDogJ1wiICsgRW5kcG9pbnRUeXBlRW51bVtjb25maWcuZW5kcG9pbnRUeXBlIHx8IEVuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbl0gKyBcIicuIEFib3J0aW5nLlwiLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogc2hvdWxkIHdlIGF1dGhvcml6ZSBubyB2YWxpZCBlbmRwb2ludCBjb25maWd1cmF0aW9uIGxvYWRlZCBmb3IgY3VycmVudCBkb21haW4gPyBBdXRoVG9rZW4gc3RpbGwgdXNlZnVsbCBvciBub3QgPyBCYXNlVVJMIHN0aWxsIHVzZWZ1bGwgb3Igbm90ID8gYXBpIHN1ZmZpeCA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4dGVybmFsIFVSTHMsIG9idmlvdXNseSBlbmRwb2ludCBjb25maWcgaXMgbm90IG1hbmRhdG9yeSwgYnV0IGl0IGNvdWxkIGJlIHByb3ZpZGVkIGlmIG5lZWRlZDogaG93IHRvIGhhbmRsZSB0aGlzIGNhc2U/XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1JlamVjdCBhamF4IGNhbGxzIGludGVuZGVkIHRvIGV4dGVybmFsIGVuZHBvaW50cyB3aXRob3V0IG5lY2Vzc2FyeSBjb25maWd1cmF0aW9uIGxvYWRlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmVuZHBvaW50VHlwZSAhPT0gRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmVuZHBvaW50VHlwZSAhPT0gRW5kcG9pbnRUeXBlRW51bS5FeHRlcm5hbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFjdXJyZW50RW5kcG9pbnRDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKFwiW0JsdWVza3lIdHRwV3JhcHBlcl1bc2V0dXBCbHVlc2t5Q29uZmlnXSAtIEFqYXggY2FsbCBpbnRlbmRlZCB3aXRob3V0IGV4cGVjdGVkIGVuZHBvaW50IGNvbmZpZ3VyYXRpb24gbG9hZGVkIGZyb20gdGhlIHNlcnZlciBmb3IgZW5kcG9pbnRUeXBlICdcIiArIEVuZHBvaW50VHlwZUVudW1bY29uZmlnLmVuZHBvaW50VHlwZV0gKyBcIicuIEFib3J0aW5nLlwiLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBzZXQgZGVmYXVsdCB2YWx1ZXMgYWZ0ZXIgZW5kcG9pbnQtc3BlY2lmaWMgY29uZmlndXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgPSBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyIHx8IGZhbHNlOyAvLyBkZWZhdWx0IHZhbHVlIGlzIGVuYWJsZWQgKGFqYXggY2FsbHMgb24gLk5FVCBlbmRwb2ludHMpLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnVzZUN1cnJlbnRVc2VyUm9sZSA9IGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUgfHwgZmFsc2U7IC8vIGRlZmF1bHQgdmFsdWU6IGRvbid0IHRyYW5zbWl0IHNlbnNpdGl2ZSBpbmZvcm1hdGlvbiB0byByZW1vdGUgaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucyA9IGNvbmZpZy5kaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMgfHwgZmFsc2U7IC8vc2V0IGRlZmF1bHQgdmFsdWUgZm9yIGRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucyB0byBmYWxzZSBhcyBpdCdzIHBhcnQgb2YgdGhlIG5vcm1hbCBiZWhhdmlvciBleHBlY3RlZCBmb3IgdGhpcyBzZXJ2aWNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY29kZWQgaGVhZGVyIHRvIHB1dCBpbiBDT05TVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5oZWFkZXJzWydYLVJlcXVlc3RlZC1XaXRoJ10gPSAnWE1MSHR0cFJlcXVlc3QnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWplY3QgY2FsbCB3aGVuIG1pc3NpbmcgbWFuZGF0b3J5IGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5DdXJyZW50VXNlclJvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihcIltCbHVlc2t5SHR0cFdyYXBwZXJdW3NldHVwQmx1ZXNreUNvbmZpZ10gLSBBamF4IGNhbGwgaW50ZW5kZWQgd2l0aG91dCBuZWNlc3NhcnkgdXNlclJvbGUgc2V0IGluIGNvbmZpZy4gQWJvcnRpbmcuXCIsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY29kZWQgaGVhZGVyIHRvIHB1dCBpbiBDT05TVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5oZWFkZXJzWydPQS1Vc2VyUm9sZSddID0gX3RoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuQ3VycmVudFVzZXJSb2xlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYXV0aCB0b2tlbiBwcm92aWRlZCBmb3IgdGFyZ2V0IGVuZHBvaW50LCBhZGQgaXQgaW4gaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm90ZWN0IGFnYWluc3QgY2FzZXMgd2hlcmUgZW5kcG9pbnRUeXBlIGlzIGN1cnJlbnQgZG9tYWluIG9yIGV4dGVybmFsOiBlbmRwb2ludENvbmZpZyBudWxsL3VuZGVmaW5lZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RW5kcG9pbnRDb25maWcgJiYgY3VycmVudEVuZHBvaW50Q29uZmlnLkF1dGhUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHJlamVjdCBhdXRoVG9rZW4gZm9yIGVuZHBvaW50cyB0aGF0IGFyZSBub3QgJ3NhZmUnIHRvIHNoYXJlIGF1dGggdG9rZW4gd2l0aCwgc3VjaCBhcyBFeHRlcm5hbCBvbmVzID8gT3IgYXV0aG9yaXplIHRoaXMgc28gdGhhdCBzZXJ2ZXIgY2FuIGxvYWQgYW4gYXV0aCB0b2tlbiBmb3IgY2VydGFpbiBleHRlcm5hbCBlbmRwb2ludHMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSB0b2tlbiB2YWxpZGl0eSBlbmREYXRlOiByZW5ldyBhdXRoIGJlZm9yZSB0aGUgY2FsbCAhIFdoYXQncyB0aGUgYmVzdCBtb21lbnQgdG8gZG8gaXQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY29kZWQgaGVhZGVyIHRvIHB1dCBpbiBDT05TVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSAnQmVhcmVyICcgKyBjdXJyZW50RW5kcG9pbnRDb25maWcuQXV0aFRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogT0Ugc3BlY2lmaWMgY29kZSwgdG8gcmVtb3ZlLCBvciBhdCBsZWFzdCBwdXQgaW4gYXMgY29uZmlnIHBhcmFtXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuJHdpbmRvdy5ibG9ja19VSSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdHlwZSBjYXN0aW5nLCBpcyBpdCBva2F5IG9yIG5vdCA/IGJldHRlciBhcHByb2FjaCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJHdpbmRvdy5wcmV2ZW50QmxvY2tVSSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4dHJhY3RBbmd1bGFyQ29uZmlnRnJvbUJsdWVza3lDb25maWcgPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwsIGJsdWVza3lDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlucHV0IHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXJsIHx8IG1ldGhvZCA9PT0gbnVsbCB8fCBtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoJ1VSTCAmIE1FVEhPRCBwYXJhbWV0ZXJzIGFyZSBuZWNlc3NhcnkgdG8gY29uZmlndXJlIGh0dHBXcmFwcGVyIGNhbGxzLiBBYm9ydGluZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFibHVlc2t5Q29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcignYmx1ZXNreSBjb25maWcgbWlzc2luZy4gQWJvcnRpbmcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY2FzdCBpcyBub3Qgc2FmZSwgd2UgbWF5IGZvcmdldCB0byBzZXQgdXJsICYgbWV0aG9kIHBhcmFtZXRlcnMuIFRPRklYLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBnZXQgYWxsIG5vbi1maWx0ZXJlZCBwYXJhbWV0ZXJzICYga2VlcCB0aGVtIGZvciB0aGlzIG5ldyBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5ndWxhckNvbmZpZyA9IGJsdWVza3lDb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBzdXBwb3J0IG1hcHBpbmcgYmV0d2VlbiB1cGxvYWQgJiBwb3N0IGhlcmUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhckNvbmZpZy5tZXRob2QgPSBIdHRwTWV0aG9kW21ldGhvZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gYnVpbGQgYSB2YWxpZCB1cmwgZnJvbSBpbnB1dCAmIGVuZHBvaW50VHlwZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaW5hbFVybFRvRmV0Y2ggPSBfdGhpcy5idWlsZFVybEZyb21Db250ZXh0KHVybCwgYmx1ZXNreUNvbmZpZy5lbmRwb2ludFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaW5hbFVybFRvRmV0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKCdbQmx1ZXNreUh0dHBXcmFwcGVyIC0gYWpheCBjYWxsIGJ1aWxkZXJdIC0gdW5hYmxlIHRvIGNvbnN0cnVjdCB2YWxpZCB1cmwgdG8gY2FsbC4gYWJvcnRpbmcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXJDb25maWcudXJsID0gZmluYWxVcmxUb0ZldGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbmd1bGFyQ29uZmlnLnVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoXCJbQmx1ZXNreUh0dHBXcmFwcGVyXVtjb25maWd1cmVIdHRwQ2FsbF0gLSBVbmFibGUgdG8gYnVpbGQgdXJsIGZyb20gdXJsSW5wdXQgJ1wiICsgdXJsICsgXCInIHdpdGggZW5kcG9pbnRUeXBlICdcIiArIChibHVlc2t5Q29uZmlnLmVuZHBvaW50VHlwZSA/IEVuZHBvaW50VHlwZUVudW1bYmx1ZXNreUNvbmZpZy5lbmRwb2ludFR5cGVdIDogXCJ1bmtub3duIGVuZHBvaW50XCIpICsgXCInLiBBYm9ydGluZyBhamF4IGNhbGwuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5ndWxhckNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFN1Y2Nlc3MgaGFuZGxlci5cbiAgICAgICAgICAgICAgICAgICAgICogQ2FwdHVyZXMgdGhlIGlucHV0IHBhcmFtZXRlcnMgYXQgdGhlIG1vbWVudCBvZiBpdHMgZGVjbGFyYXRpb24gJiByZXR1cm4gdGhlIHJlYWwgaGFuZGxlciB0byBiZSBjYWxsZWQgdXBvbiBwcm9taXNlIGNvbXBsZXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAqIElucHV0IHBhcmFtZXRlcnM6XG4gICAgICAgICAgICAgICAgICAgICAqICAtIGNhbGxpbmdDb25maWc6IGNvbmZpZ3VyYXRpb24gdXNlZCB0byBtYWtlIHRoZSBhamF4IGNhbGwsIGluIGNhc2UgdGhlIHJldHVybmVkIHByb21pc2UgaXMgbnVsbC9lbXB0eSBhbmQgZG9lc24ndCBjb250YWluIG5lY2Vzc2FyeSBkYXRhIGZvciBkZWJ1Z2dpbmcuXG4gICAgICAgICAgICAgICAgICAgICAqICAtIGdldENvbXBsZXRlUmVzcG9uc2VPYmplY3Q6IGZsYWcgaW5kaWNhdGlvbiBpZiB3ZSBtdXN0IHJldHVybiB0aGUgZnVsbCByZXNwb25zZSBvYmplY3QgYWxvbmcgd2l0aCBoZWFkZXJzIGFuZCBzdGF0dXMgb3Igb25seSB0aGUgaW5uZXIgZGF0YS4gQnkgZGVmYXVsdCAmIGlmIG5vdCBzcGVjaWZpZWQsIG9ubHkgcmV0dXJucyBpbm5lciBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAob3JpZ2luYWxDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLndhcm4oJ3VuYWJsZSB0byByZXRyaWV2ZSBvcmlnaW5hbENvbmZpZyBpbiBvblN1Y2Nlc3MuIFBsZWFzZSBwcm92aWRlIGNvbXBsZXRlIGNvbmZpZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaHR0cFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWh0dHBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBcIltIVFRQIG5vLXJlc3BvbnNlXSBVbmV4cGVjdGVkICRodHRwIGVycm9yLCBubyByZXNwb25zZSBwcm9taXNlIHJldHVybmVkLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxDb25maWcuZGlzYWJsZVRvYXN0ZXJOb3RpZmljYXRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9hc3Rlci5lcnJvcigndW5leHBlY3RlZCBiZWhhdmlvcicsICdQbGVhc2UgY29udGFjdCB5b3VyIGxvY2FsIHN1cHBvcnQgdGVhbS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBtdWx0aS10eXBlIHJldHVybiBpbiBjYXNlIG9mIHJlamVjdGlvbiBvciBkbyBzb21ldGhpbmcgZWxzZSA/IHRoaXMgbWV0aG9kIGlzIGN1cnJlbnRseSB1c2VkIHN5bmNocm9ub3VzbHkgd2l0aG91dCBwcm9taXNlIHdhaXRpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIHRoaXMuJHEucmVqZWN0KGh0dHBQcm9taXNlKTsgLy8gUmVqZWN0IHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogcmVqZWN0IGlmIHN0YXR1cyAhPSAyWFggP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSB3aGVuIEFQSSBpcyBmaXhlZC4gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE3NDY4OTQvd2hhdC1pcy10aGUtcHJvcGVyLXJlc3QtcmVzcG9uc2UtY29kZS1mb3ItYS12YWxpZC1yZXF1ZXN0LWJ1dC1hbi1lbXB0eS1kYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAoKHByb21pc2VDYWxsYmFjay5kYXRhID09PSBudWxsIHx8IHByb21pc2VDYWxsYmFjay5kYXRhID09PSB1bmRlZmluZWQpICYmIHByb21pc2VDYWxsYmFjay5zdGF0dXMgIT09IDIwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIHRoaXMuJGxvZy5lcnJvcignVW5leHBlY3RlZCByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIsIGV4cGVjdGVkIHJlc3BvbnNlIGRhdGEgYnV0IG5vbmUgZm91bmQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgdGhpcy50b2FzdGVyLndhcm5pbmcoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UnLCAnUGxlYXNlIGNvbnRhY3QgeW91ciBsb2NhbCBzdXBwb3J0IHRlYW0uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KHByb21pc2VDYWxsYmFjayk7IC8vIFJlamVjdCBwcm9taXNlIGlmIG5vdCB3ZWxsLWZvcm1lZCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogc2FtZSBiZWhhdmlvciBhbHNvIG9uIGEgR0VUIHJlcXVlc3QgPyBpZiByZXF1ZXN0IGlzIEdFVCBhbmQgcmVzcG9uc2UgaXMgMjAwIHdpdGggbm8gZGF0YSwgcmV0dXJuIGVycm9yID8gKHBhc3MgaW4gcGFyYW1ldGVyIHJlcXVlc3QgY29udGV4dCB0byBsb2cgdGhpcyBlcnJvcikuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogZ2V0IGZ1bGwgdXJsIG9mIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmRlYnVnKFwiW0hUVFAgXCIgKyBodHRwUHJvbWlzZS5jb25maWcubWV0aG9kICsgXCJdIFtcIiArIGh0dHBQcm9taXNlLmNvbmZpZy51cmwgKyBcIl1cIiwgaHR0cFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBvbmx5IHRoZSBkYXRhIGV4cGVjdGVkIGZvciBjYWxsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFByb21pc2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBFcnJvciBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgICAqIFRPRE8gTUdBOiBhbmd1bGFyIHNpZ25hdHVyZXMgaW5kaWNhdGVzIHRoYXQgcGFyYW1ldGVyIGlzIHJlamVjdGlvbiByZWFzb24sIG5vdCBuZWNlc3NhcmlseSBodHRwUHJvbWlzZTogaW52ZXN0aWdhdGUgJiBmaXggaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBodHRwUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7fVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yID0gZnVuY3Rpb24gKG9yaWdpbmFsQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy53YXJuKCd1bmFibGUgdG8gcmV0cmlldmUgb3JpZ2luYWxDb25maWcgaW4gb25TdWNjZXNzLiBQbGVhc2UgcHJvdmlkZSBjb21wbGV0ZSBjb25maWcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGh0dHBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc3VwcG9zZSBpbiBjYXNlIG9mIG5vIHJlc3BvbnNlIHRoYXQgdGhlIHNydiBkaWRuJ3Qgc2VuZCBhbnkgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBNR0E6IG1heSBhbHNvIGJlIGEgZmF1bHQgaW4gaW50ZXJuYWwgJGh0dHAgLyBhamF4IGNsaWVudCBzaWRlIGxpYiwgdG8gZGlzdGluZ3Vpc2guXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFodHRwUHJvbWlzZSB8fCAhaHR0cFByb21pc2UuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwUHJvbWlzZS5kYXRhID0gJ1NlcnZlciBub3QgcmVzcG9uZGluZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLnN0YXR1cyA9IDUwMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcmlnaW5hbENvbmZpZy5kaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gaHR0cFByb21pc2UuaGVhZGVycygnQ29udGVudC1UeXBlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgY29udGVudFR5cGUgdG8gdHJ5IHRvIGRpc3BsYXkgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ3RleHQvcGxhaW4nKSA+IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAnJzsgLy9kZWZhdWx0IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBlcnJvciBoYW5kbGluZyBtb3JlIGdlbmVyaWNhbGx5IGJhc2VkIG9uIGlucHV0IGVycm9yIG1lc3NhZ2UgY29udHJhY3QgaW5zdGVhZCBvZiBleHBlY3Rpbmcgc3BlY2lmaWMgZXJyb3Igc3RyY3R1cmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIChyZXNwb25zZS5kYXRhLk1vZGVsU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIC8vVE9ETyBNR0EgOiBoYW5kbGUgdGhpcyB3aGVuIHdlbGwgZm9ybWF0dGVkIHNlcnZlci1zaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL30gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNTdHJpbmcoaHR0cFByb21pc2UuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gaHR0cFByb21pc2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGh0dHBQcm9taXNlLmRhdGEuTWVzc2FnZSAmJiBhbmd1bGFyLmlzU3RyaW5nKGh0dHBQcm9taXNlLmRhdGEuTWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gaHR0cFByb21pc2UuZGF0YS5NZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh0dHBQcm9taXNlLnN0YXR1cyA+PSA0MDAgJiYgaHR0cFByb21pc2Uuc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh0dHBQcm9taXNlLmRhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cFByb21pc2UuZGF0YS5Nb2RlbFN0YXRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLmRhdGEuTW9kZWxTdGF0ZS5WYWxpZGF0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLmRhdGEuTW9kZWxTdGF0ZS5WYWxpZGF0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VDb250ZW50ID0gaHR0cFByb21pc2UuZGF0YS5Nb2RlbFN0YXRlLlZhbGlkYXRpb24uam9pbignLCAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9hc3Rlci53YXJuaW5nKG1lc3NhZ2UgfHwgJ2JhZCByZXF1ZXN0JywgbWVzc2FnZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChodHRwUHJvbWlzZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50b2FzdGVyLndhcm5pbmcoJ25vdCBmb3VuZCcsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9hc3Rlci53YXJuaW5nKCdiYWQgcmVxdWVzdCcsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRvYXN0ZXIuZXJyb3IoJ3NlcnZlciByZXNwb25zZSBlcnJvcicsIG1lc3NhZ2UgKyBcIi4gKHN0YXR1czogXCIgKyBodHRwUHJvbWlzZS5zdGF0dXMgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50b2FzdGVyLmVycm9yKCdpbnRlcm5hbCBzZXJ2ZXIgZXJyb3InLCAnc3RhdHVzOiAnICsgaHR0cFByb21pc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBnZXQgZnVsbCB1cmwgb2YgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoXCJbSFRUUCBcIiArIGh0dHBQcm9taXNlLmNvbmZpZy5tZXRob2QgKyBcIl0gW1wiICsgaHR0cFByb21pc2UuY29uZmlnLnVybCArIFwiXVwiLCBodHRwUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgcmVjb3ZlciBmcm9tIGVycm9yLCBzbyB3ZSBwcm9wYWdhdGUgaXQgOiBiZWxvdyBoYW5kbGVycyBoYXZlIHRoZSBjaG9pY2Ugb2YgcmVhZGluZyB0aGUgZXJyb3Igd2l0aCBhbiBlcnJvciBoYW5kbGVyIG9yIG5vdC4gU2VlICRxIHByb21pc2VzIGJlaGF2aW9yIGhlcmUgOiBodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3FcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGJlaGF2aW9yIGlzIGRlc2lyZWQgc28gdGhhdCB3ZSBzaG93IGVycm9yIGluc2lkZSBzcGVjaWZpYyBzZXJ2ZXIgY29tbXVuaWNhdGlvbiBtb2RhbHMgYXQgc3BlY2lmaWMgcGxhY2VzIGluIHRoZSBhcHAsIG90aGVyd2lzZSBzaG93IGEgZ2xvYmFsIGFsZXJ0IG1lc3NhZ2UsIG9yIGV2ZW4gZG8gbm90IHNob3cgYW55dGhpbmcgaWYgbm90IG5lY2Vzc2FyeSAoZG8gbm90IGFkIGFuIGVycm9yIGhhbmRsZXIgaW4gYmVsb3cgaGFuZGxlcnMgb2YgdGhpcyBwcm9taXNlKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJHEucmVqZWN0KGh0dHBQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBGdW5jdGlvbiBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhbiBhamF4IGNhbGwsIHJlZ2FyZGxlc3Mgb2YgaXQncyBzdWNjZXNzIG9yIGZhaWx1cmUuXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgKiBUT0RPIE1HQSBpbnZlcnNpb24gb2YgcmVzcG9uc2FiaWxpdHk6IG1ha2UgdGhpcyBleHRlbnNpYmxlIHNvIHRoYXQgc3BlY2lmYyBhcHBzIGNhbiBwbHVnIGludG8gdGhpcyBldmVudCB3b3JrZmxvd1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5hbGx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogT0Utc3BlY2lmaWMgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLiR3aW5kb3cuYmxvY2tfVUkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHR5cGUgY2FzdGluZywgaXMgaXQgb2theSBvciBub3QgPyBiZXR0ZXIgYXBwcm9hY2ggP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiR3aW5kb3cucHJldmVudEJsb2NrVUkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpZ3VyYXRpb25FbmRwb2ludFVybCA9IHRoaXMuYnVpbGRVcmxGcm9tQ29udGV4dChjb25maWdJbml0aWFsaXphdGlvblVSTCwgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uRW5kcG9pbnRVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihcIltCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIFVuYWJsZSB0byBidWlsZCB1cmwgZnJvbSBpbml0aWFsQ29uZmlnIHVybCAnXCIgKyBjb25maWdJbml0aWFsaXphdGlvblVSTCArIFwiJyB3aXRoIGVuZHBvaW50VHlwZSAnXCIgKyBFbmRwb2ludFR5cGVFbnVtW0VuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbl0gKyBcIicuIEFib3J0aW5nIGJsdWVza3lIdHRwU2VydmljZSBpbml0LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBjdXN0b20gY29uZmlnIGZvciBoZWFkZXJzIGhhcmQgY29kZWQsIHRvIG11dHVhbGl6ZSB3aXRoIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGxvZyBwcm9wZXJseSBhcyBvdGhlciBhamF4IGNhbGxzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0QWpheENvbmZpZ0Zyb21TZXJ2ZXJQcm9taXNlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGh0dHBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KGNvbmZpZ3VyYXRpb25FbmRwb2ludFVybCwgeyBoZWFkZXJzOiB7ICdYLVJlcXVlc3RlZC1XaXRoJzogJ1hNTEh0dHBSZXF1ZXN0JyB9IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY2xpZW50Q29uZmlnUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHJlamVjdCBzdGF0dXMgbm90IGluIDJYWCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjbGllbnRDb25maWdQcm9taXNlLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IFwiW0JsdWVza3lIdHRwV3JhcHBlcl1bSW5pdGlhbGl6YXRpb25dIC0gVW5hYmxlIHRvIHJldHJpZXZlIGh0dHAgY29uZmlnIGRhdGEgZnJvbSAnXCIgKyBjb25maWdJbml0aWFsaXphdGlvblVSTCArIFwiJy4gQWJvcnRpbmcgICAgICAgICAgICAgICBibHVlc2t5SHR0cFdyYXBwZXJTZXJ2aWNlIGluaXRpYWxpemF0aW9uLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHRvYXN0ZXIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhpcy4kcS5yZWplY3QobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuaW5mbygnW0JsdWVza3lIdHRwV3JhcHBlcl1bSW5pdGlhbGl6YXRpb25dIC0gU3VjY2Vzc2Z1bGx5IGxvYWRlZCBjbGllbnRDb25maWcgZnJvbSBzcnY6JywgY2xpZW50Q29uZmlnUHJvbWlzZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZyA9IGNsaWVudENvbmZpZ1Byb21pc2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50Q29uZmlnUHJvbWlzZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdbQmx1ZXNreUh0dHBXcmFwcGVyXVtJbml0aWFsaXphdGlvbl0gLSBVbmFibGUgdG8gcmV0cmlldmUgQVBJIGNvbmZpZy4gQWJvcnRpbmcgYmx1ZXNreUh0dHBXcmFwcGVyU2VydmljZSBpbml0aWFsaXphdGlvbi4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IobXNnICsgJ09yaWdpbmFsIG1zZzogJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHNob3cgdG9hc3RlciA/IGJhc2VkIG9uIHByb3ZpZGVyIGNvbmZpZyBmbGFnID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJHEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3N1Y2Nlc3MsIGdldCB1c2VyU1NPIGZyb20gY2FwaSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChibHVlc2t5Q2xpZW50Q29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsdWVza3lDbGllbnRDb25maWcuQ3VycmVudFVzZXJSb2xlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVXNlclJvbGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNlbGVjdGVkVXNlclJvbGUuTmFtZSArICcgJyArIHNlbGVjdGVkVXNlclJvbGUuUm9sZSArICcgJyArIHNlbGVjdGVkVXNlclJvbGUuU2lsbykgIT09IGJsdWVza3lDbGllbnRDb25maWcuQ3VycmVudFVzZXJSb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW0JsdWVza3lIdHRwV3JhcHBlcl1bSW5pdGlhbGl6YXRpb25dIC0gY2xpZW50ICYgc3J2LXNpZGUgc2VsZWN0ZWQgdXNlciByb2xlcyBwcm92aWRlZCBidXQgdGhleSBkaWZmZXIuIGludGVybmFsIGVycm9yIHRvIGZpeC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFibHVlc2t5Q2xpZW50Q29uZmlnLkN1cnJlbnRVc2VyUm9sZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0lmIG5vdCBwcm92aWRlZCBieSBkb21haW4gZnJvbSB3aGljaCBjb2RlIHdhcyBsb2FkZWQsIHRoZW4gdHJ5IHRvIGZldGNoIGRlZmF1bHQgdXNlclJvbGUgZnJvbSBDQVBJIGVuZHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuaW5mbygnW0JsdWVza3lIdHRwV3JhcHBlcl1bSW5pdGlhbGl6YXRpb25dIC0gTm8gZGVmYXVsdCBVc2VyUm9sZSBwcm92aWRlZCBieSBjdXJyZW50IGRvbWFpbiwgdHJ5aW5nIHRvIGZldGNoIGl0IGZyb20gQ0FQSS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvcmVBcGlDb25maWcgPSBibHVlc2t5Q2xpZW50Q29uZmlnLkVuZHBvaW50Q29uZmlndXJhdGlvbkRpY3Rpb25uYXJ5W0VuZHBvaW50VHlwZUVudW1bRW5kcG9pbnRUeXBlRW51bS5Db3JlQXBpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29yZUFwaUNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdbQmx1ZXNreUh0dHBXcmFwcGVyXVtJbml0aWFsaXphdGlvbl0gLSBGYWlsZWQgdG8gcmV0cmlldmUgbmVjZXNzYXJ5IENvcmVBcGkgZW5kcG9pbnQgY29uZmlnIHRvIGZldGNoIHVzZXJTU08uIEFib3J0aW5nLic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBmYWN0b3JpemUgd2l0aCBjb25maWd1cmVIdHRwQ2FsbCgpICEhIHRoaXMgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgd2UgY2Fubm90IHVzZSBhamF4KCkgRFJZIG1ldGhvZCAuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1c3RvbUNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyICcgKyBjb3JlQXBpQ29uZmlnLkF1dGhUb2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0VXNlclNzb0Z1bGxVcmwgPSBfdGhpcy5idWlsZFVybEZyb21Db250ZXh0KCd1c2VyLXNzbz9wcm9maWxlPScsIEVuZHBvaW50VHlwZUVudW0uQ29yZUFwaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZ2V0VXNlclNzb0Z1bGxVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnW0JsdWVza3lIdHRwV3JhcHBlcl1bSW5pdGlhbGl6YXRpb25dIC0gRmFpbGVkIHRvIGNvbnN0cnVjdCB1c2VyU1NPIHVybCBmb3IgY2FwaS4gQWJvcnRpbmcuJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGxvZyBwcm9wZXJseSBhcyBvdGhlciBhamF4IGNhbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kaHR0cC5nZXQoZ2V0VXNlclNzb0Z1bGxVcmwsIGN1c3RvbUNvbmZpZykudGhlbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zdWNjZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh1c2VyU3NvUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyU3NvUHJvbWlzZSB8fCAhdXNlclNzb1Byb21pc2UuZGF0YSB8fCAhdXNlclNzb1Byb21pc2UuZGF0YS5Vc2VyUm9sZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvcmVBcGlDb25maWdNaXNzaW5nTXNnID0gJ1tCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIFVuYWJsZSB0byByZXRyaWV2ZSBDb3JlQVBJIGRlZmF1bHQgdXNlclNTTy4gQWJvcnRpbmcgaHR0cFdyYXBwZXJTZXJ2aWNlIGluaXRpYWxpemF0aW9uLic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihjb3JlQXBpQ29uZmlnTWlzc2luZ01zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvcmVBcGlDb25maWdNaXNzaW5nTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXNlclNzb1Byb21pc2UuZGF0YS5Vc2VyRGlzcGxheU5hbWUgfHwgIXVzZXJTc29Qcm9taXNlLmRhdGEuVXNlcklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9Vc2VySWRNc2cgPSAnW0JsdWVza3lIdHRwV3JhcHBlcl1bSW5pdGlhbGl6YXRpb25dIC0gQ29yZUFQSSB1c2VyU1NPIGlzIG5vdCBmdWxseSBwb3B1bGF0ZWQ6IHVuYWJsZSB0byByZXRyaWV2ZSBVc2VySWRlbnRpZmllciBvciBEaXNwbGF5TmFtZS4gQWJvcnRpbmcgaHR0cFdyYXBwZXJTZXJ2aWNlIGluaXRpYWxpemF0aW9uLic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihub1VzZXJJZE1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5vVXNlcklkTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1c2VyU3NvID0gdXNlclNzb1Byb21pc2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuaW5mbyhcIltCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIERlZmF1bHQgdXNlclNTTyBsb2FkZWQgZnJvbSBDQVBJOiAnXCIgKyB1c2VyU3NvLlVzZXJEaXNwbGF5TmFtZSArIFwiJy5cIiwgdXNlclNzbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRVc2VyUm9sZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmluZm8oXCJbQmx1ZXNreUh0dHBXcmFwcGVyXVtJbml0aWFsaXphdGlvbl0gLSBDbGllbnQgYXBwIHByb3ZpZGVkIHBlcnNpc3RlZCBVc2VyUm9sZS4gQXNzaWduaW5nIGl0LlwiLCBfdGhpcy5zZWxlY3RlZFVzZXJSb2xlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IG1ha2Ugc3VyZSBzZWxlY3RlZFVzZXJSb2xlIGlzIGF2YWlsYWJsZSBpbiB0aGUgbGlzdCBvZiB1c2VyU1NPIHJvbGVzLCBvdGhlcndpc2Ugc2VsZWN0IGRlZmF1bHQgIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaG93IHRvIGluZm9ybSBiYWNrIHRoZSBEQSB0aGF0IHNlbGVjdGVkVXNlclJvbGUgd2FzIHJlc2V0ID8gaW52ZXJ0IHJlc3BvbnNhYmlsaXR5ICYgc3RvcmUgdXNlclJvbGUgaW4gbG9jYWxTdG9yYWdlIGZyb20gdGhpcyBzZXJ2aWNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1c2VyUm9sZVRvVXNlID0gc2VsZWN0ZWRVc2VyUm9sZSB8fCB1c2VyU3NvLlVzZXJSb2xlRW50cnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiB0aGlzIG5lZWRzIHRvIGJlIHB1dCBpbiBzaGFyZWQgZXh0ZW5zaW9uIG1ldGhvZCAvIHNlcnZpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLkN1cnJlbnRVc2VyUm9sZSA9IHVzZXJSb2xlVG9Vc2UuTmFtZSArIFwiIFwiICsgdXNlclJvbGVUb1VzZS5Sb2xlICsgXCIgXCIgKyB1c2VyUm9sZVRvVXNlLlNpbG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5DdXJyZW50VXNlciA9IHVzZXJTc287XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmx1ZXNreUNsaWVudENvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ1tCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIFVuYWJsZSB0byByZXRyaWV2ZSB1c2VyIFNTTyBmcm9tIGNhcGkuIFByb2JhYmx5IGR1ZSB0byBpbnZhbGlkIGNlcnRpZmljYXRlcyBwcmV2ZW50aW5nIHVzIHRvIGNvbW11bmljYXRlIHdpdGggQ0FQSS4gQWJvcnRpbmcuJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IobXNnICsgJyBPcmlnaW5hbCBtc2c6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogc2hvdyB0b2FzdGVyID8gYmFzZWQgb24gcHJvdmlkZXIgY29uZmlnIGZsYWcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRxLnJlamVjdChtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHdlIG9ubHkgbG9hZCB1c2VyU1NPIGlmIG5vIHVzZXJSb2xlIHdhcyBwcm92aWRlZCBzcnYtc2lkZSwgc2hvdWxkIHdlIGxvYWQgaXQgaW4gYWxsIGNhc2VzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBkZWZpbmVkIHVzZXJSb2xlIHNlbnQgZnJvbSBvcmlnaW4gYXBwLCB1c2UgaXQgJiBzZXQgaXQgYXMgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsdWVza3lDbGllbnRDb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gKGVycm9yOiBhbnkpOiBuZy5JUHJvbWlzZTxuZXZlcj4gPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgLy9UT0RPIE1HQTogc2hvdWxkIG5vdCBiZSBuZWVkZWQsIGZhaWwgY2FzZSBpdCBjb25zdW1lciBwcm9taXNlc1xuICAgICAgICAgICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8jZW5kcmVnaW9uXG4gICAgICAgICAgICAgICAgLy8jcmVnaW9uIHB1YmxpYyBtZXRob2RzXG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheChIdHRwTWV0aG9kLkdFVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodXJsLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheChIdHRwTWV0aG9kLkRFTEVURSwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBkYXRhIHx8IGNvbmZpZy5kYXRhO1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXgoSHR0cE1ldGhvZC5QT1NULCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gZGF0YSB8fCBjb25maWcuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheChIdHRwTWV0aG9kLlBVVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5wYXRjaCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gZGF0YSB8fCBjb25maWcuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheChIdHRwTWV0aG9kLlBBVENILCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUT0RPIE1HQTogbm90IERSWSB3aXRoIGFqYXggbWV0aG9kLCBob3cgdG8ga2VlcCBpdCBpbiBzeW5jID9cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdXJsXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGZpbGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbiAodXJsLCBmaWxlLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlICYmICghY29uZmlnIHx8ICFjb25maWcuZmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnQ2Fubm90IHN0YXJ0IHVwbG9hZCB3aXRoIG51bGwge2ZpbGV9IHBhcmFtZXRlci4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5maWxlID0gZmlsZSB8fCBjb25maWcuZmlsZTsgLy9UT0RPIE1HQSA6IGRvIG5vdCBleHBvc2UgZmlsZSBpbiBJQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnID9cbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBjb25maWcuZGF0YSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy51cGxvYWRJbkJhc2U2NEpzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IG1ha2Ugc3VyZSB0aGlzIGRlbGF5cyBuZXh0IGNhbGwgYW5kIHVwbG9hZCBpcyBub3QgZG9uZSBiZWZvcmUgYmFzZTY0IGVuY29kaW5nIGlzIGZpbmlzaGVkLCBldmVuIGlmIHByb21pc2UgaXMgYWxyZWFkeSByZXNvbHZlZCA/Pz9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlVwbG9hZC5iYXNlNjREYXRhVXJsKGZpbGUpLnRoZW4oZnVuY3Rpb24gKGZpbGVCYXNlNjRVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkLWNvZGVkIGtleSB0byBmZXRjaCBiYXNlNjQgZW5jb2RpbmcsIHRvIHBhcmFtZXRyaXplIHdpdGggc2VydmVyLXNpZGUgIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLmRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhLmZpbGVCYXNlNjRVcmwgPSBmaWxlQmFzZTY0VXJsOyAvL1RPRE8gTUdBIHNob3VsZCBub3QgaGF2ZSB0byBoYW5kbGUgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbm9ybWFsIHBvc3QgaW4gY2FzZSBvZiBiYXNlNjQtZW5jb2RlZCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFqYXgoSHR0cE1ldGhvZC5QT1NULCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhLmZpbGVGb3JtRGF0YU5hbWUgPSAnZmlsZSc7IC8vIGZpbGUgZm9ybURhdGEgbmFtZSAoJ0NvbnRlbnQtRGlzcG9zaXRpb24nKSwgc2VydmVyIHNpZGUgcmVxdWVzdCBmb3JtIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBkbyBub3QgYmxvY2sgaWYgbm90IGNhbGwgdG8gaW50ZXJuYWwgQVBJID8gKGluaXRDYWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWpheENvbmZpZ0Zyb21TZXJ2ZXJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibHVlc2t5Q29uZmlnID0gX3RoaXMuc2V0dXBCbHVlc2t5Q29uZmlnKGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ3VsYXJDb25maWcgPSBfdGhpcy5leHRyYWN0QW5ndWxhckNvbmZpZ0Zyb21CbHVlc2t5Q29uZmlnKEh0dHBNZXRob2QuUE9TVCwgdXJsLCBibHVlc2t5Q29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFuZ3VsYXJDb25maWcgfHwgIWJsdWVza3lDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRxLnJlamVjdCgnW2JsdWVza3lIdHRwV3JhcHBlci1BamF4Q2FsbF0gdW5hYmxlIHRvIGNvbmZpZ3VyZSBjb3JyZWN0bHkgYW5ndWxhciBjb25maWcgb2JqZWN0IG5lY2Vzc2FyeSBmb3IgYWpheCBjYWxsLiBhYm9ydGluZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLlVwbG9hZC51cGxvYWQoYW5ndWxhckNvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oX3RoaXMub25TdWNjZXNzKGJsdWVza3lDb25maWcpLCBfdGhpcy5vbkVycm9yKGJsdWVza3lDb25maWcpLCAoY29uZmlnICYmIGNvbmZpZy51cGxvYWRQcm9ncmVzcykgPyBjb25maWcudXBsb2FkUHJvZ3Jlc3MgOiB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KF90aGlzLmZpbmFsbHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gZG93bmxvYWQgYSBmaWxlIGluIHRoZSBmb3JtIG9mIGEgYnl0ZS1zdHJlYW0gZnJvbSBhbiBlbmRwb2ludCBhbmQgd3JhcCBpdCBpbnRvIGEgRmlsZUNvbnRlbnQgb2JqZWN0IHdpdGggbmFtZSwgdHlwZSAmIHNpemUgcHJvcGVydGllcyByZWFkIGZyb20gdGhlIEhUVFAgcmVzcG9uc2UgaGVhZGVycyBvZiB0aGUgc2VydmV1ci5cbiAgICAgICAgICAgICAgICAgKiBJdCBpcyB0aGUgcmVzcG9uc2FiaWxpdHkgb2YgdGhlIGNvbnN1bWVyIHRvIGRvIHNvbWV0aGluZyB3aXRoIHRoZSB3cmFwcGVkIGJ5dGVBcnJheSAoZm9yIGV4YW1wbGUgZG93bmxvYWQgdGhlIGZpbGUsIG9yIHNob3cgaXQgaW5zaWRlIHRoZSB3ZWJQYWdlIGV0YykuXG4gICAgICAgICAgICAgICAgICogVE9ETyBNR0E6IG5vdCBEUlkgd2l0aCBhamF4IG1ldGhvZCwgaG93IHRvIGtlZXAgaXQgaW4gc3luYyA/XG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHVybFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBleHBlY3RlZE5hbWVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXhwZWN0ZWRTaXplXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV4cGVjdGVkVHlwZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLmdldEZpbGUgPSBmdW5jdGlvbiAodXJsLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWpheENvbmZpZ0Zyb21TZXJ2ZXJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsdWVza3lDb25maWcgPSBfdGhpcy5zZXR1cEJsdWVza3lDb25maWcoY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmd1bGFyQ29uZmlnID0gX3RoaXMuZXh0cmFjdEFuZ3VsYXJDb25maWdGcm9tQmx1ZXNreUNvbmZpZyhIdHRwTWV0aG9kLkdFVCwgdXJsLCBibHVlc2t5Q29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYW5ndWxhckNvbmZpZyB8fCAhYmx1ZXNreUNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kcS5yZWplY3QoJ1tibHVlc2t5SHR0cFdyYXBwZXItQWpheENhbGxdIHVuYWJsZSB0byBjb25maWd1cmUgY29ycmVjdGx5IGFuZ3VsYXIgY29uZmlnIG9iamVjdCBuZWNlc3NhcnkgZm9yIGFqYXggY2FsbC4gYWJvcnRpbmcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpY2FsbHkgZXhwZWN0IHJhdyByZXNwb25zZSB0eXBlLCBvdGhlcndpc2UgYnl0ZSBzdHJlYW0gcmVzcG9uc2VzIGFyZSBjb3JydXB0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyQ29uZmlnLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0V4cGVjdGVkIEFycmF5QnVmZmVyIHJlc3BvbnNlID0gYnl0ZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRodHRwKGFuZ3VsYXJDb25maWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGh0dHBSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2JlbmVmaXQgZnJvbSBzdWNjZXNzQ2FsbGJhY2sgdmFsaWRhdGlvbiBiZWZvcmUgY29udGludWluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgdW5kZXJzdGFuZCB3aHkgVFMgdmFsaWRhdGlvbiBkb2Vzbid0IGNhdGNoIGFib3ZlIGlmIGNsYXVzZSB0byB2YWxpZGF0ZSBibHVlc2t5Q29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFibHVlc2t5Q29uZmlnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJHEucmVqZWN0KCdbYmx1ZXNreUh0dHBXcmFwcGVyLUFqYXhDYWxsXSB1bmFibGUgdG8gY29uZmlndXJlIGNvcnJlY3RseSBhbmd1bGFyIGNvbmZpZyBvYmplY3QgbmVjZXNzYXJ5IGZvciBhamF4IGNhbGwuIGFib3J0aW5nLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJheUJ1ZmZlciA9IF90aGlzLm9uU3VjY2VzcyhibHVlc2t5Q29uZmlnKShodHRwUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHByb21pc2UgcmVqZWN0aW9uIHZzLiByZXR1cm4gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnJheUJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbQmx1ZXNreUh0dHBXcmFwcGVyLWdldEZpbGVdIC0gdW5hYmxlIHRvIHJldHJpZXZlIGJ5dGUgYXJyYXkuJyk7IC8vc3RvcCBwcm9jZXNzaW5nIGlmIHVuYWJsZSB0byByZXRyaWV2ZSBieXRlIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWFkIGZpbGUgaW5mbyBmcm9tIHJlc3BvbnNlLWhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZUNvbnRlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IF90aGlzLmdldEZpbGVOYW1lRnJvbUhlYWRlckNvbnRlbnREaXNwb3NpdGlvbihodHRwUmVzcG9uc2UuaGVhZGVycygnY29udGVudC1kaXNwb3NpdGlvbicpKSB8fCAndW5rbm93bicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IE51bWJlcihodHRwUmVzcG9uc2UuaGVhZGVycygnY29udGVudC1sZW5ndGgnKSkgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogaHR0cFJlc3BvbnNlLmhlYWRlcnMoJ2NvbnRlbnQtdHlwZScpIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBhcnJheUJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25FcnJvcihibHVlc2t5Q29uZmlnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseShfdGhpcy5maW5hbGx5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUcmllcyB0byBwYXJzZSB0aGUgaW5wdXQgdXJsIDpcbiAgICAgICAgICAgICAgICAgKiBJZiBpdCBzZWVtcyB0byBiZSBhIGZ1bGwgVVJMLCB0aGVuIHJldHVybiBhcyBpcyAoY29uc2lkZXJzIGl0IGV4dGVybmFsIFVybClcbiAgICAgICAgICAgICAgICAgKiBPdGhlcndpc2UsIHRyaWVzIHRvIGZpbmQgdGhlIGJhc2UgVVJMIG9mIHRoZSBjdXJyZW50IEJsdWVTa3kgYXBwIHdpdGggb3Igd2l0aG91dCB0aGUgaW5jbHVkZWQgQ29udHJvbGxlciBhbmQgcmV0dXJucyB0aGUgZnVsbCBVcmxcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdXJsSW5wdXQgOiBUT0RPIE1HQTogZG9jdW1lbnQgZGlmZmVyZW50IGtpbmQgb2YgdXJscyB0aGF0IHRoaXMgbWV0aG9kIGNhbiB0YWtlIGFzIGlucHV0IChmdWxsLCBwYXJ0aWFsIGV0YylcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIG51bGwgaWYgbm90IGFibGUgdG8gY29tcHV0ZSB1cmwuIE90aGVyd2lzZSwgdXJsIG9mIHRoZSByZXF1ZXN0IGVpdGhlciBwYXJ0aWFsIG9yIGZ1bGwgYmFzZWQgb24gZW5kcG9pbnRUeXBlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUuYnVpbGRVcmxGcm9tQ29udGV4dCA9IGZ1bmN0aW9uICh1cmxJbnB1dCwgZW5kcG9pbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXJsSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignTm8gVVJMIGlucHV0IHByb3ZpZGVkLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBVcmwgc3RhcnRzIHdpdGggaHR0cDovLyBvciBodHRwczovLyA9PiByZXR1cm4gYXMgaXMsIGV2ZW4gaWYgZW5kcG9pbnRUeXBlIGlzIG5vdCBleHRlcm5hbC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybElucHV0LnNsaWNlKDAsICdodHRwOi8vJy5sZW5ndGgpID09PSAnaHR0cDovLycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybElucHV0LnNsaWNlKDAsICdodHRwczovLycubGVuZ3RoKSA9PT0gJ2h0dHBzOi8vJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50VHlwZSAhPT0gRW5kcG9pbnRUeXBlRW51bS5FeHRlcm5hbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cud2FybignRnVsbCBVUkwgcHJvdmlkZWQgZm9yIGEgY2FsbCB0aGF0IGlzIG5vdCBmbGFnZ2VkIGFzIFxcJ0V4dGVybmFsXFwnIGVuZHBvaW50VHlwZSwgdGhpcyBpcyBiYWQgcHJhY3RpY2UgYXMgb25seSB0aGUgYmx1ZXNreVdyYXBwZXIgc2hvdWxkIGtub3cgYWJvdXQgdGhlIGJhc2VVUkwgb2YgdGFyZ2V0IGVuZHBvaW50cyAobG9hZGVkIGZyb20gc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgZW52KS4gVXNlIHBhcnRpYWwgVVJMcy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1cmxJbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlLCB3ZSBoYXZlIGEgcGFydGlhbCBVUkwgdG8gY29tcGxldGU6IHVzZSBwcm92aWRlZCBlbmRwb2ludCB0eXBlIHRvIGRldGVybWluZSBob3cgdG8gY29tcGxldGUgdXJsLlxuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHZhbHVlIGZvciBlbmRwb2ludFR5cGUgaWYgbm90IHByb3ZpZGVkIGlzIG9yaWdpbi4gVE9ETyBNR0E6IHJ1bGUgdG8gZGlzY3VzcywgaGVyZSBmb3IgcmV0cm8tY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRUeXBlID0gZW5kcG9pbnRUeXBlIHx8IEVuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRwb2ludFR5cGUgPT09IEVuZHBvaW50VHlwZUVudW0uRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy53YXJuKCdQYXJ0aWFsIHVybCBwcm92aWRlZCBmb3IgYSBjYWxsIHdpdGggZW5kcG9pbnRUeXBlIGZsYWdnZWQgYXMgXFwnRXh0ZXJuYWxcXCc6IHRoZSBjYWxsIHdpbGwgcHJvYmFibHkgZmFpbC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBtb2RpZnkgcHJvdmlkZWQgdXJsIGlmIGV4dGVybmFsICh3ZSBjYW5ub3Qga25vdyBob3cgdG8gY29tcGxldGUgaXQsIGV2ZW4gaWYgcGFydGlhbCkuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsSW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZW5kcG9pbnRUeXBlID09PSBFbmRwb2ludFR5cGVFbnVtLkN1cnJlbnREb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IG5vdCBsb2FkaW5nIHRoZSBlbmRwb2ludENvbmZpZyBmb3IgY3VycmVudCBkb21haW4gbWVhbnMgd2UgY2FuJ3QgYWNjZXNzIGVuZHBvaW50QVBJc3VmZml4IGlmIGl0IGV4aXN0cywgc2hvdWxkIHdlIGxvYWQgdGhlIGVuZHBvaW50Q29uZmlnIGZvciB0aGlzIGNhc2UgdG9vID8/ICYgaGFuZGxlIGl0IHRoZSBzYW1lIHdheSBhcyBvdGhlciBlbmRwb2ludHMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVnZXggdHJ5aW5nIHRvIGRldGVybWluZSBpZiB0aGUgaW5wdXQgZnJhZ21lbnQgY29udGFpbnMgYSAvIGJldHdlZW4gdHdvIGNoYXJhY3RlciBzdWl0ZXMgPT4gY29udHJvbGxlciBnaXZlbiBhcyBpbnB1dCwgb3RoZXJ3aXNlLCBhY3Rpb24gb24gc2FtZSBjb250cm9sbGVyIGV4cGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbGxlcklzUHJlc2VudFJlZ2V4ID0gL1xcdytcXC9cXHcrLztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIgPSAhY29udHJvbGxlcklzUHJlc2VudFJlZ2V4LnRlc3QodXJsSW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IHRoaXMuZ2V0VXJsUGF0aChhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGFsbCBvdGhlciBlbmRwb2ludFR5cGVzOiBjb21wdXRlIFVSTCBhcyBhIGNvbWJpbmF0aW9uIG9mIGJhc2VVUkwgJiBzdWZmaXggaWYgcHJlc2VudCwgYXMgcHJvdmlkZWQgYnkgc2VydmVyLWNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5FbmRwb2ludENvbmZpZ3VyYXRpb25EaWN0aW9ubmFyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignRXhwZWN0ZWQgZW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnkgcHJvdmlkZWQgYnV0IG5vbmUgZm91bmQuIEFib3J0aW5nLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSBIQUNLWTogc2VhcmNoIGJ5IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBlbmRwb2ludCB0eXBlIGluIGRpY3QgZHVlIHRvIHNlcmlhbGl6YXRpb24gbGltaXRzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kcG9pbnRDb25maWcgPSB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLkVuZHBvaW50Q29uZmlndXJhdGlvbkRpY3Rpb25uYXJ5W0VuZHBvaW50VHlwZUVudW1bZW5kcG9pbnRUeXBlXV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZHBvaW50Q29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKFwiRW5kcG9pbnRUeXBlICdcIiArIEVuZHBvaW50VHlwZUVudW1bZW5kcG9pbnRUeXBlXSArIFwiJyBpcyBub3QgJ0V4dGVybmFsJyBvciAnQ3VycmVudERvbWFpbicsIGV4cGVjdGVkIGNvcnJlc3BvbmRpbmcgZW5kcG9pbnRDb25maWd1cmF0aW9uIHByb3ZpZGVkIGluIGJsdWVza3lBamF4Q2xpZW50Q29uZmlnLmVuZHBvaW50Q29uZmlndXJhdGlvbkRpY3Rpb25uYXJ5IGJ1dCBub25lIGZvdW5kLiBBYm9ydGluZy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBlbmRwb2ludENvbmZpZy5FbmRwb2ludEJhc2VVUkwgKyAoZW5kcG9pbnRDb25maWcuRW5kcG9pbnRTdWZmaXggfHwgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhvdyB0byBoYW5kbGUgT00gYXBwcyBleHRlcm5hbCBjYWxscyB3aXRob3V0IHNlc3Npb24gcHJvdmlkZWQgPyB3aWxsIHJlc3VsdCBpbiBhIHJlZGlyZWN0IGFuZCBjYWxsIG1heSBmYWlsID9cbiAgICAgICAgICAgICAgICAgICAgLy8gQm9vbGVhbiB1c2VkIHRvIHRyeSB0byBkZXRlcm1pbmUgY29ycmVjdCBmdWxsIHVybCAoYWRkIC8gb3Igbm90IGJlZm9yZSB0aGUgdXJsIGZyYWdtZW50IGRlcGVuZGluZyBvbiBpZiBmb3VuZCBvciBub3QpXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaCA9IHVybElucHV0LnNsaWNlKDAsIDEpID09PSAnLyc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVXJsRnJhZ21lbnRFbmRzV2l0aFNsYXNoID0gYmFzZVVybC5zbGljZShiYXNlVXJsLmxlbmd0aCAtIDEsIGJhc2VVcmwubGVuZ3RoKSA9PT0gJy8nO1xuICAgICAgICAgICAgICAgICAgICAvL2Jhc2VkIG9uIHN0YXJ0aW5nL3RyYWlsaW5nIHNsYXNoZXMsIHJldHVybiBmdWxsIHVybC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VVcmxGcmFnbWVudEVuZHNXaXRoU2xhc2ggJiYgdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgbGFzdCAnLycgb24gYmFzZVVybFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmwuc2xpY2UoMCwgYmFzZVVybC5sZW5ndGggLSAxKSArIHVybElucHV0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiAhdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2gpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybCArICcvJyArIHVybElucHV0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiAhdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2gpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoIWJhc2VVcmxGcmFnbWVudEVuZHNXaXRoU2xhc2ggJiYgdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2gpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmwgKyB1cmxJbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vI2VuZHJlZ2lvblxuICAgICAgICAgICAgICAgIC8vI3JlZ2lvbiBwcml2YXRlIG1ldGhvZHNcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBVdGlsaXR5IG1ldGhvZC5cbiAgICAgICAgICAgICAgICAgKiBNYWluIGNhbGxlciB0aGF0IGFsbCB3cmFwcGVyIGNhbGxzIChnZXQsIGRlbGV0ZSwgcG9zdCwgcHV0KSBtdXN0IHVzZSB0byBzaGFyZSBjb21tb24gYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNvbmZpZ1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUuYWpheCA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBtYWtlIHN1cmUgZ2V0Q29uZmlnIHJlc29sdmUgYXV0b21hdGljYWxseSB3aXRob3V0IG92ZXJoZWFkIG9uY2UgZmlyc3QgY2FsbCBzdWNlc3NmdWxsLlxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogZG8gbm90IGJsb2NrIGlmIG5vdCBjYWxsIHRvIGludGVybmFsIEFQSSAoaW5pdENhbGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFqYXhDb25maWdGcm9tU2VydmVyUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibHVlc2t5Q29uZmlnID0gX3RoaXMuc2V0dXBCbHVlc2t5Q29uZmlnKGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5ndWxhckNvbmZpZyA9IF90aGlzLmV4dHJhY3RBbmd1bGFyQ29uZmlnRnJvbUJsdWVza3lDb25maWcobWV0aG9kLCB1cmwsIGJsdWVza3lDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbmd1bGFyQ29uZmlnIHx8ICFibHVlc2t5Q29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRxLnJlamVjdCgnW2JsdWVza3lIdHRwV3JhcHBlci1BamF4Q2FsbF0gdW5hYmxlIHRvIGNvbmZpZ3VyZSBjb3JyZWN0bHkgYW5ndWxhciBjb25maWcgb2JqZWN0IG5lY2Vzc2FyeSBmb3IgYWpheCBjYWxsLiBhYm9ydGluZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kaHR0cChhbmd1bGFyQ29uZmlnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKF90aGlzLm9uU3VjY2VzcyhibHVlc2t5Q29uZmlnKSwgX3RoaXMub25FcnJvcihibHVlc2t5Q29uZmlnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseShfdGhpcy5maW5hbGx5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHVzaW5nIG1ldGhvZCBmcm9tIExheW91dC5qcyA6IHRvIGRvY3VtZW50IHRvIG5vdCBoYW5kbGUgZHVwbGljYXRlIGNvZGUgISFcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiB1bnJvYnVzdCwgbmVlZHMgc29saWQgcmVmYWN0byB0byBtYWtlIGl0IG1vcmUgZ2VuZXJpYyB3aGVuIG9uIG9yaWdpbiBkb21haW4gIVxuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUuZ2V0VXJsUGF0aCA9IGZ1bmN0aW9uIChhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmxPbUFwcHNSZWdleCA9IC8oXFwvXFx3K1xcL1xcKFNcXChcXHcrXFwpXFwpKVxcL1xcdysvO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybEFzcEFwcHNSZWdleCA9IC8oXFwvXFx3KylcXC9cXHcrLztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMuJHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmxPbUFwcHNNYXRjaGVzID0gYmFzZVVybE9tQXBwc1JlZ2V4LmV4ZWModXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmxBc3BBcHBzTWF0Y2hlcyA9IGJhc2VVcmxBc3BBcHBzUmVnZXguZXhlYyh1cmwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIDIgbWF0Y2hlcyA9IHJlZ2V4IG1hdGNoZXMgKyB0aGUgY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlVXJsT21BcHBzTWF0Y2hlcyAmJiBiYXNlVXJsT21BcHBzTWF0Y2hlcy5sZW5ndGggJiYgYmFzZVVybE9tQXBwc01hdGNoZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lID0gYmFzZVVybE9tQXBwc01hdGNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gYmFzZVVybE9tQXBwc01hdGNoZXNbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYmFzZVVybEFzcEFwcHNNYXRjaGVzICYmIGJhc2VVcmxBc3BBcHBzTWF0Y2hlcy5sZW5ndGggJiYgYmFzZVVybEFzcEFwcHNNYXRjaGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSA9IGJhc2VVcmxBc3BBcHBzTWF0Y2hlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBiYXNlVXJsQXNwQXBwc01hdGNoZXNbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbklzT25TYW1lQ29udHJvbGxlciAmJiBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiYXNlVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBPTS1zcGVjaWZpYyBBU1AgTVZDIGNvZGUsIG5vdCB1c2VkIEFUTSwgdG8gcmVtb3ZlXG4gICAgICAgICAgICAgICAgLy8gcHJpdmF0ZSBnZXRDdXJyZW50U2Vzc2lvbklEKCk6IHN0cmluZyB7XG4gICAgICAgICAgICAgICAgLy8gICAgIC8vVE9ETyBNR0EgOiBtYWdpYyByZWdleHAgdG8gZmV0Y2ggU2Vzc2lvbklEIGluIFVSTCwgdG8gc3RvcmUgZWxzZXdoZXJlICFcbiAgICAgICAgICAgICAgICAvLyAgICAgdmFyIHNlc3Npb25SZWdleCA9IC9odHRwczpcXC9cXC9bXFx3Ll0rXFwvW1xcdy5dK1xcLyhcXChTXFwoXFx3K1xcKVxcKSlcXC8uKi87XG4gICAgICAgICAgICAgICAgLy8gICAgIC8vdmFyIHNlc3Npb25SZWdleCA9IC9odHRwczpcXC9cXC9bXFx3Ll0rXFwvT3JkZXJFbnRyeVxcLyhcXChTXFwoXFx3K1xcKVxcKSlcXC8uKi87XG4gICAgICAgICAgICAgICAgLy8gICAgIC8vIFRPRE8gTUdBIDogdXBkYXRlIHJlZ2V4cCB0byB0aGUgb25lIGJlbG93XG4gICAgICAgICAgICAgICAgLy8gICAgIC8vdmFyIGJhc2VVcmxSZWdleCA9IC8oaHR0cHM6XFwvXFwvW1xcdy4tXStcXC9bXFx3Li1dK1xcL1xcKFNcXChcXHcrXFwpXFwpXFwvKVxcdysvO1xuICAgICAgICAgICAgICAgIC8vICAgICB2YXIgcGF0aCA9IHRoaXMuJGxvY2F0aW9uLmFic1VybCgpO1xuICAgICAgICAgICAgICAgIC8vICAgICB2YXIgcmVnZXhwQXJyYXkgPSBzZXNzaW9uUmVnZXguZXhlYyhwYXRoKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKCFyZWdleHBBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdVbmFibGUgdG8gcmVjb2duaXplZCBzZWFyY2hlZCBwYXR0ZXJuIGluIGN1cnJlbnQgdXJsIGxvY2F0aW9uIHRvIHJldHJpZXZlIHNlc3Npb25JRC4nKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgICBpZiAocmVnZXhwQXJyYXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ1VuYWJsZSB0byBmaW5kIHNlc3Npb25JRCBpbiBzZWFyY2hlZCBwYXR0ZXJuIGluIGN1cnJlbnQgdXJsLicpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gICAgIGlmIChyZWdleHBBcnJheS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ1RvbyBtYW55IG1hdGNoZXMgZm91bmQgZm9yIHRoZSBzZXNzaW9uSUQgc2VhcmNoIGluIHRoZSBjdXJyZW50IHVybC4nKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gcmVnZXhwQXJyYXlbMV07XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRyaW0gdGhlIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyIHRvIHJldHVybiBvbmx5IHRoZSBmaWxlbmFtZS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY29udGVudERpc3Bvc2l0aW9uSGVhZGVyXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5nZXRGaWxlTmFtZUZyb21IZWFkZXJDb250ZW50RGlzcG9zaXRpb24gPSBmdW5jdGlvbiAoY29udGVudERpc3Bvc2l0aW9uSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGVudERpc3Bvc2l0aW9uSGVhZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlci5zcGxpdCgnOycpWzFdLnRyaW0oKS5zcGxpdCgnPScpWzFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlcGxhY2UoL1wiL2csICcnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBCbHVlc2t5SHR0cFdyYXBwZXI7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgc2VydmljZS5CbHVlc2t5SHR0cFdyYXBwZXIgPSBCbHVlc2t5SHR0cFdyYXBwZXI7XG4gICAgICAgIH0pKHNlcnZpY2UgPSBjb3JlLnNlcnZpY2UgfHwgKGNvcmUuc2VydmljZSA9IHt9KSk7XG4gICAgfSkoY29yZSA9IGJsdWVza3kuY29yZSB8fCAoYmx1ZXNreS5jb3JlID0ge30pKTtcbn0pKGJsdWVza3kgfHwgKGJsdWVza3kgPSB7fSkpO1xuIiwibmFtZXNwYWNlIGJsdWVza3kuY29yZS5zZXJ2aWNlIHtcclxuICAgIGltcG9ydCBVc2VyUm9sZUVudHJ5RHRvID0gYmx1ZXNreS5jb3JlLm1vZGVsLnVzZXJNYW5hZ2VtZW50LklVc2VyUm9sZUVudHJ5RHRvO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXIgZm9yIHRoZSBCbHVlc2t5SHR0cFdyYXBwZXIuXHJcbiAgICAgKiBFbmFibGVzIHBlci1jb25zdW1lciBjb25maWd1cmF0aW9uIG9mIHRoZSBodHRwIHNlcnZpY2UgdG8gc2V0IGN1c3RvbSBjb25maWd1cmF0aW9uIFVSTCB0byBmZXRjaCBkYXRhIGZyb206XHJcbiAgICAgKiAgLSBDbGllbnQgaW5pdGlhbCBjb25maWd1cmF0aW9uIFVSTCBmcm9tIHRoZSBvcmlnaW4gdGhlIGFwcCB3YXMgbG9hZGVkIGZyb20uXHJcbiAgICAgKiAgLSBVc2VyUm9sZSB0byB1c2Ugb2YgYWxyZWFkeSBmZXRjaGVkIGZyb20gYW5vdGhlciBwbGFjZS5cclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIEJsdWVza3lIdHRwV3JhcHBlclByb3ZpZGVyIGltcGxlbWVudHMgbmcuSVNlcnZpY2VQcm92aWRlciB7XHJcblxyXG4gICAgICAgIC8vI3JlZ2lvbiBwcml2YXRlIHByb3BlcnRpZXNcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBnZXRDbGllbnRDb25maWdJbml0aWFsaXphdGlvblVybDogc3RyaW5nID0gJ0JsdWVza3lBamF4Q2xpZW50Q29uZmlndXJhdGlvbi9HZXRBamF4Q2xpZW50Q29uZmlndXJhdGlvbic7IC8vIGJ5IGRlZmF1bHQuXHJcbiAgICAgICAgcHJpdmF0ZSBzZWxlY3RlZFVzZXJSb2xlOiBVc2VyUm9sZUVudHJ5RHRvIHwgdW5kZWZpbmVkOyAvLyBieSBkZWZhdWx0IG5vdC1zZXQuXHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHVibGljIGNvbmZpZ3VyYXRpb24gbWV0aG9kc1xyXG5cclxuICAgICAgICBwdWJsaWMgc2V0Q2xpZW50Q29uZmlnVVJMKGNsaWVudENvbmZpZ1VybFRvVXNlOiBzdHJpbmcgfCB1bmRlZmluZWQpOiB2b2lkIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRDbGllbnRDb25maWdJbml0aWFsaXphdGlvblVybCA9IGNsaWVudENvbmZpZ1VybFRvVXNlIHx8IHRoaXMuZ2V0Q2xpZW50Q29uZmlnSW5pdGlhbGl6YXRpb25Vcmw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc2V0VXNlclJvbGVUb1VzZSh1c2VyUm9sZTogVXNlclJvbGVFbnRyeUR0byB8IHVuZGVmaW5lZCk6IHZvaWQge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkVXNlclJvbGUgPSB1c2VyUm9sZSB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8gUHJvdmlkZXIncyBmYWN0b3J5IGZ1bmN0aW9uXHJcbiAgICAgICAgLyogQG5nSW5qZWN0ICovXHJcbiAgICAgICAgcHVibGljICRnZXQgPSAoXHJcbiAgICAgICAgICAgICRodHRwOiBuZy5JSHR0cFNlcnZpY2UsXHJcbiAgICAgICAgICAgICR3aW5kb3c6IG5nLklXaW5kb3dTZXJ2aWNlLFxyXG4gICAgICAgICAgICAkbG9nOiBuZy5JTG9nU2VydmljZSxcclxuICAgICAgICAgICAgJHE6IG5nLklRU2VydmljZSxcclxuICAgICAgICAgICAgVXBsb2FkOiBuZy5hbmd1bGFyRmlsZVVwbG9hZC5JVXBsb2FkU2VydmljZSxcclxuICAgICAgICAgICAgdG9hc3RlcjogdG9hc3Rlci5JVG9hc3RlclNlcnZpY2UpOiBJQmx1ZXNreUh0dHBXcmFwcGVyID0+IHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmx1ZXNreUh0dHBXcmFwcGVyKCRodHRwLCAkd2luZG93LCAkbG9nLCAkcSwgVXBsb2FkLCB0b2FzdGVyLCB0aGlzLnNlbGVjdGVkVXNlclJvbGUsIHRoaXMuZ2V0Q2xpZW50Q29uZmlnSW5pdGlhbGl6YXRpb25VcmwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhbmd1bGFyLm1vZHVsZSgnYmx1ZXNreS5odHRwV3JhcHBlcicsIFsndG9hc3RlcicsICduZ0FuaW1hdGUnLCAnbmdGaWxlVXBsb2FkJ10pXHJcbiAgICAgICAgLmNvbnN0YW50PF8uVW5kZXJzY29yZVN0YXRpYz4oJ18nLCB3aW5kb3cuXylcclxuICAgICAgICAuY29uc3RhbnQ8bW9tZW50Lk1vbWVudFN0YXRpYz4oJ21vbWVudCcsIHdpbmRvdy5tb21lbnQpXHJcbiAgICAgICAgLnByb3ZpZGVyKCdibHVlc2t5SHR0cFdyYXBwZXInLCBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlcik7XHJcbn0iLCJuYW1lc3BhY2UgYmx1ZXNreS5jb3JlLnNlcnZpY2Uge1xyXG5cclxuICAgIGltcG9ydCBVc2VyUm9sZUVudHJ5RHRvID0gYmx1ZXNreS5jb3JlLm1vZGVsLnVzZXJNYW5hZ2VtZW50LklVc2VyUm9sZUVudHJ5RHRvO1xyXG4gICAgaW1wb3J0IFVzZXJTc29EdG8gPSBibHVlc2t5LmNvcmUubW9kZWwudXNlck1hbmFnZW1lbnQuSVVzZXJTc29EdG87XHJcbiAgICBpbXBvcnQgQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnID0gYmx1ZXNreS5jb3JlLm1vZGVsLmJsdWVza3lIdHRwQ2xpZW50LklCbHVlc2t5SHR0cFJlcXVlc3RDb25maWc7XHJcbiAgICBpbXBvcnQgRmlsZUNvbnRlbnQgPSBibHVlc2t5LmNvcmUubW9kZWwuYmx1ZXNreUh0dHBDbGllbnQuRmlsZUNvbnRlbnQ7XHJcbiAgICBpbXBvcnQgQmx1ZXNreUFqYXhDbGllbnRDb25maWd1cmF0aW9uRHRvID0gYmx1ZXNreS5jb3JlLm1vZGVsLmNsaWVudENvbmZpZy5JQmx1ZXNreUFqYXhDbGllbnRDb25maWd1cmF0aW9uRHRvO1xyXG4gICAgaW1wb3J0IEVuZHBvaW50VHlwZUVudW0gPSBibHVlc2t5LmNvcmUubW9kZWwuY2xpZW50Q29uZmlnLkVuZHBvaW50VHlwZUVudW07XHJcbiAgICAvLyBpbXBvcnQgQWpheENsaWVudEVuZHBvaW50Q29uZmlndXJhdGlvbkR0byA9IGJsdWVza3kuY29yZS5tb2RlbC5jbGllbnRDb25maWcuSUFqYXhDbGllbnRFbmRwb2ludENvbmZpZ3VyYXRpb25EdG87XHJcblxyXG4gICAgZXhwb3J0IGVudW0gSHR0cE1ldGhvZCB7IEdFVCwgUE9TVCwgUFVULCBQQVRDSCwgREVMRVRFIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUT0RPIE1HQSBjb21tZW50XHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgSUJsdWVza3lIdHRwV3JhcHBlciB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFsbCBzcnYtc2lkZSBjb25maWd1cmF0aW9uIG9mIHRoaXMgaHR0cCBjbGllbnQsIHByb3ZpZGVkIGJ5IHRoZSBpbmplY3RlZCAnY29uZmlnSW5pdGlhbGl6YXRpb25VUkwnIGVuZHBvaW50LlxyXG4gICAgICAgICAqIFRoaXMgY29uZmlndXJhdGlvbiBkYXRhIGlzIGxvYWRlZCB1cG9uIGluaXRpYWxpemF0aW9uIG9mIHRoaXMgc2VydmljZSAodG8gYmUgdXNlZCBhcyBhIHNpbmdsZXRvbiBpbiB0aGUgYXBwKS4gQWxsIG90aGVyIHdlYiBjYWxscyBhcmUgYmxvY2tlZCBhcyBsb25nIGFzIHRoaXMgb25lIGlzIG5vdCBmaW5pc2hlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBibHVlc2t5QWpheENsaWVudENvbmZpZzogQmx1ZXNreUFqYXhDbGllbnRDb25maWd1cmF0aW9uRHRvO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9taXNlIHJlc29sdmVkIG9ubHkgb25jZSB0aGUgYWpheENvbmZpZyBoYXMgYmVlbiBjb3JyZWN0bHkgZmV0Y2hlZCBmcm9tIHNlcnZlciAmIHRoZSBjdXJyZW50IHVzZXIgJiB1c2VyIHJvbGUgaGFzIGJlZW4gbG9hZGVkIChpZiBuZWVkZWQpICYgc2V0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEFqYXhDb25maWdGcm9tU2VydmVyUHJvbWlzZTogbmcuSVByb21pc2U8Qmx1ZXNreUFqYXhDbGllbnRDb25maWd1cmF0aW9uRHRvPjtcclxuXHJcbiAgICAgICAgZ2V0PFQ+KHVybDogc3RyaW5nLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuXHJcbiAgICAgICAgZGVsZXRlPFQ+KHVybDogc3RyaW5nLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuXHJcbiAgICAgICAgcG9zdDxUPih1cmw6IHN0cmluZywgZGF0YTogYW55LCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuXHJcbiAgICAgICAgcHV0PFQ+KHVybDogc3RyaW5nLCBkYXRhOiBhbnksIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklQcm9taXNlPFQ+O1xyXG5cclxuICAgICAgICBwYXRjaDxUPih1cmw6IHN0cmluZywgZGF0YTogYW55LCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuXHJcbiAgICAgICAgdXBsb2FkPFQ+KHVybDogc3RyaW5nLCBmaWxlOiBGaWxlLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuXHJcbiAgICAgICAgZ2V0RmlsZSh1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8RmlsZUNvbnRlbnQ+O1xyXG5cclxuICAgICAgICBidWlsZFVybEZyb21Db250ZXh0KHVybElucHV0OiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGNsYXNzIEJsdWVza3lIdHRwV3JhcHBlciBpbXBsZW1lbnRzIElCbHVlc2t5SHR0cFdyYXBwZXIge1xyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHJvcGVydGllc1xyXG5cclxuICAgICAgICBwdWJsaWMgZ2V0QWpheENvbmZpZ0Zyb21TZXJ2ZXJQcm9taXNlOiBuZy5JUHJvbWlzZTxCbHVlc2t5QWpheENsaWVudENvbmZpZ3VyYXRpb25EdG8+O1xyXG5cclxuICAgICAgICBwdWJsaWMgYmx1ZXNreUFqYXhDbGllbnRDb25maWc6IEJsdWVza3lBamF4Q2xpZW50Q29uZmlndXJhdGlvbkR0bztcclxuXHJcbiAgICAgICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgICAgIC8vI3JlZ2lvbiBjdG9yXHJcblxyXG4gICAgICAgIC8qIEBuZ0luamVjdCAqL1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgICAgICBwcml2YXRlICRodHRwOiBuZy5JSHR0cFNlcnZpY2UsXHJcbiAgICAgICAgICAgIHByaXZhdGUgJHdpbmRvdzogbmcuSVdpbmRvd1NlcnZpY2UsXHJcbiAgICAgICAgICAgIHByaXZhdGUgJGxvZzogbmcuSUxvZ1NlcnZpY2UsXHJcbiAgICAgICAgICAgIHByaXZhdGUgJHE6IG5nLklRU2VydmljZSxcclxuICAgICAgICAgICAgcHJpdmF0ZSBVcGxvYWQ6IG5nLmFuZ3VsYXJGaWxlVXBsb2FkLklVcGxvYWRTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlIHRvYXN0ZXI6IHRvYXN0ZXIuSVRvYXN0ZXJTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlIHNlbGVjdGVkVXNlclJvbGU6IFVzZXJSb2xlRW50cnlEdG8gfCB1bmRlZmluZWQsXHJcblxyXG4gICAgICAgICAgICBjb25maWdJbml0aWFsaXphdGlvblVSTDogc3RyaW5nXHJcblxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICAvLyAxIC0gZmV0Y2ggdGhlIGNvbmZpZ3VyYXRpb24gZGF0YSBuZWNlc3NhcnkgZm9yIHRoaXMgc2VydmljZSB0byBydW4gZnJvbSB0aGUgcHJvdmlkZWQgZW5kcG9pbnRcclxuXHJcbiAgICAgICAgICAgIGxldCBjb25maWd1cmF0aW9uRW5kcG9pbnRVcmwgPSB0aGlzLmJ1aWxkVXJsRnJvbUNvbnRleHQoY29uZmlnSW5pdGlhbGl6YXRpb25VUkwsIEVuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbik7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb25FbmRwb2ludFVybCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKGBbQmx1ZXNreUh0dHBXcmFwcGVyXVtJbml0aWFsaXphdGlvbl0gLSBVbmFibGUgdG8gYnVpbGQgdXJsIGZyb20gaW5pdGlhbENvbmZpZyB1cmwgJyR7Y29uZmlnSW5pdGlhbGl6YXRpb25VUkx9JyB3aXRoIGVuZHBvaW50VHlwZSAnJHtFbmRwb2ludFR5cGVFbnVtW0VuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbl19Jy4gQWJvcnRpbmcgYmx1ZXNreUh0dHBTZXJ2aWNlIGluaXQuYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IGN1c3RvbSBjb25maWcgZm9yIGhlYWRlcnMgaGFyZCBjb2RlZCwgdG8gbXV0dWFsaXplIHdpdGggY29uc3RcclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogbG9nIHByb3Blcmx5IGFzIG90aGVyIGFqYXggY2FsbHNcclxuICAgICAgICAgICAgdGhpcy5nZXRBamF4Q29uZmlnRnJvbVNlcnZlclByb21pc2UgPVxyXG4gICAgICAgICAgICAgICAgdGhpcy4kaHR0cFxyXG4gICAgICAgICAgICAgICAgICAgIC5nZXQ8Qmx1ZXNreUFqYXhDbGllbnRDb25maWd1cmF0aW9uRHRvPihjb25maWd1cmF0aW9uRW5kcG9pbnRVcmwsIHsgaGVhZGVyczogeyAnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCcgfSB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChjbGllbnRDb25maWdQcm9taXNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiByZWplY3Qgc3RhdHVzIG5vdCBpbiAyWFggP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjbGllbnRDb25maWdQcm9taXNlLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gYFtCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIFVuYWJsZSB0byByZXRyaWV2ZSBodHRwIGNvbmZpZyBkYXRhIGZyb20gJyR7Y29uZmlnSW5pdGlhbGl6YXRpb25VUkx9Jy4gQWJvcnRpbmcgICAgICAgICAgICAgICBibHVlc2t5SHR0cFdyYXBwZXJTZXJ2aWNlIGluaXRpYWxpemF0aW9uLmA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogdG9hc3RlciA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMuJHEucmVqZWN0KG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmluZm8oJ1tCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIFN1Y2Nlc3NmdWxseSBsb2FkZWQgY2xpZW50Q29uZmlnIGZyb20gc3J2OicsIGNsaWVudENvbmZpZ1Byb21pc2UuZGF0YSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZyA9IGNsaWVudENvbmZpZ1Byb21pc2UuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnRDb25maWdQcm9taXNlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChlcnJvcjogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbXNnID0gJ1tCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIFVuYWJsZSB0byByZXRyaWV2ZSBBUEkgY29uZmlnLiBBYm9ydGluZyBibHVlc2t5SHR0cFdyYXBwZXJTZXJ2aWNlIGluaXRpYWxpemF0aW9uLic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IobXNnICsgJ09yaWdpbmFsIG1zZzogJywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogc2hvdyB0b2FzdGVyID8gYmFzZWQgb24gcHJvdmlkZXIgY29uZmlnIGZsYWcgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zdWNjZXNzLCBnZXQgdXNlclNTTyBmcm9tIGNhcGkgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsdWVza3lDbGllbnRDb25maWcgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibHVlc2t5Q2xpZW50Q29uZmlnLkN1cnJlbnRVc2VyUm9sZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVXNlclJvbGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2VsZWN0ZWRVc2VyUm9sZS5OYW1lICsgJyAnICsgc2VsZWN0ZWRVc2VyUm9sZS5Sb2xlICsgJyAnICsgc2VsZWN0ZWRVc2VyUm9sZS5TaWxvKSAhPT0gYmx1ZXNreUNsaWVudENvbmZpZy5DdXJyZW50VXNlclJvbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIGNsaWVudCAmIHNydi1zaWRlIHNlbGVjdGVkIHVzZXIgcm9sZXMgcHJvdmlkZWQgYnV0IHRoZXkgZGlmZmVyLiBpbnRlcm5hbCBlcnJvciB0byBmaXguJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFibHVlc2t5Q2xpZW50Q29uZmlnLkN1cnJlbnRVc2VyUm9sZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgbm90IHByb3ZpZGVkIGJ5IGRvbWFpbiBmcm9tIHdoaWNoIGNvZGUgd2FzIGxvYWRlZCwgdGhlbiB0cnkgdG8gZmV0Y2ggZGVmYXVsdCB1c2VyUm9sZSBmcm9tIENBUEkgZW5kcG9pbnRcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmluZm8oJ1tCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIE5vIGRlZmF1bHQgVXNlclJvbGUgcHJvdmlkZWQgYnkgY3VycmVudCBkb21haW4sIHRyeWluZyB0byBmZXRjaCBpdCBmcm9tIENBUEkuJyk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29yZUFwaUNvbmZpZyA9IGJsdWVza3lDbGllbnRDb25maWcuRW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnlbRW5kcG9pbnRUeXBlRW51bVtFbmRwb2ludFR5cGVFbnVtLkNvcmVBcGldXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb3JlQXBpQ29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtc2cgPSAnW0JsdWVza3lIdHRwV3JhcHBlcl1bSW5pdGlhbGl6YXRpb25dIC0gRmFpbGVkIHRvIHJldHJpZXZlIG5lY2Vzc2FyeSBDb3JlQXBpIGVuZHBvaW50IGNvbmZpZyB0byBmZXRjaCB1c2VyU1NPLiBBYm9ydGluZy4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBmYWN0b3JpemUgd2l0aCBjb25maWd1cmVIdHRwQ2FsbCgpICEhIHRoaXMgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgd2UgY2Fubm90IHVzZSBhamF4KCkgRFJZIG1ldGhvZCAuLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VzdG9tQ29uZmlnID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgJyArIGNvcmVBcGlDb25maWcuQXV0aFRva2VuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZ2V0VXNlclNzb0Z1bGxVcmwgPSB0aGlzLmJ1aWxkVXJsRnJvbUNvbnRleHQoJ3VzZXItc3NvP3Byb2ZpbGU9JywgRW5kcG9pbnRUeXBlRW51bS5Db3JlQXBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFnZXRVc2VyU3NvRnVsbFVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbXNnID0gJ1tCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIEZhaWxlZCB0byBjb25zdHJ1Y3QgdXNlclNTTyB1cmwgZm9yIGNhcGkuIEFib3J0aW5nLic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihtc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGxvZyBwcm9wZXJseSBhcyBvdGhlciBhamF4IGNhbGxzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGh0dHAuZ2V0PFVzZXJTc29EdG8+KGdldFVzZXJTc29GdWxsVXJsLCBjdXN0b21Db25maWcpLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc3VjY2Vzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyU3NvUHJvbWlzZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJTc29Qcm9taXNlIHx8ICF1c2VyU3NvUHJvbWlzZS5kYXRhIHx8ICF1c2VyU3NvUHJvbWlzZS5kYXRhLlVzZXJSb2xlRW50cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29yZUFwaUNvbmZpZ01pc3NpbmdNc2cgPSAnW0JsdWVza3lIdHRwV3JhcHBlcl1bSW5pdGlhbGl6YXRpb25dIC0gVW5hYmxlIHRvIHJldHJpZXZlIENvcmVBUEkgZGVmYXVsdCB1c2VyU1NPLiBBYm9ydGluZyBodHRwV3JhcHBlclNlcnZpY2UgaW5pdGlhbGl6YXRpb24uJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoY29yZUFwaUNvbmZpZ01pc3NpbmdNc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjb3JlQXBpQ29uZmlnTWlzc2luZ01zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyU3NvUHJvbWlzZS5kYXRhLlVzZXJEaXNwbGF5TmFtZSB8fCAhdXNlclNzb1Byb21pc2UuZGF0YS5Vc2VySWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub1VzZXJJZE1zZyA9ICdbQmx1ZXNreUh0dHBXcmFwcGVyXVtJbml0aWFsaXphdGlvbl0gLSBDb3JlQVBJIHVzZXJTU08gaXMgbm90IGZ1bGx5IHBvcHVsYXRlZDogdW5hYmxlIHRvIHJldHJpZXZlIFVzZXJJZGVudGlmaWVyIG9yIERpc3BsYXlOYW1lLiBBYm9ydGluZyBodHRwV3JhcHBlclNlcnZpY2UgaW5pdGlhbGl6YXRpb24uJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3Iobm9Vc2VySWRNc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihub1VzZXJJZE1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHVzZXJTc28gPSB1c2VyU3NvUHJvbWlzZS5kYXRhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5pbmZvKGBbQmx1ZXNreUh0dHBXcmFwcGVyXVtJbml0aWFsaXphdGlvbl0gLSBEZWZhdWx0IHVzZXJTU08gbG9hZGVkIGZyb20gQ0FQSTogJyR7dXNlclNzby5Vc2VyRGlzcGxheU5hbWV9Jy5gLCB1c2VyU3NvKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRVc2VyUm9sZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuaW5mbyhgW0JsdWVza3lIdHRwV3JhcHBlcl1bSW5pdGlhbGl6YXRpb25dIC0gQ2xpZW50IGFwcCBwcm92aWRlZCBwZXJzaXN0ZWQgVXNlclJvbGUuIEFzc2lnbmluZyBpdC5gLCB0aGlzLnNlbGVjdGVkVXNlclJvbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IG1ha2Ugc3VyZSBzZWxlY3RlZFVzZXJSb2xlIGlzIGF2YWlsYWJsZSBpbiB0aGUgbGlzdCBvZiB1c2VyU1NPIHJvbGVzLCBvdGhlcndpc2Ugc2VsZWN0IGRlZmF1bHQgIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaG93IHRvIGluZm9ybSBiYWNrIHRoZSBEQSB0aGF0IHNlbGVjdGVkVXNlclJvbGUgd2FzIHJlc2V0ID8gaW52ZXJ0IHJlc3BvbnNhYmlsaXR5ICYgc3RvcmUgdXNlclJvbGUgaW4gbG9jYWxTdG9yYWdlIGZyb20gdGhpcyBzZXJ2aWNlID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1c2VyUm9sZVRvVXNlID0gc2VsZWN0ZWRVc2VyUm9sZSB8fCB1c2VyU3NvLlVzZXJSb2xlRW50cnk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogdGhpcyBuZWVkcyB0byBiZSBwdXQgaW4gc2hhcmVkIGV4dGVuc2lvbiBtZXRob2QgLyBzZXJ2aWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLkN1cnJlbnRVc2VyUm9sZSA9IHVzZXJSb2xlVG9Vc2UuTmFtZSArIFwiIFwiICsgdXNlclJvbGVUb1VzZS5Sb2xlICsgXCIgXCIgKyB1c2VyUm9sZVRvVXNlLlNpbG87XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5DdXJyZW50VXNlciA9IHVzZXJTc287XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsdWVza3lDbGllbnRDb25maWc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVycm9yOiBhbnkpOiBuZy5JUHJvbWlzZTxuZXZlcj4gPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtc2cgPSAnW0JsdWVza3lIdHRwV3JhcHBlcl1bSW5pdGlhbGl6YXRpb25dIC0gVW5hYmxlIHRvIHJldHJpZXZlIHVzZXIgU1NPIGZyb20gY2FwaS4gUHJvYmFibHkgZHVlIHRvIGludmFsaWQgY2VydGlmaWNhdGVzIHByZXZlbnRpbmcgdXMgdG8gY29tbXVuaWNhdGUgd2l0aCBDQVBJLiBBYm9ydGluZy4nO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihtc2cgKyAnIE9yaWdpbmFsIG1zZzonLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBzaG93IHRvYXN0ZXIgPyBiYXNlZCBvbiBwcm92aWRlciBjb25maWcgZmxhZyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiB3ZSBvbmx5IGxvYWQgdXNlclNTTyBpZiBubyB1c2VyUm9sZSB3YXMgcHJvdmlkZWQgc3J2LXNpZGUsIHNob3VsZCB3ZSBsb2FkIGl0IGluIGFsbCBjYXNlcyA/XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgZGVmaW5lZCB1c2VyUm9sZSBzZW50IGZyb20gb3JpZ2luIGFwcCwgdXNlIGl0ICYgc2V0IGl0IGFzIGRlZmF1bHQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsdWVza3lDbGllbnRDb25maWc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvL2Vycm9yXHJcbiAgICAgICAgICAgIC8vIChlcnJvcjogYW55KTogbmcuSVByb21pc2U8bmV2ZXI+ID0+IHtcclxuICAgICAgICAgICAgLy8gICAgIC8vVE9ETyBNR0E6IHNob3VsZCBub3QgYmUgbmVlZGVkLCBmYWlsIGNhc2UgaXQgY29uc3VtZXIgcHJvbWlzZXNcclxuICAgICAgICAgICAgLy8gfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8jcmVnaW9uIHB1YmxpYyBtZXRob2RzXHJcblxyXG4gICAgICAgIHB1YmxpYyBnZXQ8VD4odXJsOiBzdHJpbmcsIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheDxUPihIdHRwTWV0aG9kLkdFVCwgdXJsLCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGRlbGV0ZTxUPih1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuREVMRVRFLCB1cmwsIGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgcG9zdDxUPih1cmw6IHN0cmluZywgZGF0YTogYW55LCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBkYXRhIHx8IGNvbmZpZy5kYXRhOztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheDxUPihIdHRwTWV0aG9kLlBPU1QsIHVybCwgY29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBwdXQ8VD4odXJsOiBzdHJpbmcsIGRhdGE6IGFueSwgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD4ge1xyXG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XHJcbiAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gZGF0YSB8fCBjb25maWcuZGF0YTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheDxUPihIdHRwTWV0aG9kLlBVVCwgdXJsLCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHBhdGNoPFQ+KHVybDogc3RyaW5nLCBkYXRhOiBhbnksIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgICAgICAgICBjb25maWcuZGF0YSA9IGRhdGEgfHwgY29uZmlnLmRhdGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXg8VD4oSHR0cE1ldGhvZC5QQVRDSCwgdXJsLCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVE9ETyBNR0E6IG5vdCBEUlkgd2l0aCBhamF4IG1ldGhvZCwgaG93IHRvIGtlZXAgaXQgaW4gc3luYyA/XHJcbiAgICAgICAgICogQHBhcmFtIHVybFxyXG4gICAgICAgICAqIEBwYXJhbSBmaWxlXHJcbiAgICAgICAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyB1cGxvYWQ8VD4odXJsOiBzdHJpbmcsIGZpbGU6IEZpbGUsIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHwgbmcuSVByb21pc2U8bmV2ZXI+IHtcclxuXHJcbiAgICAgICAgICAgIGlmICghZmlsZSAmJiAoIWNvbmZpZyB8fCAhY29uZmlnLmZpbGUpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbXNnID0gJ0Nhbm5vdCBzdGFydCB1cGxvYWQgd2l0aCBudWxsIHtmaWxlfSBwYXJhbWV0ZXIuJztcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihtc2cpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KG1zZyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgICAgICAgICAgY29uZmlnLmZpbGUgPSBmaWxlIHx8IGNvbmZpZy5maWxlOyAvL1RPRE8gTUdBIDogZG8gbm90IGV4cG9zZSBmaWxlIGluIElCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcgP1xyXG4gICAgICAgICAgICBjb25maWcuZGF0YSA9IGNvbmZpZy5kYXRhIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy51cGxvYWRJbkJhc2U2NEpzb24pIHtcclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IG1ha2Ugc3VyZSB0aGlzIGRlbGF5cyBuZXh0IGNhbGwgYW5kIHVwbG9hZCBpcyBub3QgZG9uZSBiZWZvcmUgYmFzZTY0IGVuY29kaW5nIGlzIGZpbmlzaGVkLCBldmVuIGlmIHByb21pc2UgaXMgYWxyZWFkeSByZXNvbHZlZCA/Pz9cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlVwbG9hZC5iYXNlNjREYXRhVXJsKGZpbGUpLnRoZW4oKGZpbGVCYXNlNjRVcmwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkLWNvZGVkIGtleSB0byBmZXRjaCBiYXNlNjQgZW5jb2RpbmcsIHRvIHBhcmFtZXRyaXplIHdpdGggc2VydmVyLXNpZGUgIVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLmRhdGEpIGNvbmZpZy5kYXRhLmZpbGVCYXNlNjRVcmwgPSBmaWxlQmFzZTY0VXJsOyAvL1RPRE8gTUdBIHNob3VsZCBub3QgaGF2ZSB0byBoYW5kbGUgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vbm9ybWFsIHBvc3QgaW4gY2FzZSBvZiBiYXNlNjQtZW5jb2RlZCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheDxUPihIdHRwTWV0aG9kLlBPU1QsIHVybCwgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLmRhdGEuZmlsZUZvcm1EYXRhTmFtZSA9ICdmaWxlJzsgLy8gZmlsZSBmb3JtRGF0YSBuYW1lICgnQ29udGVudC1EaXNwb3NpdGlvbicpLCBzZXJ2ZXIgc2lkZSByZXF1ZXN0IGZvcm0gbmFtZVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBkbyBub3QgYmxvY2sgaWYgbm90IGNhbGwgdG8gaW50ZXJuYWwgQVBJID8gKGluaXRDYWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWpheENvbmZpZ0Zyb21TZXJ2ZXJQcm9taXNlLnRoZW4oKCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgYmx1ZXNreUNvbmZpZyA9IHRoaXMuc2V0dXBCbHVlc2t5Q29uZmlnKGNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFuZ3VsYXJDb25maWcgPSB0aGlzLmV4dHJhY3RBbmd1bGFyQ29uZmlnRnJvbUJsdWVza3lDb25maWcoSHR0cE1ldGhvZC5QT1NULCB1cmwsIGJsdWVza3lDb25maWcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFuZ3VsYXJDb25maWcgfHwgIWJsdWVza3lDb25maWcpIHsgLy8gaWYgbm8gY29uZmlnIHJldHVybmVkLCBjb25maWd1cmF0aW9uIGZhaWxlZCwgZG8gbm90IHN0YXJ0IGFqYXggcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QoJ1tibHVlc2t5SHR0cFdyYXBwZXItQWpheENhbGxdIHVuYWJsZSB0byBjb25maWd1cmUgY29ycmVjdGx5IGFuZ3VsYXIgY29uZmlnIG9iamVjdCBuZWNlc3NhcnkgZm9yIGFqYXggY2FsbC4gYWJvcnRpbmcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5VcGxvYWQudXBsb2FkPFQ+KDxuZy5hbmd1bGFyRmlsZVVwbG9hZC5JRmlsZVVwbG9hZENvbmZpZ0ZpbGU+YW5ndWxhckNvbmZpZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU3VjY2VzczxUPihibHVlc2t5Q29uZmlnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihibHVlc2t5Q29uZmlnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb25maWcgJiYgY29uZmlnLnVwbG9hZFByb2dyZXNzKSA/IGNvbmZpZy51cGxvYWRQcm9ncmVzcyA6IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8uY2F0Y2ggVE9ETyBNR0EgaGFuZGxlIGNhdGNoIGNsYXVzZSBpZiBleGNlcHRpb24gaW4gc3VjY2VzcyBvciBlcnJvciBjYWxsYmFjayAhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KHRoaXMuZmluYWxseSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBkb3dubG9hZCBhIGZpbGUgaW4gdGhlIGZvcm0gb2YgYSBieXRlLXN0cmVhbSBmcm9tIGFuIGVuZHBvaW50IGFuZCB3cmFwIGl0IGludG8gYSBGaWxlQ29udGVudCBvYmplY3Qgd2l0aCBuYW1lLCB0eXBlICYgc2l6ZSBwcm9wZXJ0aWVzIHJlYWQgZnJvbSB0aGUgSFRUUCByZXNwb25zZSBoZWFkZXJzIG9mIHRoZSBzZXJ2ZXVyLlxyXG4gICAgICAgICAqIEl0IGlzIHRoZSByZXNwb25zYWJpbGl0eSBvZiB0aGUgY29uc3VtZXIgdG8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHdyYXBwZWQgYnl0ZUFycmF5IChmb3IgZXhhbXBsZSBkb3dubG9hZCB0aGUgZmlsZSwgb3Igc2hvdyBpdCBpbnNpZGUgdGhlIHdlYlBhZ2UgZXRjKS5cclxuICAgICAgICAgKiBUT0RPIE1HQTogbm90IERSWSB3aXRoIGFqYXggbWV0aG9kLCBob3cgdG8ga2VlcCBpdCBpbiBzeW5jID9cclxuICAgICAgICAgKiBAcGFyYW0gdXJsXHJcbiAgICAgICAgICogQHBhcmFtIGV4cGVjdGVkTmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSBleHBlY3RlZFNpemVcclxuICAgICAgICAgKiBAcGFyYW0gZXhwZWN0ZWRUeXBlXHJcbiAgICAgICAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEZpbGUodXJsOiBzdHJpbmcsIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklQcm9taXNlPEZpbGVDb250ZW50PiB8IG5nLklQcm9taXNlPG5ldmVyPiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFqYXhDb25maWdGcm9tU2VydmVyUHJvbWlzZS50aGVuKCgpID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgYmx1ZXNreUNvbmZpZyA9IHRoaXMuc2V0dXBCbHVlc2t5Q29uZmlnKGNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgYW5ndWxhckNvbmZpZyA9IHRoaXMuZXh0cmFjdEFuZ3VsYXJDb25maWdGcm9tQmx1ZXNreUNvbmZpZyhIdHRwTWV0aG9kLkdFVCwgdXJsLCBibHVlc2t5Q29uZmlnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWFuZ3VsYXJDb25maWcgfHwgIWJsdWVza3lDb25maWcpIHsgLy8gaWYgbm8gY29uZmlnIHJldHVybmVkLCBjb25maWd1cmF0aW9uIGZhaWxlZCwgZG8gbm90IHN0YXJ0IGFqYXggcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRxLnJlamVjdCgnW2JsdWVza3lIdHRwV3JhcHBlci1BamF4Q2FsbF0gdW5hYmxlIHRvIGNvbmZpZ3VyZSBjb3JyZWN0bHkgYW5ndWxhciBjb25maWcgb2JqZWN0IG5lY2Vzc2FyeSBmb3IgYWpheCBjYWxsLiBhYm9ydGluZy4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpY2FsbHkgZXhwZWN0IHJhdyByZXNwb25zZSB0eXBlLCBvdGhlcndpc2UgYnl0ZSBzdHJlYW0gcmVzcG9uc2VzIGFyZSBjb3JydXB0ZWQuXHJcbiAgICAgICAgICAgICAgICBhbmd1bGFyQ29uZmlnLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9FeHBlY3RlZCBBcnJheUJ1ZmZlciByZXNwb25zZSA9IGJ5dGUgYXJyYXlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRodHRwPEFycmF5QnVmZmVyPihhbmd1bGFyQ29uZmlnKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9iZW5lZml0IGZyb20gc3VjY2Vzc0NhbGxiYWNrIHZhbGlkYXRpb24gYmVmb3JlIGNvbnRpbnVpbmdcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgdW5kZXJzdGFuZCB3aHkgVFMgdmFsaWRhdGlvbiBkb2Vzbid0IGNhdGNoIGFib3ZlIGlmIGNsYXVzZSB0byB2YWxpZGF0ZSBibHVlc2t5Q29uZmlnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmx1ZXNreUNvbmZpZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRxLnJlamVjdCgnW2JsdWVza3lIdHRwV3JhcHBlci1BamF4Q2FsbF0gdW5hYmxlIHRvIGNvbmZpZ3VyZSBjb3JyZWN0bHkgYW5ndWxhciBjb25maWcgb2JqZWN0IG5lY2Vzc2FyeSBmb3IgYWpheCBjYWxsLiBhYm9ydGluZy4nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhcnJheUJ1ZmZlciA9IHRoaXMub25TdWNjZXNzPEFycmF5QnVmZmVyPihibHVlc2t5Q29uZmlnKShodHRwUmVzcG9uc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogcHJvbWlzZSByZWplY3Rpb24gdnMuIHJldHVybiBudWxsID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnJheUJ1ZmZlcikgdGhyb3cgbmV3IEVycm9yKCdbQmx1ZXNreUh0dHBXcmFwcGVyLWdldEZpbGVdIC0gdW5hYmxlIHRvIHJldHJpZXZlIGJ5dGUgYXJyYXkuJyk7IC8vc3RvcCBwcm9jZXNzaW5nIGlmIHVuYWJsZSB0byByZXRyaWV2ZSBieXRlIGFycmF5XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JlYWQgZmlsZSBpbmZvIGZyb20gcmVzcG9uc2UtaGVhZGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZUNvbnRlbnQ6IEZpbGVDb250ZW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5nZXRGaWxlTmFtZUZyb21IZWFkZXJDb250ZW50RGlzcG9zaXRpb24oaHR0cFJlc3BvbnNlLmhlYWRlcnMoJ2NvbnRlbnQtZGlzcG9zaXRpb24nKSkgfHwgJ3Vua25vd24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogTnVtYmVyKGh0dHBSZXNwb25zZS5oZWFkZXJzKCdjb250ZW50LWxlbmd0aCcpKSB8fCAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogaHR0cFJlc3BvbnNlLmhlYWRlcnMoJ2NvbnRlbnQtdHlwZScpIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogYXJyYXlCdWZmZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlQ29udGVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKGJsdWVza3lDb25maWcpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KHRoaXMuZmluYWxseSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJpZXMgdG8gcGFyc2UgdGhlIGlucHV0IHVybCA6XHJcbiAgICAgICAgICogSWYgaXQgc2VlbXMgdG8gYmUgYSBmdWxsIFVSTCwgdGhlbiByZXR1cm4gYXMgaXMgKGNvbnNpZGVycyBpdCBleHRlcm5hbCBVcmwpIFxyXG4gICAgICAgICAqIE90aGVyd2lzZSwgdHJpZXMgdG8gZmluZCB0aGUgYmFzZSBVUkwgb2YgdGhlIGN1cnJlbnQgQmx1ZVNreSBhcHAgd2l0aCBvciB3aXRob3V0IHRoZSBpbmNsdWRlZCBDb250cm9sbGVyIGFuZCByZXR1cm5zIHRoZSBmdWxsIFVybCBcclxuICAgICAgICAgKiBAcGFyYW0gdXJsSW5wdXQgOiBUT0RPIE1HQTogZG9jdW1lbnQgZGlmZmVyZW50IGtpbmQgb2YgdXJscyB0aGF0IHRoaXMgbWV0aG9kIGNhbiB0YWtlIGFzIGlucHV0IChmdWxsLCBwYXJ0aWFsIGV0YylcclxuICAgICAgICAgKiBAcmV0dXJuIG51bGwgaWYgbm90IGFibGUgdG8gY29tcHV0ZSB1cmwuIE90aGVyd2lzZSwgdXJsIG9mIHRoZSByZXF1ZXN0IGVpdGhlciBwYXJ0aWFsIG9yIGZ1bGwgYmFzZWQgb24gZW5kcG9pbnRUeXBlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyBidWlsZFVybEZyb21Db250ZXh0KHVybElucHV0OiBzdHJpbmcsIGVuZHBvaW50VHlwZT86IEVuZHBvaW50VHlwZUVudW0pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG5cclxuICAgICAgICAgICAgaWYgKCF1cmxJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdObyBVUkwgaW5wdXQgcHJvdmlkZWQuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBVcmwgc3RhcnRzIHdpdGggaHR0cDovLyBvciBodHRwczovLyA9PiByZXR1cm4gYXMgaXMsIGV2ZW4gaWYgZW5kcG9pbnRUeXBlIGlzIG5vdCBleHRlcm5hbC5cclxuICAgICAgICAgICAgaWYgKHVybElucHV0LnNsaWNlKDAsICdodHRwOi8vJy5sZW5ndGgpID09PSAnaHR0cDovLycgfHxcclxuICAgICAgICAgICAgICAgIHVybElucHV0LnNsaWNlKDAsICdodHRwczovLycubGVuZ3RoKSA9PT0gJ2h0dHBzOi8vJykge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlbmRwb2ludFR5cGUgIT09IEVuZHBvaW50VHlwZUVudW0uRXh0ZXJuYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLndhcm4oJ0Z1bGwgVVJMIHByb3ZpZGVkIGZvciBhIGNhbGwgdGhhdCBpcyBub3QgZmxhZ2dlZCBhcyBcXCdFeHRlcm5hbFxcJyBlbmRwb2ludFR5cGUsIHRoaXMgaXMgYmFkIHByYWN0aWNlIGFzIG9ubHkgdGhlIGJsdWVza3lXcmFwcGVyIHNob3VsZCBrbm93IGFib3V0IHRoZSBiYXNlVVJMIG9mIHRhcmdldCBlbmRwb2ludHMgKGxvYWRlZCBmcm9tIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IGVudikuIFVzZSBwYXJ0aWFsIFVSTHMuJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybElucHV0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBFbHNlLCB3ZSBoYXZlIGEgcGFydGlhbCBVUkwgdG8gY29tcGxldGU6IHVzZSBwcm92aWRlZCBlbmRwb2ludCB0eXBlIHRvIGRldGVybWluZSBob3cgdG8gY29tcGxldGUgdXJsLlxyXG5cclxuICAgICAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZSBmb3IgZW5kcG9pbnRUeXBlIGlmIG5vdCBwcm92aWRlZCBpcyBvcmlnaW4uIFRPRE8gTUdBOiBydWxlIHRvIGRpc2N1c3MsIGhlcmUgZm9yIHJldHJvLWNvbXBhdGliaWxpdHkuXHJcbiAgICAgICAgICAgIGVuZHBvaW50VHlwZSA9IGVuZHBvaW50VHlwZSB8fCBFbmRwb2ludFR5cGVFbnVtLkN1cnJlbnREb21haW47XHJcblxyXG4gICAgICAgICAgICBsZXQgYmFzZVVybDogc3RyaW5nO1xyXG5cclxuICAgICAgICAgICAgaWYgKGVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlRW51bS5FeHRlcm5hbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLndhcm4oJ1BhcnRpYWwgdXJsIHByb3ZpZGVkIGZvciBhIGNhbGwgd2l0aCBlbmRwb2ludFR5cGUgZmxhZ2dlZCBhcyBcXCdFeHRlcm5hbFxcJzogdGhlIGNhbGwgd2lsbCBwcm9iYWJseSBmYWlsLicpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBtb2RpZnkgcHJvdmlkZWQgdXJsIGlmIGV4dGVybmFsICh3ZSBjYW5ub3Qga25vdyBob3cgdG8gY29tcGxldGUgaXQsIGV2ZW4gaWYgcGFydGlhbCkuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsSW5wdXQ7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogbm90IGxvYWRpbmcgdGhlIGVuZHBvaW50Q29uZmlnIGZvciBjdXJyZW50IGRvbWFpbiBtZWFucyB3ZSBjYW4ndCBhY2Nlc3MgZW5kcG9pbnRBUElzdWZmaXggaWYgaXQgZXhpc3RzLCBzaG91bGQgd2UgbG9hZCB0aGUgZW5kcG9pbnRDb25maWcgZm9yIHRoaXMgY2FzZSB0b28gPz8gJiBoYW5kbGUgaXQgdGhlIHNhbWUgd2F5IGFzIG90aGVyIGVuZHBvaW50cyA/XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVnZXggdHJ5aW5nIHRvIGRldGVybWluZSBpZiB0aGUgaW5wdXQgZnJhZ21lbnQgY29udGFpbnMgYSAvIGJldHdlZW4gdHdvIGNoYXJhY3RlciBzdWl0ZXMgPT4gY29udHJvbGxlciBnaXZlbiBhcyBpbnB1dCwgb3RoZXJ3aXNlLCBhY3Rpb24gb24gc2FtZSBjb250cm9sbGVyIGV4cGVjdGVkXHJcbiAgICAgICAgICAgICAgICBsZXQgY29udHJvbGxlcklzUHJlc2VudFJlZ2V4ID0gL1xcdytcXC9cXHcrLztcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgYWN0aW9uSXNPblNhbWVDb250cm9sbGVyID0gIWNvbnRyb2xsZXJJc1ByZXNlbnRSZWdleC50ZXN0KHVybElucHV0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBiYXNlVXJsID0gdGhpcy5nZXRVcmxQYXRoKGFjdGlvbklzT25TYW1lQ29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgYWxsIG90aGVyIGVuZHBvaW50VHlwZXM6IGNvbXB1dGUgVVJMIGFzIGEgY29tYmluYXRpb24gb2YgYmFzZVVSTCAmIHN1ZmZpeCBpZiBwcmVzZW50LCBhcyBwcm92aWRlZCBieSBzZXJ2ZXItY29uZmlndXJhdGlvbi5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcgfHxcclxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5FbmRwb2ludENvbmZpZ3VyYXRpb25EaWN0aW9ubmFyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignRXhwZWN0ZWQgZW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnkgcHJvdmlkZWQgYnV0IG5vbmUgZm91bmQuIEFib3J0aW5nLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBNR0EgSEFDS1k6IHNlYXJjaCBieSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZW5kcG9pbnQgdHlwZSBpbiBkaWN0IGR1ZSB0byBzZXJpYWxpemF0aW9uIGxpbWl0c1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZHBvaW50Q29uZmlnID0gdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5FbmRwb2ludENvbmZpZ3VyYXRpb25EaWN0aW9ubmFyeVtFbmRwb2ludFR5cGVFbnVtW2VuZHBvaW50VHlwZV1dO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZW5kcG9pbnRDb25maWcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYEVuZHBvaW50VHlwZSAnJHtFbmRwb2ludFR5cGVFbnVtW2VuZHBvaW50VHlwZV19JyBpcyBub3QgJ0V4dGVybmFsJyBvciAnQ3VycmVudERvbWFpbicsIGV4cGVjdGVkIGNvcnJlc3BvbmRpbmcgZW5kcG9pbnRDb25maWd1cmF0aW9uIHByb3ZpZGVkIGluIGJsdWVza3lBamF4Q2xpZW50Q29uZmlnLmVuZHBvaW50Q29uZmlndXJhdGlvbkRpY3Rpb25uYXJ5IGJ1dCBub25lIGZvdW5kLiBBYm9ydGluZy5gKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBlbmRwb2ludENvbmZpZy5FbmRwb2ludEJhc2VVUkwgKyAoZW5kcG9pbnRDb25maWcuRW5kcG9pbnRTdWZmaXggfHwgJycpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBob3cgdG8gaGFuZGxlIE9NIGFwcHMgZXh0ZXJuYWwgY2FsbHMgd2l0aG91dCBzZXNzaW9uIHByb3ZpZGVkID8gd2lsbCByZXN1bHQgaW4gYSByZWRpcmVjdCBhbmQgY2FsbCBtYXkgZmFpbCA/XHJcblxyXG4gICAgICAgICAgICAvLyBCb29sZWFuIHVzZWQgdG8gdHJ5IHRvIGRldGVybWluZSBjb3JyZWN0IGZ1bGwgdXJsIChhZGQgLyBvciBub3QgYmVmb3JlIHRoZSB1cmwgZnJhZ21lbnQgZGVwZW5kaW5nIG9uIGlmIGZvdW5kIG9yIG5vdClcclxuICAgICAgICAgICAgbGV0IHVybEZyYWdtZW50U3RhcnRzV2l0aFNsYXNoID0gdXJsSW5wdXQuc2xpY2UoMCwgMSkgPT09ICcvJztcclxuICAgICAgICAgICAgbGV0IGJhc2VVcmxGcmFnbWVudEVuZHNXaXRoU2xhc2ggPSBiYXNlVXJsLnNsaWNlKGJhc2VVcmwubGVuZ3RoIC0gMSwgYmFzZVVybC5sZW5ndGgpID09PSAnLyc7XHJcblxyXG4gICAgICAgICAgICAvL2Jhc2VkIG9uIHN0YXJ0aW5nL3RyYWlsaW5nIHNsYXNoZXMsIHJldHVybiBmdWxsIHVybC5cclxuICAgICAgICAgICAgaWYgKGJhc2VVcmxGcmFnbWVudEVuZHNXaXRoU2xhc2ggJiYgdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2gpXHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgbGFzdCAnLycgb24gYmFzZVVybFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmwuc2xpY2UoMCwgYmFzZVVybC5sZW5ndGggLSAxKSArIHVybElucHV0O1xyXG4gICAgICAgICAgICBlbHNlIGlmICghYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiAhdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2gpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybCArICcvJyArIHVybElucHV0O1xyXG4gICAgICAgICAgICBlbHNlIGlmICgoYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiAhdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2gpIHx8XHJcbiAgICAgICAgICAgICAgICAoIWJhc2VVcmxGcmFnbWVudEVuZHNXaXRoU2xhc2ggJiYgdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2gpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmwgKyB1cmxJbnB1dDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8jcmVnaW9uIHByaXZhdGUgbWV0aG9kc1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVdGlsaXR5IG1ldGhvZC5cclxuICAgICAgICAgKiBNYWluIGNhbGxlciB0aGF0IGFsbCB3cmFwcGVyIGNhbGxzIChnZXQsIGRlbGV0ZSwgcG9zdCwgcHV0KSBtdXN0IHVzZSB0byBzaGFyZSBjb21tb24gYmVoYXZpb3IuXHJcbiAgICAgICAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgYWpheDxUPihtZXRob2Q6IEh0dHBNZXRob2QsIHVybDogc3RyaW5nLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB8IG5nLklQcm9taXNlPG5ldmVyPiB7XHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBtYWtlIHN1cmUgZ2V0Q29uZmlnIHJlc29sdmUgYXV0b21hdGljYWxseSB3aXRob3V0IG92ZXJoZWFkIG9uY2UgZmlyc3QgY2FsbCBzdWNlc3NmdWxsLlxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBIDogZG8gbm90IGJsb2NrIGlmIG5vdCBjYWxsIHRvIGludGVybmFsIEFQSSAoaW5pdENhbGwpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFqYXhDb25maWdGcm9tU2VydmVyUHJvbWlzZS50aGVuKCgpID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgYmx1ZXNreUNvbmZpZyA9IHRoaXMuc2V0dXBCbHVlc2t5Q29uZmlnKGNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgYW5ndWxhckNvbmZpZyA9IHRoaXMuZXh0cmFjdEFuZ3VsYXJDb25maWdGcm9tQmx1ZXNreUNvbmZpZyhtZXRob2QsIHVybCwgYmx1ZXNreUNvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFhbmd1bGFyQ29uZmlnIHx8ICFibHVlc2t5Q29uZmlnKSB7IC8vIGlmIG5vIGNvbmZpZyByZXR1cm5lZCwgY29uZmlndXJhdGlvbiBmYWlsZWQsIGRvIG5vdCBzdGFydCBhamF4IHJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QoJ1tibHVlc2t5SHR0cFdyYXBwZXItQWpheENhbGxdIHVuYWJsZSB0byBjb25maWd1cmUgY29ycmVjdGx5IGFuZ3VsYXIgY29uZmlnIG9iamVjdCBuZWNlc3NhcnkgZm9yIGFqYXggY2FsbC4gYWJvcnRpbmcuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGh0dHA8VD4oYW5ndWxhckNvbmZpZylcclxuICAgICAgICAgICAgICAgICAgICAudGhlbih0aGlzLm9uU3VjY2VzczxUPihibHVlc2t5Q29uZmlnKSwgdGhpcy5vbkVycm9yKGJsdWVza3lDb25maWcpKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vLmNhdGNoIFRPRE8gTUdBIGhhbmRsZSBjYXRjaCBjbGF1c2UgaWYgZXhjZXB0aW9uIGluIHN1Y2Nlc3Mgb3IgZXJyb3IgY2FsbGJhY2sgIVxyXG4gICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KHRoaXMuZmluYWxseSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJlcGFyZXMgYmx1ZXNreS1zcGVjaWZpYyBjb25maWd1cmF0aW9uIGJhc2VkIG9uIHByb3ZpZGVkIGlucHV0cy5cclxuICAgICAgICAgKiBUaGUgb3BlcmF0aW9ucyBpbmNsdWRlIHNldHRpbmcgZGVmYXVsdCB2YWx1ZXMgd2hlbiBub3QgcHJvdmlkZWQsIGFuZCBzZXR0aW5nIGh0dHAgaGVhZGVycyBpZiBuZWVkZWQgZm9yIDpcclxuICAgICAgICAgKiAgLSBBamF4IGNhbGxzXHJcbiAgICAgICAgICogIC0gQXV0aG9yaXphdGlvbiB0b2tlblxyXG4gICAgICAgICAqICAtIEN1cnJlbnQgVXNlclJvbGUuXHJcbiAgICAgICAgICogQHBhcmFtIGNvbmZpZyB1c2VyIGlucHV0IGNvbmZpZyBpZiBwcm92aWRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBhdXRvbWF0aWMgcnVsZXMgYXBwbGllZC4gXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBzZXR1cEJsdWVza3lDb25maWcgPSAoY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnIHwgdW5kZWZpbmVkID0+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IGNvbmZpZyB2YWx1ZXMgYW5kIGN1c3RvbSBvbmVzIGJhc2VkIG9uIGVuZHBvaW50c1xyXG5cclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgY29uZmlnLmVuZHBvaW50VHlwZSA9IGNvbmZpZy5lbmRwb2ludFR5cGUgfHwgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluOyAvLyBkZWZhdWx0IHZhbHVlOiBpZiBub3Qgc3BlY2lmaWVkLCBlbmRwb2ludCB0byB1c2UgaXMgc3VwcG9zZWQgdG8gYmUgdGhlIG9yaWdpbi5cclxuXHJcbiAgICAgICAgICAgIC8vIHNlYXJjaCBieSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZW5kcG9pbnQgdHlwZVxyXG4gICAgICAgICAgICAvLyBUT0RPIE1HQTogbWFrZSBzdXJlIEVuZHBvaW50VHlwZUVudW1baW52YWxpZCB2YWx1ZV0gZG9lc24ndCByZXR1cm4gZGVmYXVsdCB2YWxpZCBlbnVtIHZhbHVlID8/PyBvdGhlcndpc2UsIGRhbmdlcm91cyAhXHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RW5kcG9pbnRDb25maWcgPSB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnICYmIHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuRW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnlbRW5kcG9pbnRUeXBlRW51bVtjb25maWcuZW5kcG9pbnRUeXBlXV07XHJcblxyXG4gICAgICAgICAgICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgLy8gY29uZmlndXJlIGRlZmF1bHQgY29uZmlnIGZsYWdzIGJhc2VkIG9uIHRhcmdldCBlbmRwb2ludFxyXG4gICAgICAgICAgICBzd2l0Y2ggKGNvbmZpZy5lbmRwb2ludFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5Db3JlQXBpOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLk1hcmtldGluZ0FwaTpcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5TZWxmY2FyZUFwaTpcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5NZXRyYU5ldEFwaTpcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5SZXNvdXJjZUFwaTpcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5Nb25pdG9yaW5nQXBpOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlamVjdCBleHBsaWNpdGx5IHdyb25nIGlucHV0IGNvbmZpZ3VyYXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLndhcm4oYFtCbHVlc2t5SHR0cFdyYXBwZXJdW3NldHVwQmx1ZXNreUNvbmZpZ10gLSBBUEkgY2FsbCBpbnRlbmRlZCB3aXRoIGluY29tcGF0aWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuIEFib3J0aW5nIGFqYXggY2FsbC5gLCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uZmlnIHZhbHVlcyBmb3IgQVBJIGVuZHBvaW50cyBhcmUgZGlmZmVyZW50IGZyb20gZGVmYXVsdCwgc28gd2UgbXVzdCBzcGVjaWZ5IHRoZW0uXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IGZhbHNlOyAvLyBieSBkZWZhdWx0IGFscmVhZHkgZW5hYmxlZCwgYnV0IGVuZm9yZSB0aGlzIGhlYWRlciBhcyBuZWNlc3NhcnkgZm9yIGNhbGxzIHRvIFdlYkFQSSBlbmRwb2ludHMuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnVzZUN1cnJlbnRVc2VyUm9sZSA9IHRydWU7IC8vIGZvciBhcGkgY2FsbHMsIGZvcmNlIHRoaXMgcm9sZSB0byBiZSBwYXNzZWQgYXJvdW5kIChzaG91bGQgYmUgbWFuZGF0b3J5IHRvIGNvbnRleHR1YWxpemUgcmVxdWVzdCB0byByZWFsbSBvZiBjdXJyZW50IHVzZXIpLlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLlF1b3RlV2l6YXJkOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLk9yZGVyRW50cnk6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uT3JkZXJUcmFja2luZzpcclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgT00gYXBwcyBjYWxsZWQgYXMgZW5kcG9pbnRzLCBtYWtlIHN1cmUgdGhlIFhtbEh0dHBSZXF1ZXN0IGhlYWRlciBpcyBwcmVzZW50IChBU1AuTkVUIGFwcHMpLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBhZGQgY3VycmVudFVzZXJSb2xlIGJ5IGRlZmF1bHQgc28gdGhhdCBPTSBhcHBzIGNhbiBjb250ZXh0dWFsaXNlIHRoZSByZXF1ZXN0ID9cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5NZXRyYW5ldDpcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5UZWNobmljYWxJbnZlbnRvcnk6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uVGVtcGxhdGVHZW5lcmF0b3I6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uU2FsZXNmb3JjZTpcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBubyBzcGVjaWZpYyBjb25maWcgZm9yIHRob3NlIGV4dGVybmFsIGVuZHBvaW50cyA/IGFkZCBjdXN0b20gb25lcyBpZiBuZWVkZWQgaGVyZS5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBhamF4IGNhbGxzLCBtYWtlIHN1cmUgdGhlIFhtbEh0dHBSZXF1ZXN0IGhlYWRlciBpcyBwcmVzZW50IChBU1AuTkVUIGFwcHMpLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB1c2VyIHJvbGUgaXMgdXNlZnVsbCBldmVuIGZvciBjdXJyZW50IGRvbWFpbiBzbyB0aGF0IHNydiBjYW4ga25vdyB0aGUgY29udGV4dC5cclxuICAgICAgICAgICAgICAgICAgICBjb25maWcudXNlQ3VycmVudFVzZXJSb2xlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5FeHRlcm5hbDpcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIHRvIGNvbmZpcm06IHdlIG1heSB3YW50IHRvIGNhbGwgZXh0ZXJuYWwgdXJscyB2aWEgYWpheCwgc28gaG93IHRvIGJlIHN1cmUgb2YgZGVmYXVsdCB2YWx1ZSA/XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IHRydWU7IC8vIGRvIG5vdCBhZGQgWG1sSHR0cFJlcXVlc3QgaWYgZXh0ZXJuYWwgVXJsIGJ5IGRlZmF1bHQ6IG1pZ2h0IGNyZWF0ZSBjb25mbGljdHMgb24gY2VydGFpbiBzZXJ2ZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0aGlzIGhlYWRlciBvdXRzaWRlIG9mIEFTUCB3b3JsZC5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKGBbQmx1ZXNreUh0dHBXcmFwcGVyXVtzZXR1cEJsdWVza3lDb25maWddIC0gVW5zdXBwb3J0ZWQgZW5kcG9pbnRUeXBlIHByb3ZpZGVkOiAnJHtFbmRwb2ludFR5cGVFbnVtW2NvbmZpZy5lbmRwb2ludFR5cGUgfHwgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluXX0nLiBBYm9ydGluZy5gLCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAvL2JyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBzaG91bGQgd2UgYXV0aG9yaXplIG5vIHZhbGlkIGVuZHBvaW50IGNvbmZpZ3VyYXRpb24gbG9hZGVkIGZvciBjdXJyZW50IGRvbWFpbiA/IEF1dGhUb2tlbiBzdGlsbCB1c2VmdWxsIG9yIG5vdCA/IEJhc2VVUkwgc3RpbGwgdXNlZnVsbCBvciBub3QgPyBhcGkgc3VmZml4ID8gXHJcbiAgICAgICAgICAgIC8vIEZvciBleHRlcm5hbCBVUkxzLCBvYnZpb3VzbHkgZW5kcG9pbnQgY29uZmlnIGlzIG5vdCBtYW5kYXRvcnksIGJ1dCBpdCBjb3VsZCBiZSBwcm92aWRlZCBpZiBuZWVkZWQ6IGhvdyB0byBoYW5kbGUgdGhpcyBjYXNlP1xyXG5cclxuICAgICAgICAgICAgLy9SZWplY3QgYWpheCBjYWxscyBpbnRlbmRlZCB0byBleHRlcm5hbCBlbmRwb2ludHMgd2l0aG91dCBuZWNlc3NhcnkgY29uZmlndXJhdGlvbiBsb2FkZWQgZnJvbSB0aGUgc2VydmVyLlxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmVuZHBvaW50VHlwZSAhPT0gRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluICYmXHJcbiAgICAgICAgICAgICAgICBjb25maWcuZW5kcG9pbnRUeXBlICE9PSBFbmRwb2ludFR5cGVFbnVtLkV4dGVybmFsICYmXHJcbiAgICAgICAgICAgICAgICAhY3VycmVudEVuZHBvaW50Q29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYFtCbHVlc2t5SHR0cFdyYXBwZXJdW3NldHVwQmx1ZXNreUNvbmZpZ10gLSBBamF4IGNhbGwgaW50ZW5kZWQgd2l0aG91dCBleHBlY3RlZCBlbmRwb2ludCBjb25maWd1cmF0aW9uIGxvYWRlZCBmcm9tIHRoZSBzZXJ2ZXIgZm9yIGVuZHBvaW50VHlwZSAnJHtFbmRwb2ludFR5cGVFbnVtW2NvbmZpZy5lbmRwb2ludFR5cGVdfScuIEFib3J0aW5nLmAsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBzZXQgZGVmYXVsdCB2YWx1ZXMgYWZ0ZXIgZW5kcG9pbnQtc3BlY2lmaWMgY29uZmlndXJhdGlvbnNcclxuICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgfHwgZmFsc2U7IC8vIGRlZmF1bHQgdmFsdWUgaXMgZW5hYmxlZCAoYWpheCBjYWxscyBvbiAuTkVUIGVuZHBvaW50cykuXHJcbiAgICAgICAgICAgIGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUgPSBjb25maWcudXNlQ3VycmVudFVzZXJSb2xlIHx8IGZhbHNlOyAvLyBkZWZhdWx0IHZhbHVlOiBkb24ndCB0cmFuc21pdCBzZW5zaXRpdmUgaW5mb3JtYXRpb24gdG8gcmVtb3RlIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZC5cclxuICAgICAgICAgICAgY29uZmlnLmRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucyA9IGNvbmZpZy5kaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMgfHwgZmFsc2U7IC8vc2V0IGRlZmF1bHQgdmFsdWUgZm9yIGRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucyB0byBmYWxzZSBhcyBpdCdzIHBhcnQgb2YgdGhlIG5vcm1hbCBiZWhhdmlvciBleHBlY3RlZCBmb3IgdGhpcyBzZXJ2aWNlLlxyXG5cclxuICAgICAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyKVxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZCBjb2RlZCBoZWFkZXIgdG8gcHV0IGluIENPTlNUXHJcbiAgICAgICAgICAgICAgICBjb25maWcuaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcclxuXHJcbiAgICAgICAgICAgIGlmIChjb25maWcudXNlQ3VycmVudFVzZXJSb2xlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWplY3QgY2FsbCB3aGVuIG1pc3NpbmcgbWFuZGF0b3J5IGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuQ3VycmVudFVzZXJSb2xlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKGBbQmx1ZXNreUh0dHBXcmFwcGVyXVtzZXR1cEJsdWVza3lDb25maWddIC0gQWpheCBjYWxsIGludGVuZGVkIHdpdGhvdXQgbmVjZXNzYXJ5IHVzZXJSb2xlIHNldCBpbiBjb25maWcuIEFib3J0aW5nLmAsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY29kZWQgaGVhZGVyIHRvIHB1dCBpbiBDT05TVFxyXG4gICAgICAgICAgICAgICAgY29uZmlnLmhlYWRlcnNbJ09BLVVzZXJSb2xlJ10gPSB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLkN1cnJlbnRVc2VyUm9sZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgYXV0aCB0b2tlbiBwcm92aWRlZCBmb3IgdGFyZ2V0IGVuZHBvaW50LCBhZGQgaXQgaW4gaGVhZGVyXHJcbiAgICAgICAgICAgIC8vIHByb3RlY3QgYWdhaW5zdCBjYXNlcyB3aGVyZSBlbmRwb2ludFR5cGUgaXMgY3VycmVudCBkb21haW4gb3IgZXh0ZXJuYWw6IGVuZHBvaW50Q29uZmlnIG51bGwvdW5kZWZpbmVkLlxyXG4gICAgICAgICAgICBpZiAoY3VycmVudEVuZHBvaW50Q29uZmlnICYmIGN1cnJlbnRFbmRwb2ludENvbmZpZy5BdXRoVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHJlamVjdCBhdXRoVG9rZW4gZm9yIGVuZHBvaW50cyB0aGF0IGFyZSBub3QgJ3NhZmUnIHRvIHNoYXJlIGF1dGggdG9rZW4gd2l0aCwgc3VjaCBhcyBFeHRlcm5hbCBvbmVzID8gT3IgYXV0aG9yaXplIHRoaXMgc28gdGhhdCBzZXJ2ZXIgY2FuIGxvYWQgYW4gYXV0aCB0b2tlbiBmb3IgY2VydGFpbiBleHRlcm5hbCBlbmRwb2ludHMgP1xyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSB0b2tlbiB2YWxpZGl0eSBlbmREYXRlOiByZW5ldyBhdXRoIGJlZm9yZSB0aGUgY2FsbCAhIFdoYXQncyB0aGUgYmVzdCBtb21lbnQgdG8gZG8gaXQgP1xyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY29kZWQgaGVhZGVyIHRvIHB1dCBpbiBDT05TVFxyXG4gICAgICAgICAgICAgICAgY29uZmlnLmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9ICdCZWFyZXIgJyArIGN1cnJlbnRFbmRwb2ludENvbmZpZy5BdXRoVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IE9FIHNwZWNpZmljIGNvZGUsIHRvIHJlbW92ZSwgb3IgYXQgbGVhc3QgcHV0IGluIGFzIGNvbmZpZyBwYXJhbVxyXG4gICAgICAgICAgICBpZiAoKDxhbnk+dGhpcy4kd2luZG93KS5ibG9ja19VSSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBNR0EgOiB0eXBlIGNhc3RpbmcsIGlzIGl0IG9rYXkgb3Igbm90ID8gYmV0dGVyIGFwcHJvYWNoID9cclxuICAgICAgICAgICAgICAgICg8YW55PnRoaXMuJHdpbmRvdykucHJldmVudEJsb2NrVUkgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgZXh0cmFjdEFuZ3VsYXJDb25maWdGcm9tQmx1ZXNreUNvbmZpZyA9IChtZXRob2Q6IEh0dHBNZXRob2QsIHVybDogc3RyaW5nLCBibHVlc2t5Q29uZmlnOiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcgfCB1bmRlZmluZWQpOiBuZy5JUmVxdWVzdENvbmZpZyB8IHVuZGVmaW5lZCA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyBpbnB1dCB2YWxpZGF0aW9uXHJcblxyXG4gICAgICAgICAgICBpZiAoIXVybCB8fCBtZXRob2QgPT09IG51bGwgfHwgbWV0aG9kID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVVJMICYgTUVUSE9EIHBhcmFtZXRlcnMgYXJlIG5lY2Vzc2FyeSB0byBjb25maWd1cmUgaHR0cFdyYXBwZXIgY2FsbHMuIEFib3J0aW5nLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFibHVlc2t5Q29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ2JsdWVza3kgY29uZmlnIG1pc3NpbmcuIEFib3J0aW5nLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZCBjYXN0IGlzIG5vdCBzYWZlLCB3ZSBtYXkgZm9yZ2V0IHRvIHNldCB1cmwgJiBtZXRob2QgcGFyYW1ldGVycy4gVE9GSVguXHJcbiAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZ2V0IGFsbCBub24tZmlsdGVyZWQgcGFyYW1ldGVycyAmIGtlZXAgdGhlbSBmb3IgdGhpcyBuZXcgb2JqZWN0LlxyXG4gICAgICAgICAgICBsZXQgYW5ndWxhckNvbmZpZyA9IDxuZy5JUmVxdWVzdENvbmZpZz5ibHVlc2t5Q29uZmlnO1xyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogc3VwcG9ydCBtYXBwaW5nIGJldHdlZW4gdXBsb2FkICYgcG9zdCBoZXJlID9cclxuICAgICAgICAgICAgYW5ndWxhckNvbmZpZy5tZXRob2QgPSBIdHRwTWV0aG9kW21ldGhvZF07XHJcblxyXG4gICAgICAgICAgICAvLyBUcnkgdG8gYnVpbGQgYSB2YWxpZCB1cmwgZnJvbSBpbnB1dCAmIGVuZHBvaW50VHlwZS5cclxuICAgICAgICAgICAgbGV0IGZpbmFsVXJsVG9GZXRjaCA9IHRoaXMuYnVpbGRVcmxGcm9tQ29udGV4dCh1cmwsIGJsdWVza3lDb25maWcuZW5kcG9pbnRUeXBlKTtcclxuICAgICAgICAgICAgaWYgKCFmaW5hbFVybFRvRmV0Y2gpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignW0JsdWVza3lIdHRwV3JhcHBlciAtIGFqYXggY2FsbCBidWlsZGVyXSAtIHVuYWJsZSB0byBjb25zdHJ1Y3QgdmFsaWQgdXJsIHRvIGNhbGwuIGFib3J0aW5nLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhbmd1bGFyQ29uZmlnLnVybCA9IGZpbmFsVXJsVG9GZXRjaDtcclxuXHJcbiAgICAgICAgICAgIGlmICghYW5ndWxhckNvbmZpZy51cmwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihgW0JsdWVza3lIdHRwV3JhcHBlcl1bY29uZmlndXJlSHR0cENhbGxdIC0gVW5hYmxlIHRvIGJ1aWxkIHVybCBmcm9tIHVybElucHV0ICcke3VybH0nIHdpdGggZW5kcG9pbnRUeXBlICcke2JsdWVza3lDb25maWcuZW5kcG9pbnRUeXBlID8gRW5kcG9pbnRUeXBlRW51bVtibHVlc2t5Q29uZmlnLmVuZHBvaW50VHlwZV0gOiBcInVua25vd24gZW5kcG9pbnRcIn0nLiBBYm9ydGluZyBhamF4IGNhbGwuYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYW5ndWxhckNvbmZpZztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN1Y2Nlc3MgaGFuZGxlci5cclxuICAgICAgICAgKiBDYXB0dXJlcyB0aGUgaW5wdXQgcGFyYW1ldGVycyBhdCB0aGUgbW9tZW50IG9mIGl0cyBkZWNsYXJhdGlvbiAmIHJldHVybiB0aGUgcmVhbCBoYW5kbGVyIHRvIGJlIGNhbGxlZCB1cG9uIHByb21pc2UgY29tcGxldGlvbi5cclxuICAgICAgICAgKiBJbnB1dCBwYXJhbWV0ZXJzOlxyXG4gICAgICAgICAqICAtIGNhbGxpbmdDb25maWc6IGNvbmZpZ3VyYXRpb24gdXNlZCB0byBtYWtlIHRoZSBhamF4IGNhbGwsIGluIGNhc2UgdGhlIHJldHVybmVkIHByb21pc2UgaXMgbnVsbC9lbXB0eSBhbmQgZG9lc24ndCBjb250YWluIG5lY2Vzc2FyeSBkYXRhIGZvciBkZWJ1Z2dpbmcuXHJcbiAgICAgICAgICogIC0gZ2V0Q29tcGxldGVSZXNwb25zZU9iamVjdDogZmxhZyBpbmRpY2F0aW9uIGlmIHdlIG11c3QgcmV0dXJuIHRoZSBmdWxsIHJlc3BvbnNlIG9iamVjdCBhbG9uZyB3aXRoIGhlYWRlcnMgYW5kIHN0YXR1cyBvciBvbmx5IHRoZSBpbm5lciBkYXRhLiBCeSBkZWZhdWx0ICYgaWYgbm90IHNwZWNpZmllZCwgb25seSByZXR1cm5zIGlubmVyIGRhdGEuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBvblN1Y2Nlc3MgPSA8VD4ob3JpZ2luYWxDb25maWc6IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IChodHRwUHJvbWlzZTogbmcuSUh0dHBQcm9taXNlQ2FsbGJhY2tBcmc8VD4pID0+IFQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIW9yaWdpbmFsQ29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cud2FybigndW5hYmxlIHRvIHJldHJpZXZlIG9yaWdpbmFsQ29uZmlnIGluIG9uU3VjY2Vzcy4gUGxlYXNlIHByb3ZpZGUgY29tcGxldGUgY29uZmlnLicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gPFQ+KGh0dHBQcm9taXNlOiBuZy5JSHR0cFByb21pc2VDYWxsYmFja0FyZzxUPik6IFQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFodHRwUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtc2cgPSBgW0hUVFAgbm8tcmVzcG9uc2VdIFVuZXhwZWN0ZWQgJGh0dHAgZXJyb3IsIG5vIHJlc3BvbnNlIHByb21pc2UgcmV0dXJuZWQuYDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IobXNnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcmlnaW5hbENvbmZpZy5kaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9hc3Rlci5lcnJvcigndW5leHBlY3RlZCBiZWhhdmlvcicsICdQbGVhc2UgY29udGFjdCB5b3VyIGxvY2FsIHN1cHBvcnQgdGVhbS4nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIG11bHRpLXR5cGUgcmV0dXJuIGluIGNhc2Ugb2YgcmVqZWN0aW9uIG9yIGRvIHNvbWV0aGluZyBlbHNlID8gdGhpcyBtZXRob2QgaXMgY3VycmVudGx5IHVzZWQgc3luY2hyb25vdXNseSB3aXRob3V0IHByb21pc2Ugd2FpdGluZy5cclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiB0aGlzLiRxLnJlamVjdChodHRwUHJvbWlzZSk7IC8vIFJlamVjdCBwcm9taXNlXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogcmVqZWN0IGlmIHN0YXR1cyAhPSAyWFggP1xyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSB3aGVuIEFQSSBpcyBmaXhlZC4gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE3NDY4OTQvd2hhdC1pcy10aGUtcHJvcGVyLXJlc3QtcmVzcG9uc2UtY29kZS1mb3ItYS12YWxpZC1yZXF1ZXN0LWJ1dC1hbi1lbXB0eS1kYXRhXHJcbiAgICAgICAgICAgICAgICAvL2lmICgocHJvbWlzZUNhbGxiYWNrLmRhdGEgPT09IG51bGwgfHwgcHJvbWlzZUNhbGxiYWNrLmRhdGEgPT09IHVuZGVmaW5lZCkgJiYgcHJvbWlzZUNhbGxiYWNrLnN0YXR1cyAhPT0gMjA0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICB0aGlzLiRsb2cuZXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLCBleHBlY3RlZCByZXNwb25zZSBkYXRhIGJ1dCBub25lIGZvdW5kLicpO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgdGhpcy50b2FzdGVyLndhcm5pbmcoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UnLCAnUGxlYXNlIGNvbnRhY3QgeW91ciBsb2NhbCBzdXBwb3J0IHRlYW0uJyk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QocHJvbWlzZUNhbGxiYWNrKTsgLy8gUmVqZWN0IHByb21pc2UgaWYgbm90IHdlbGwtZm9ybWVkIGRhdGFcclxuICAgICAgICAgICAgICAgIC8vfVxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogc2FtZSBiZWhhdmlvciBhbHNvIG9uIGEgR0VUIHJlcXVlc3QgPyBpZiByZXF1ZXN0IGlzIEdFVCBhbmQgcmVzcG9uc2UgaXMgMjAwIHdpdGggbm8gZGF0YSwgcmV0dXJuIGVycm9yID8gKHBhc3MgaW4gcGFyYW1ldGVyIHJlcXVlc3QgY29udGV4dCB0byBsb2cgdGhpcyBlcnJvcikuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogZ2V0IGZ1bGwgdXJsIG9mIHJlcXVlc3RcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5kZWJ1ZyhgW0hUVFAgJHtodHRwUHJvbWlzZS5jb25maWcubWV0aG9kfV0gWyR7aHR0cFByb21pc2UuY29uZmlnLnVybH1dYCwgaHR0cFByb21pc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiBvbmx5IHRoZSBkYXRhIGV4cGVjdGVkIGZvciBjYWxsZXJcclxuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUHJvbWlzZS5kYXRhO1xyXG5cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVycm9yIGhhbmRsZXJcclxuICAgICAgICAgKiBUT0RPIE1HQTogYW5ndWxhciBzaWduYXR1cmVzIGluZGljYXRlcyB0aGF0IHBhcmFtZXRlciBpcyByZWplY3Rpb24gcmVhc29uLCBub3QgbmVjZXNzYXJpbHkgaHR0cFByb21pc2U6IGludmVzdGlnYXRlICYgZml4IGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAqIEBwYXJhbSBodHRwUHJvbWlzZSBcclxuICAgICAgICAgKiBAcmV0dXJucyB7fSBcclxuICAgICAgICAgKi9cclxuICAgICAgICBwcml2YXRlIG9uRXJyb3IgPSAob3JpZ2luYWxDb25maWc6IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IChodHRwUHJvbWlzZTogbmcuSUh0dHBQcm9taXNlQ2FsbGJhY2tBcmc8YW55PikgPT4gYW55ID0+IHtcclxuICAgICAgICAgICAgaWYgKCFvcmlnaW5hbENvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLndhcm4oJ3VuYWJsZSB0byByZXRyaWV2ZSBvcmlnaW5hbENvbmZpZyBpbiBvblN1Y2Nlc3MuIFBsZWFzZSBwcm92aWRlIGNvbXBsZXRlIGNvbmZpZy4nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChodHRwUHJvbWlzZTogbmcuSUh0dHBQcm9taXNlQ2FsbGJhY2tBcmc8YW55Pik6IGFueSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzdXBwb3NlIGluIGNhc2Ugb2Ygbm8gcmVzcG9uc2UgdGhhdCB0aGUgc3J2IGRpZG4ndCBzZW5kIGFueSByZXNwb25zZS5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBOiBtYXkgYWxzbyBiZSBhIGZhdWx0IGluIGludGVybmFsICRodHRwIC8gYWpheCBjbGllbnQgc2lkZSBsaWIsIHRvIGRpc3Rpbmd1aXNoLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFodHRwUHJvbWlzZSB8fCAhaHR0cFByb21pc2UuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLmRhdGEgPSAnU2VydmVyIG5vdCByZXNwb25kaW5nJztcclxuICAgICAgICAgICAgICAgICAgICBodHRwUHJvbWlzZS5zdGF0dXMgPSA1MDM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFvcmlnaW5hbENvbmZpZy5kaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRUeXBlID0gaHR0cFByb21pc2UuaGVhZGVycygnQ29udGVudC1UeXBlJyk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGNvbnRlbnRUeXBlIHRvIHRyeSB0byBkaXNwbGF5IGVycm9yIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ3RleHQvcGxhaW4nKSA+IC0xKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2U6IHN0cmluZyA9ICcnOyAvL2RlZmF1bHQgbWVzc2FnZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIGVycm9yIGhhbmRsaW5nIG1vcmUgZ2VuZXJpY2FsbHkgYmFzZWQgb24gaW5wdXQgZXJyb3IgbWVzc2FnZSBjb250cmFjdCBpbnN0ZWFkIG9mIGV4cGVjdGluZyBzcGVjaWZpYyBlcnJvciBzdHJjdHVyZS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgKHJlc3BvbnNlLmRhdGEuTW9kZWxTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAvL1RPRE8gTUdBIDogaGFuZGxlIHRoaXMgd2hlbiB3ZWxsIGZvcm1hdHRlZCBzZXJ2ZXItc2lkZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL30gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc1N0cmluZyhodHRwUHJvbWlzZS5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGh0dHBQcm9taXNlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaHR0cFByb21pc2UuZGF0YS5NZXNzYWdlICYmIGFuZ3VsYXIuaXNTdHJpbmcoaHR0cFByb21pc2UuZGF0YS5NZXNzYWdlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGh0dHBQcm9taXNlLmRhdGEuTWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh0dHBQcm9taXNlLnN0YXR1cyA+PSA0MDAgJiYgaHR0cFByb21pc2Uuc3RhdHVzIDwgNTAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHR0cFByb21pc2UuZGF0YSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLmRhdGEuTW9kZWxTdGF0ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLmRhdGEuTW9kZWxTdGF0ZS5WYWxpZGF0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cFByb21pc2UuZGF0YS5Nb2RlbFN0YXRlLlZhbGlkYXRpb24ubGVuZ3RoID4gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZUNvbnRlbnQgPSBodHRwUHJvbWlzZS5kYXRhLk1vZGVsU3RhdGUuVmFsaWRhdGlvbi5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9hc3Rlci53YXJuaW5nKG1lc3NhZ2UgfHwgJ2JhZCByZXF1ZXN0JywgbWVzc2FnZUNvbnRlbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaHR0cFByb21pc2Uuc3RhdHVzID09PSA0MDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvYXN0ZXIud2FybmluZygnbm90IGZvdW5kJywgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9hc3Rlci53YXJuaW5nKCdiYWQgcmVxdWVzdCcsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyA1MDArIHN0YXR1cyBjb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvYXN0ZXIuZXJyb3IoJ3NlcnZlciByZXNwb25zZSBlcnJvcicsIGAke21lc3NhZ2V9LiAoc3RhdHVzOiAke2h0dHBQcm9taXNlLnN0YXR1c30pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2FzdGVyLmVycm9yKCdpbnRlcm5hbCBzZXJ2ZXIgZXJyb3InLCAnc3RhdHVzOiAnICsgaHR0cFByb21pc2Uuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogZ2V0IGZ1bGwgdXJsIG9mIHJlcXVlc3RcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihgW0hUVFAgJHtodHRwUHJvbWlzZS5jb25maWcubWV0aG9kfV0gWyR7aHR0cFByb21pc2UuY29uZmlnLnVybH1dYCwgaHR0cFByb21pc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHJlY292ZXIgZnJvbSBlcnJvciwgc28gd2UgcHJvcGFnYXRlIGl0IDogYmVsb3cgaGFuZGxlcnMgaGF2ZSB0aGUgY2hvaWNlIG9mIHJlYWRpbmcgdGhlIGVycm9yIHdpdGggYW4gZXJyb3IgaGFuZGxlciBvciBub3QuIFNlZSAkcSBwcm9taXNlcyBiZWhhdmlvciBoZXJlIDogaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGJlaGF2aW9yIGlzIGRlc2lyZWQgc28gdGhhdCB3ZSBzaG93IGVycm9yIGluc2lkZSBzcGVjaWZpYyBzZXJ2ZXIgY29tbXVuaWNhdGlvbiBtb2RhbHMgYXQgc3BlY2lmaWMgcGxhY2VzIGluIHRoZSBhcHAsIG90aGVyd2lzZSBzaG93IGEgZ2xvYmFsIGFsZXJ0IG1lc3NhZ2UsIG9yIGV2ZW4gZG8gbm90IHNob3cgYW55dGhpbmcgaWYgbm90IG5lY2Vzc2FyeSAoZG8gbm90IGFkIGFuIGVycm9yIGhhbmRsZXIgaW4gYmVsb3cgaGFuZGxlcnMgb2YgdGhpcyBwcm9taXNlKS5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRxLnJlamVjdChodHRwUHJvbWlzZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGdW5jdGlvbiBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhbiBhamF4IGNhbGwsIHJlZ2FyZGxlc3Mgb2YgaXQncyBzdWNjZXNzIG9yIGZhaWx1cmUuXHJcbiAgICAgICAgICogQHBhcmFtIHJlc3BvbnNlXHJcbiAgICAgICAgICogVE9ETyBNR0EgaW52ZXJzaW9uIG9mIHJlc3BvbnNhYmlsaXR5OiBtYWtlIHRoaXMgZXh0ZW5zaWJsZSBzbyB0aGF0IHNwZWNpZmMgYXBwcyBjYW4gcGx1ZyBpbnRvIHRoaXMgZXZlbnQgd29ya2Zsb3dcclxuICAgICAgICAgKi9cclxuICAgICAgICBwcml2YXRlIGZpbmFsbHkgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IE9FLXNwZWNpZmljIGNvZGVcclxuICAgICAgICAgICAgaWYgKCg8YW55PnRoaXMuJHdpbmRvdykuYmxvY2tfVUkgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdHlwZSBjYXN0aW5nLCBpcyBpdCBva2F5IG9yIG5vdCA/IGJldHRlciBhcHByb2FjaCA/XHJcbiAgICAgICAgICAgICAgICAoPGFueT50aGlzLiR3aW5kb3cpLnByZXZlbnRCbG9ja1VJID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUT0RPIE1HQSA6IHVzaW5nIG1ldGhvZCBmcm9tIExheW91dC5qcyA6IHRvIGRvY3VtZW50IHRvIG5vdCBoYW5kbGUgZHVwbGljYXRlIGNvZGUgISFcclxuICAgICAgICAvL1RPRE8gTUdBOiB1bnJvYnVzdCwgbmVlZHMgc29saWQgcmVmYWN0byB0byBtYWtlIGl0IG1vcmUgZ2VuZXJpYyB3aGVuIG9uIG9yaWdpbiBkb21haW4gIVxyXG4gICAgICAgIHByaXZhdGUgZ2V0VXJsUGF0aChhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXI6IGJvb2xlYW4pOiBzdHJpbmcge1xyXG5cclxuICAgICAgICAgICAgbGV0IGJhc2VVcmxPbUFwcHNSZWdleCA9IC8oXFwvXFx3K1xcL1xcKFNcXChcXHcrXFwpXFwpKVxcL1xcdysvO1xyXG4gICAgICAgICAgICBsZXQgYmFzZVVybEFzcEFwcHNSZWdleCA9IC8oXFwvXFx3KylcXC9cXHcrLztcclxuXHJcbiAgICAgICAgICAgIGxldCB1cmwgPSB0aGlzLiR3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XHJcbiAgICAgICAgICAgIGxldCBiYXNlVXJsT21BcHBzTWF0Y2hlcyA9IGJhc2VVcmxPbUFwcHNSZWdleC5leGVjKHVybCk7XHJcbiAgICAgICAgICAgIGxldCBiYXNlVXJsQXNwQXBwc01hdGNoZXMgPSBiYXNlVXJsQXNwQXBwc1JlZ2V4LmV4ZWModXJsKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGxldCBiYXNlVXJsOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAvLyAyIG1hdGNoZXMgPSByZWdleCBtYXRjaGVzICsgdGhlIGNhcHR1cmluZyBncm91cFxyXG4gICAgICAgICAgICBpZiAoYmFzZVVybE9tQXBwc01hdGNoZXMgJiYgYmFzZVVybE9tQXBwc01hdGNoZXMubGVuZ3RoICYmIGJhc2VVcmxPbUFwcHNNYXRjaGVzLmxlbmd0aCA9PT0gMikge1xyXG5cclxuICAgICAgICAgICAgICAgIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWUgPSBiYXNlVXJsT21BcHBzTWF0Y2hlc1swXTtcclxuICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBiYXNlVXJsT21BcHBzTWF0Y2hlc1sxXTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiYXNlVXJsQXNwQXBwc01hdGNoZXMgJiYgYmFzZVVybEFzcEFwcHNNYXRjaGVzLmxlbmd0aCAmJiBiYXNlVXJsQXNwQXBwc01hdGNoZXMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lID0gYmFzZVVybEFzcEFwcHNNYXRjaGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgYmFzZVVybCA9IGJhc2VVcmxBc3BBcHBzTWF0Y2hlc1sxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGFjdGlvbklzT25TYW1lQ29udHJvbGxlciAmJiBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiYXNlVXJsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9UT0RPIE1HQTogT00tc3BlY2lmaWMgQVNQIE1WQyBjb2RlLCBub3QgdXNlZCBBVE0sIHRvIHJlbW92ZVxyXG4gICAgICAgIC8vIHByaXZhdGUgZ2V0Q3VycmVudFNlc3Npb25JRCgpOiBzdHJpbmcge1xyXG5cclxuICAgICAgICAvLyAgICAgLy9UT0RPIE1HQSA6IG1hZ2ljIHJlZ2V4cCB0byBmZXRjaCBTZXNzaW9uSUQgaW4gVVJMLCB0byBzdG9yZSBlbHNld2hlcmUgIVxyXG4gICAgICAgIC8vICAgICB2YXIgc2Vzc2lvblJlZ2V4ID0gL2h0dHBzOlxcL1xcL1tcXHcuXStcXC9bXFx3Ll0rXFwvKFxcKFNcXChcXHcrXFwpXFwpKVxcLy4qLztcclxuICAgICAgICAvLyAgICAgLy92YXIgc2Vzc2lvblJlZ2V4ID0gL2h0dHBzOlxcL1xcL1tcXHcuXStcXC9PcmRlckVudHJ5XFwvKFxcKFNcXChcXHcrXFwpXFwpKVxcLy4qLztcclxuXHJcbiAgICAgICAgLy8gICAgIC8vIFRPRE8gTUdBIDogdXBkYXRlIHJlZ2V4cCB0byB0aGUgb25lIGJlbG93XHJcbiAgICAgICAgLy8gICAgIC8vdmFyIGJhc2VVcmxSZWdleCA9IC8oaHR0cHM6XFwvXFwvW1xcdy4tXStcXC9bXFx3Li1dK1xcL1xcKFNcXChcXHcrXFwpXFwpXFwvKVxcdysvO1xyXG5cclxuXHJcbiAgICAgICAgLy8gICAgIHZhciBwYXRoID0gdGhpcy4kbG9jYXRpb24uYWJzVXJsKCk7XHJcblxyXG4gICAgICAgIC8vICAgICB2YXIgcmVnZXhwQXJyYXkgPSBzZXNzaW9uUmVnZXguZXhlYyhwYXRoKTtcclxuXHJcbiAgICAgICAgLy8gICAgIGlmICghcmVnZXhwQXJyYXkpIHtcclxuICAgICAgICAvLyAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVW5hYmxlIHRvIHJlY29nbml6ZWQgc2VhcmNoZWQgcGF0dGVybiBpbiBjdXJyZW50IHVybCBsb2NhdGlvbiB0byByZXRyaWV2ZSBzZXNzaW9uSUQuJyk7XHJcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyAgICAgaWYgKHJlZ2V4cEFycmF5Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIC8vICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdVbmFibGUgdG8gZmluZCBzZXNzaW9uSUQgaW4gc2VhcmNoZWQgcGF0dGVybiBpbiBjdXJyZW50IHVybC4nKTtcclxuICAgICAgICAvLyAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vICAgICBpZiAocmVnZXhwQXJyYXkubGVuZ3RoID4gMikge1xyXG4gICAgICAgIC8vICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdUb28gbWFueSBtYXRjaGVzIGZvdW5kIGZvciB0aGUgc2Vzc2lvbklEIHNlYXJjaCBpbiB0aGUgY3VycmVudCB1cmwuJyk7XHJcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgLy8gICAgIH1cclxuXHJcbiAgICAgICAgLy8gICAgIHJldHVybiByZWdleHBBcnJheVsxXTtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyaW0gdGhlIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyIHRvIHJldHVybiBvbmx5IHRoZSBmaWxlbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0gY29udGVudERpc3Bvc2l0aW9uSGVhZGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBnZXRGaWxlTmFtZUZyb21IZWFkZXJDb250ZW50RGlzcG9zaXRpb24oY29udGVudERpc3Bvc2l0aW9uSGVhZGVyOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcikgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBjb250ZW50RGlzcG9zaXRpb25IZWFkZXIuc3BsaXQoJzsnKVsxXS50cmltKCkuc3BsaXQoJz0nKVsxXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVwbGFjZSgvXCIvZywgJycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8jZW5kcmVnaW9uXHJcbiAgICB9XHJcbn0iXX0=
